{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallbackWorkflow = void 0;\nconst bson_1 = require(\"bson\");\nconst error_1 = require(\"../../../error\");\nconst utils_1 = require(\"../../../utils\");\nconst providers_1 = require(\"../providers\");\nconst token_entry_cache_1 = require(\"./token_entry_cache\");\n/* 5 minutes in milliseconds */\nconst TIMEOUT_MS = 300000;\n/**\n * OIDC implementation of a callback based workflow.\n * @internal\n */\nclass CallbackWorkflow {\n  /**\n   * Instantiate the workflow\n   */\n  constructor() {\n    this.cache = new token_entry_cache_1.TokenEntryCache();\n  }\n  /**\n   * Get the document to add for speculative authentication. Is empty when\n   * callbacks are in play.\n   */\n  speculativeAuth() {\n    return Promise.resolve({});\n  }\n  /**\n   * Execute the workflow.\n   *\n   * Steps:\n   * - If an entry is in the cache\n   *   - If it is not expired\n   *     - Skip step one and use the entry to execute step two.\n   *   - If it is expired\n   *     - If the refresh callback exists\n   *       - remove expired entry from cache\n   *       - call the refresh callback.\n   *       - put the new entry in the cache.\n   *       - execute step two.\n   *     - If the refresh callback does not exist.\n   *       - remove expired entry from cache\n   *       - call the request callback.\n   *       - put the new entry in the cache.\n   *       - execute step two.\n   * - If no entry is in the cache.\n   *   - execute step one.\n   *   - call the refresh callback.\n   *   - put the new entry in the cache.\n   *   - execute step two.\n   */\n  async execute(connection, credentials) {\n    let reauthenticate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const request = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n    const refresh = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;\n    const entry = this.cache.getEntry(connection.address, credentials.username, request || null, refresh || null);\n    if (entry) {\n      // Check if the entry is not expired and if we are reauthenticating.\n      if (!reauthenticate && entry.isValid()) {\n        // Skip step one and execute the step two saslContinue.\n        try {\n          const result = await finishAuth(entry.tokenResult, undefined, connection, credentials);\n          return result;\n        } catch (error) {\n          // If authentication errors when using a cached token we remove it from\n          // the cache.\n          this.cache.deleteEntry(connection.address, credentials.username || '', request || null, refresh || null);\n          throw error;\n        }\n      } else {\n        // Remove the expired entry from the cache.\n        this.cache.deleteEntry(connection.address, credentials.username || '', request || null, refresh || null);\n        // Execute a refresh of the token and finish auth.\n        return this.refreshAndFinish(connection, credentials, entry.serverResult, entry.tokenResult);\n      }\n    } else {\n      // No entry means to start with the step one saslStart.\n      const result = await connection.commandAsync((0, utils_1.ns)(credentials.source), startCommandDocument(credentials), undefined);\n      const stepOne = bson_1.BSON.deserialize(result.payload.buffer);\n      // Call the request callback and finish auth.\n      return this.requestAndFinish(connection, credentials, stepOne, result.conversationId);\n    }\n  }\n  /**\n   * Execute the refresh callback if it exists, otherwise the request callback, then\n   * finish the authentication.\n   */\n  async refreshAndFinish(connection, credentials, stepOneResult, tokenResult, conversationId) {\n    const request = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n    const refresh = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;\n    // If a refresh callback exists, use it. Otherwise use the request callback.\n    if (refresh) {\n      const result = await refresh(credentials.username, stepOneResult, tokenResult, TIMEOUT_MS);\n      // Validate the result.\n      if (!result || !result.accessToken) {\n        throw new error_1.MongoMissingCredentialsError('REFRESH_TOKEN_CALLBACK must return a valid object with an accessToken');\n      }\n      // Cache a new entry and continue with the saslContinue.\n      this.cache.addEntry(connection.address, credentials.username || '', request || null, refresh, result, stepOneResult);\n      return finishAuth(result, conversationId, connection, credentials);\n    } else {\n      // Fallback to using the request callback.\n      return this.requestAndFinish(connection, credentials, stepOneResult, conversationId);\n    }\n  }\n  /**\n   * Execute the request callback and finish authentication.\n   */\n  async requestAndFinish(connection, credentials, stepOneResult, conversationId) {\n    // Call the request callback.\n    const request = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n    const refresh = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;\n    // Always clear expired entries from the cache on each finish as cleanup.\n    this.cache.deleteExpiredEntries();\n    if (!request) {\n      // Request callback must be present.\n      throw new error_1.MongoInvalidArgumentError('Auth mechanism property REQUEST_TOKEN_CALLBACK is required.');\n    }\n    const tokenResult = await request(credentials.username, stepOneResult, TIMEOUT_MS);\n    // Validate the result.\n    if (!tokenResult || !tokenResult.accessToken) {\n      throw new error_1.MongoMissingCredentialsError('REQUEST_TOKEN_CALLBACK must return a valid object with an accessToken');\n    }\n    // Cache a new entry and continue with the saslContinue.\n    this.cache.addEntry(connection.address, credentials.username || '', request, refresh || null, tokenResult, stepOneResult);\n    return finishAuth(tokenResult, conversationId, connection, credentials);\n  }\n}\nexports.CallbackWorkflow = CallbackWorkflow;\n/**\n * Cache the result of the user supplied callback and execute the\n * step two saslContinue.\n */\nasync function finishAuth(result, conversationId, connection, credentials) {\n  // Execute the step two saslContinue.\n  return connection.commandAsync((0, utils_1.ns)(credentials.source), continueCommandDocument(result.accessToken, conversationId), undefined);\n}\n/**\n * Generate the saslStart command document.\n */\nfunction startCommandDocument(credentials) {\n  const payload = {};\n  if (credentials.username) {\n    payload.n = credentials.username;\n  }\n  return {\n    saslStart: 1,\n    autoAuthorize: 1,\n    mechanism: providers_1.AuthMechanism.MONGODB_OIDC,\n    payload: new bson_1.Binary(bson_1.BSON.serialize(payload))\n  };\n}\n/**\n * Generate the saslContinue command document.\n */\nfunction continueCommandDocument(token, conversationId) {\n  if (conversationId) {\n    return {\n      saslContinue: 1,\n      conversationId: conversationId,\n      payload: new bson_1.Binary(bson_1.BSON.serialize({\n        jwt: token\n      }))\n    };\n  }\n  // saslContinue requires a conversationId in the command to be valid so in this\n  // case the server allows \"step two\" to actually be a saslStart with the token\n  // as the jwt since the use of the cached value has no correlating conversating\n  // on the particular connection.\n  return {\n    saslStart: 1,\n    mechanism: providers_1.AuthMechanism.MONGODB_OIDC,\n    payload: new bson_1.Binary(bson_1.BSON.serialize({\n      jwt: token\n    }))\n  };\n}","map":{"version":3,"names":["bson_1","require","error_1","utils_1","providers_1","token_entry_cache_1","TIMEOUT_MS","CallbackWorkflow","constructor","cache","TokenEntryCache","speculativeAuth","Promise","resolve","execute","connection","credentials","reauthenticate","arguments","length","undefined","request","mechanismProperties","REQUEST_TOKEN_CALLBACK","refresh","REFRESH_TOKEN_CALLBACK","entry","getEntry","address","username","isValid","result","finishAuth","tokenResult","error","deleteEntry","refreshAndFinish","serverResult","commandAsync","ns","source","startCommandDocument","stepOne","BSON","deserialize","payload","buffer","requestAndFinish","conversationId","stepOneResult","accessToken","MongoMissingCredentialsError","addEntry","deleteExpiredEntries","MongoInvalidArgumentError","exports","continueCommandDocument","n","saslStart","autoAuthorize","mechanism","AuthMechanism","MONGODB_OIDC","Binary","serialize","token","saslContinue","jwt"],"sources":["C:\\Users\\sama\\Documents\\fullpage\\node_modules\\mongodb\\src\\cmap\\auth\\mongodb_oidc\\callback_workflow.ts"],"sourcesContent":["import { Binary, BSON, type Document } from 'bson';\n\nimport { MongoInvalidArgumentError, MongoMissingCredentialsError } from '../../../error';\nimport { ns } from '../../../utils';\nimport type { Connection } from '../../connection';\nimport type { MongoCredentials } from '../mongo_credentials';\nimport type { OIDCMechanismServerStep1, OIDCRequestTokenResult } from '../mongodb_oidc';\nimport { AuthMechanism } from '../providers';\nimport { TokenEntryCache } from './token_entry_cache';\nimport type { Workflow } from './workflow';\n\n/* 5 minutes in milliseconds */\nconst TIMEOUT_MS = 300000;\n\n/**\n * OIDC implementation of a callback based workflow.\n * @internal\n */\nexport class CallbackWorkflow implements Workflow {\n  cache: TokenEntryCache;\n\n  /**\n   * Instantiate the workflow\n   */\n  constructor() {\n    this.cache = new TokenEntryCache();\n  }\n\n  /**\n   * Get the document to add for speculative authentication. Is empty when\n   * callbacks are in play.\n   */\n  speculativeAuth(): Promise<Document> {\n    return Promise.resolve({});\n  }\n\n  /**\n   * Execute the workflow.\n   *\n   * Steps:\n   * - If an entry is in the cache\n   *   - If it is not expired\n   *     - Skip step one and use the entry to execute step two.\n   *   - If it is expired\n   *     - If the refresh callback exists\n   *       - remove expired entry from cache\n   *       - call the refresh callback.\n   *       - put the new entry in the cache.\n   *       - execute step two.\n   *     - If the refresh callback does not exist.\n   *       - remove expired entry from cache\n   *       - call the request callback.\n   *       - put the new entry in the cache.\n   *       - execute step two.\n   * - If no entry is in the cache.\n   *   - execute step one.\n   *   - call the refresh callback.\n   *   - put the new entry in the cache.\n   *   - execute step two.\n   */\n  async execute(\n    connection: Connection,\n    credentials: MongoCredentials,\n    reauthenticate = false\n  ): Promise<Document> {\n    const request = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n    const refresh = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;\n\n    const entry = this.cache.getEntry(\n      connection.address,\n      credentials.username,\n      request || null,\n      refresh || null\n    );\n    if (entry) {\n      // Check if the entry is not expired and if we are reauthenticating.\n      if (!reauthenticate && entry.isValid()) {\n        // Skip step one and execute the step two saslContinue.\n        try {\n          const result = await finishAuth(entry.tokenResult, undefined, connection, credentials);\n          return result;\n        } catch (error) {\n          // If authentication errors when using a cached token we remove it from\n          // the cache.\n          this.cache.deleteEntry(\n            connection.address,\n            credentials.username || '',\n            request || null,\n            refresh || null\n          );\n          throw error;\n        }\n      } else {\n        // Remove the expired entry from the cache.\n        this.cache.deleteEntry(\n          connection.address,\n          credentials.username || '',\n          request || null,\n          refresh || null\n        );\n        // Execute a refresh of the token and finish auth.\n        return this.refreshAndFinish(\n          connection,\n          credentials,\n          entry.serverResult,\n          entry.tokenResult\n        );\n      }\n    } else {\n      // No entry means to start with the step one saslStart.\n      const result = await connection.commandAsync(\n        ns(credentials.source),\n        startCommandDocument(credentials),\n        undefined\n      );\n      const stepOne = BSON.deserialize(result.payload.buffer) as OIDCMechanismServerStep1;\n      // Call the request callback and finish auth.\n      return this.requestAndFinish(connection, credentials, stepOne, result.conversationId);\n    }\n  }\n\n  /**\n   * Execute the refresh callback if it exists, otherwise the request callback, then\n   * finish the authentication.\n   */\n  private async refreshAndFinish(\n    connection: Connection,\n    credentials: MongoCredentials,\n    stepOneResult: OIDCMechanismServerStep1,\n    tokenResult: OIDCRequestTokenResult,\n    conversationId?: number\n  ): Promise<Document> {\n    const request = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n    const refresh = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;\n    // If a refresh callback exists, use it. Otherwise use the request callback.\n    if (refresh) {\n      const result: OIDCRequestTokenResult = await refresh(\n        credentials.username,\n        stepOneResult,\n        tokenResult,\n        TIMEOUT_MS\n      );\n      // Validate the result.\n      if (!result || !result.accessToken) {\n        throw new MongoMissingCredentialsError(\n          'REFRESH_TOKEN_CALLBACK must return a valid object with an accessToken'\n        );\n      }\n      // Cache a new entry and continue with the saslContinue.\n      this.cache.addEntry(\n        connection.address,\n        credentials.username || '',\n        request || null,\n        refresh,\n        result,\n        stepOneResult\n      );\n      return finishAuth(result, conversationId, connection, credentials);\n    } else {\n      // Fallback to using the request callback.\n      return this.requestAndFinish(connection, credentials, stepOneResult, conversationId);\n    }\n  }\n\n  /**\n   * Execute the request callback and finish authentication.\n   */\n  private async requestAndFinish(\n    connection: Connection,\n    credentials: MongoCredentials,\n    stepOneResult: OIDCMechanismServerStep1,\n    conversationId?: number\n  ): Promise<Document> {\n    // Call the request callback.\n    const request = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n    const refresh = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;\n    // Always clear expired entries from the cache on each finish as cleanup.\n    this.cache.deleteExpiredEntries();\n    if (!request) {\n      // Request callback must be present.\n      throw new MongoInvalidArgumentError(\n        'Auth mechanism property REQUEST_TOKEN_CALLBACK is required.'\n      );\n    }\n    const tokenResult = await request(credentials.username, stepOneResult, TIMEOUT_MS);\n    // Validate the result.\n    if (!tokenResult || !tokenResult.accessToken) {\n      throw new MongoMissingCredentialsError(\n        'REQUEST_TOKEN_CALLBACK must return a valid object with an accessToken'\n      );\n    }\n    // Cache a new entry and continue with the saslContinue.\n    this.cache.addEntry(\n      connection.address,\n      credentials.username || '',\n      request,\n      refresh || null,\n      tokenResult,\n      stepOneResult\n    );\n    return finishAuth(tokenResult, conversationId, connection, credentials);\n  }\n}\n\n/**\n * Cache the result of the user supplied callback and execute the\n * step two saslContinue.\n */\nasync function finishAuth(\n  result: OIDCRequestTokenResult,\n  conversationId: number | undefined,\n  connection: Connection,\n  credentials: MongoCredentials\n): Promise<Document> {\n  // Execute the step two saslContinue.\n  return connection.commandAsync(\n    ns(credentials.source),\n    continueCommandDocument(result.accessToken, conversationId),\n    undefined\n  );\n}\n\n/**\n * Generate the saslStart command document.\n */\nfunction startCommandDocument(credentials: MongoCredentials): Document {\n  const payload: Document = {};\n  if (credentials.username) {\n    payload.n = credentials.username;\n  }\n  return {\n    saslStart: 1,\n    autoAuthorize: 1,\n    mechanism: AuthMechanism.MONGODB_OIDC,\n    payload: new Binary(BSON.serialize(payload))\n  };\n}\n\n/**\n * Generate the saslContinue command document.\n */\nfunction continueCommandDocument(token: string, conversationId?: number): Document {\n  if (conversationId) {\n    return {\n      saslContinue: 1,\n      conversationId: conversationId,\n      payload: new Binary(BSON.serialize({ jwt: token }))\n    };\n  }\n  // saslContinue requires a conversationId in the command to be valid so in this\n  // case the server allows \"step two\" to actually be a saslStart with the token\n  // as the jwt since the use of the cached value has no correlating conversating\n  // on the particular connection.\n  return {\n    saslStart: 1,\n    mechanism: AuthMechanism.MONGODB_OIDC,\n    payload: new Binary(BSON.serialize({ jwt: token }))\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}