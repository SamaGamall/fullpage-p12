{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst $exists = require('./operators/exists');\nconst $type = require('./operators/type');\nconst MongooseError = require('../error/mongooseError');\nconst SchemaArrayOptions = require('../options/SchemaArrayOptions');\nconst SchemaType = require('../schematype');\nconst CastError = SchemaType.CastError;\nconst Mixed = require('./mixed');\nconst arrayDepth = require('../helpers/arrayDepth');\nconst cast = require('../cast');\nconst clone = require('../helpers/clone');\nconst isOperator = require('../helpers/query/isOperator');\nconst util = require('util');\nconst utils = require('../utils');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst geospatial = require('./operators/geospatial');\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\nlet MongooseArray;\nlet EmbeddedDoc;\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\nconst emptyOpts = Object.freeze({});\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n  if (cast) {\n    let castOptions = {};\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n    if (options != null && options.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string' ? cast : utils.getFunctionName(cast);\n    const Types = require('./index.js');\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n    this.casterConstructor = caster;\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n    if (typeof caster === 'function' && !caster.$isArraySubdocument && !caster.$isSchemaMap) {\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\n      this.caster = new caster(path, castOptions);\n    } else {\n      this.caster = caster;\n      if (!(this.caster instanceof EmbeddedDoc)) {\n        this.caster.path = key;\n      }\n    }\n    this.$embeddedSchemaType = this.caster;\n  }\n  this.$isMongooseArray = true;\n  SchemaType.call(this, key, options, 'Array');\n  let defaultArr;\n  let fn;\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function () {\n      // Leave it up to `cast()` to convert the array\n      return fn ? defaultArr.call(this) : defaultArr != null ? [].concat(defaultArr) : [];\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static\n * @api public\n */\n\nSchemaArray.options = {\n  castNonArrays: true\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * #### Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @api public\n */\nSchemaArray.set = SchemaType.set;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ? this.constructor.checkRequired() : SchemaArray.checkRequired();\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {...String|Object} [args] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function () {\n  let arr = this;\n  while (true) {\n    const instance = arr && arr.caster && arr.caster.instance;\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' + ', not ' + instance);\n    }\n    break;\n  }\n  let enumArray = arguments;\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n  arr.caster.enum.apply(arr.caster, enumArray);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function (value, scope) {\n  if (scope != null && scope.$__ != null && scope.$populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n  if (Array.isArray(ret)) {\n    const rawValue = utils.isMongooseArray(ret) ? ret.__array : ret;\n    const len = rawValue.length;\n    for (let i = 0; i < len; ++i) {\n      rawValue[i] = this.caster.applyGetters(rawValue[i], scope);\n    }\n  }\n  return ret;\n};\nSchemaArray.prototype._applySetters = function (value, scope, init, priorVal) {\n  if (this.casterConstructor.$isMongooseArray && SchemaArray.options.castNonArrays && !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null && arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length !== 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n  let i;\n  let l;\n  if (Array.isArray(value)) {\n    const len = value.length;\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ? this.path.substring(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n    options = options || emptyOpts;\n    let rawValue = utils.isMongooseArray(value) ? value.__array : value;\n    value = MongooseArray(rawValue, options.path || this._arrayPath || this.path, doc, this);\n    rawValue = value.__array;\n    if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {\n      return value;\n    }\n    const caster = this.caster;\n    const isMongooseArray = caster.$isMongooseArray;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        const len = rawValue.length;\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n    return value;\n  }\n  const castNonArraysOption = this.options.castNonArrays != null ? this.options.castNonArrays : SchemaArray.options.castNonArrays;\n  if (init || castNonArraysOption) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n  if (Array.isArray(value)) {\n    let i;\n    const rawValue = value.__array ? value.__array : value;\n    const len = rawValue.length;\n    const caster = this.caster;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n          rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n    return value;\n  }\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.discriminator = function () {\n  let arr = this;\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' + 'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(...arguments);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\nSchemaArray.prototype._castForQuery = function (val, context) {\n  let Constructor = this.casterConstructor;\n  if (val && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {\n    if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n  const proto = this.casterConstructor.prototype;\n  const protoCastForQuery = proto && proto.castForQuery;\n  const protoCast = proto && proto.cast;\n  const constructorCastForQuery = Constructor.castForQuery;\n  const caster = this.caster;\n  if (Array.isArray(val)) {\n    this.setters.reverse().forEach(setter => {\n      val = setter.call(this, val, this);\n    });\n    val = val.map(function (v) {\n      if (utils.isObject(v) && v.$elemMatch) {\n        return v;\n      }\n      if (protoCastForQuery) {\n        v = protoCastForQuery.call(caster, null, v, context);\n        return v;\n      } else if (protoCast) {\n        v = protoCast.call(caster, v);\n        return v;\n      } else if (constructorCastForQuery) {\n        v = constructorCastForQuery.call(caster, null, v, context);\n        return v;\n      }\n      if (v != null) {\n        v = new Constructor(v);\n        return v;\n      }\n      return v;\n    });\n  } else if (protoCastForQuery) {\n    val = protoCastForQuery.call(caster, null, val, context);\n  } else if (protoCast) {\n    val = protoCast.call(caster, val);\n  } else if (constructorCastForQuery) {\n    val = constructorCastForQuery.call(caster, null, val, context);\n  } else if (val != null) {\n    val = new Constructor(val);\n  }\n  return val;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function ($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n    return handler.call(this, val, context);\n  } else {\n    return this._castForQuery(val, context);\n  }\n};\nfunction cast$all(val, context) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n  val = val.map(v => {\n    if (!utils.isObject(v)) {\n      return v;\n    }\n    if (v.$elemMatch != null) {\n      return {\n        $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch, null, this && this.$$context)\n      };\n    }\n    const o = {};\n    o[this.path] = v;\n    return cast(this.casterConstructor.schema, o, null, this && this.$$context)[this.path];\n  }, this);\n  return this.castForQuery(null, val, context);\n}\nfunction cast$elemMatch(val, context) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value, context);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.options && this.casterConstructor.schema.options.discriminatorKey;\n  const discriminators = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.discriminators || {};\n  if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val, null, this && this.$$context);\n  }\n  return cast(this.casterConstructor.schema, val, null, this && this.$$context);\n}\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n    const ret = [];\n    for (const obj of val) {\n      ret.push(cast(this.casterConstructor.schema, obj, null, this && this.$$context));\n    }\n    return ret;\n  };\n}\nhandle.$near = handle.$nearSphere = geospatial.cast$near;\nhandle.$within = handle.$geoWithin = geospatial.cast$within;\nhandle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;\nhandle.$exists = $exists;\nhandle.$type = $type;\nhandle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$not = handle.$regex = handle.$ne = SchemaArray.prototype._castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;","map":{"version":3,"names":["$exists","require","$type","MongooseError","SchemaArrayOptions","SchemaType","CastError","Mixed","arrayDepth","cast","clone","isOperator","util","utils","castToNumber","geospatial","getDiscriminatorByValue","MongooseArray","EmbeddedDoc","isNestedArraySymbol","Symbol","emptyOpts","Object","freeze","SchemaArray","key","options","schemaOptions","Embedded","typeKey","castOptions","isPOJO","ref","name","getFunctionName","Types","caster","hasOwnProperty","casterConstructor","$isArraySubdocument","$isSchemaMap","path","$embeddedSchemaType","$isMongooseArray","call","defaultArr","fn","defaultValue","defaultFn","concat","$runBeforeSetters","default","schemaName","castNonArrays","defaultOptions","set","prototype","create","constructor","OptionsConstructor","_checkRequired","checkRequired","value","doc","_isRef","enum","arr","instance","Error","enumArray","arguments","Array","isArray","isObject","object","vals","apply","applyGetters","scope","$__","$populated","ret","rawValue","isMongooseArray","__array","len","length","i","_applySetters","init","priorVal","depth","$isMongooseDocumentArray","valueDepth","min","max","containsNonArrayItem","prev","l","indexes","schema","indexedPaths","arrayPath","pathIndex","arrayGeojsonPath","endsWith","substring","lastIndexOf","_arrayPath","opts","arrayPathIndex","_arrayParentPath","applySetters","e","kind","inspect","castNonArraysOption","markModified","_castForPopulate","$toObject","toObject","discriminator","assign","schematype","validators","slice","requiredValidator","undefined","_castForQuery","val","context","Constructor","discriminators","discriminatorKey","constructorByValue","proto","protoCastForQuery","castForQuery","protoCast","constructorCastForQuery","setters","reverse","forEach","setter","map","v","$elemMatch","$conditional","handler","$conditionalHandlers","cast$all","$$context","o","cast$elemMatch","keys","numKeys","handle","$all","$options","String","$geoIntersects","cast$geoIntersects","$or","createLogicalQueryOperatorHandler","$and","$nor","op","logicalQueryOperatorHandler","TypeError","obj","push","$near","$nearSphere","cast$near","$within","$geoWithin","cast$within","$size","$minDistance","$maxDistance","$eq","$gt","$gte","$lt","$lte","$not","$regex","$ne","$nin","$in","module","exports"],"sources":["C:/Users/sama/Documents/fullpage/node_modules/mongoose/lib/schema/array.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst $exists = require('./operators/exists');\nconst $type = require('./operators/type');\nconst MongooseError = require('../error/mongooseError');\nconst SchemaArrayOptions = require('../options/SchemaArrayOptions');\nconst SchemaType = require('../schematype');\nconst CastError = SchemaType.CastError;\nconst Mixed = require('./mixed');\nconst arrayDepth = require('../helpers/arrayDepth');\nconst cast = require('../cast');\nconst clone = require('../helpers/clone');\nconst isOperator = require('../helpers/query/isOperator');\nconst util = require('util');\nconst utils = require('../utils');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst geospatial = require('./operators/geospatial');\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\n\nlet MongooseArray;\nlet EmbeddedDoc;\n\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\nconst emptyOpts = Object.freeze({});\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (options != null && options.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string'\n      ? cast\n      : utils.getFunctionName(cast);\n\n    const Types = require('./index.js');\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n\n    this.casterConstructor = caster;\n\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n\n    if (typeof caster === 'function' &&\n        !caster.$isArraySubdocument &&\n        !caster.$isSchemaMap) {\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\n      this.caster = new caster(path, castOptions);\n    } else {\n      this.caster = caster;\n      if (!(this.caster instanceof EmbeddedDoc)) {\n        this.caster.path = key;\n      }\n    }\n\n    this.$embeddedSchemaType = this.caster;\n  }\n\n  this.$isMongooseArray = true;\n\n  SchemaType.call(this, key, options, 'Array');\n\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function() {\n      // Leave it up to `cast()` to convert the array\n      return fn\n        ? defaultArr.call(this)\n        : defaultArr != null\n          ? [].concat(defaultArr)\n          : [];\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static\n * @api public\n */\n\nSchemaArray.options = { castNonArrays: true };\n\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * #### Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @api public\n */\nSchemaArray.set = SchemaType.set;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {...String|Object} [args] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function() {\n  let arr = this;\n  while (true) {\n    const instance = arr &&\n    arr.caster &&\n    arr.caster.instance;\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' +\n        ', not ' + instance);\n    }\n    break;\n  }\n\n  let enumArray = arguments;\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n\n  arr.caster.enum.apply(arr.caster, enumArray);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (scope != null && scope.$__ != null && scope.$populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n  if (Array.isArray(ret)) {\n    const rawValue = utils.isMongooseArray(ret) ? ret.__array : ret;\n    const len = rawValue.length;\n    for (let i = 0; i < len; ++i) {\n      rawValue[i] = this.caster.applyGetters(rawValue[i], scope);\n    }\n  }\n  return ret;\n};\n\nSchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {\n  if (this.casterConstructor.$isMongooseArray &&\n      SchemaArray.options.castNonArrays &&\n      !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null &&\n      arr.$isMongooseArray &&\n      !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length !== 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    const len = value.length;\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ?\n        this.path.substring(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    options = options || emptyOpts;\n\n    let rawValue = utils.isMongooseArray(value) ? value.__array : value;\n    value = MongooseArray(rawValue, options.path || this._arrayPath || this.path, doc, this);\n    rawValue = value.__array;\n\n    if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {\n      return value;\n    }\n\n    const caster = this.caster;\n    const isMongooseArray = caster.$isMongooseArray;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        const len = rawValue.length;\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  const castNonArraysOption = this.options.castNonArrays != null ? this.options.castNonArrays : SchemaArray.options.castNonArrays;\n  if (init || castNonArraysOption) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  if (Array.isArray(value)) {\n    let i;\n    const rawValue = value.__array ? value.__array : value;\n    const len = rawValue.length;\n\n    const caster = this.caster;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n\n          rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.discriminator = function(...args) {\n  let arr = this;\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' +\n        'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(...args);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\n\nSchemaArray.prototype._castForQuery = function(val, context) {\n  let Constructor = this.casterConstructor;\n\n  if (val &&\n      Constructor.discriminators &&\n      Constructor.schema &&\n      Constructor.schema.options &&\n      Constructor.schema.options.discriminatorKey) {\n    if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\n        Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  const proto = this.casterConstructor.prototype;\n  const protoCastForQuery = proto && proto.castForQuery;\n  const protoCast = proto && proto.cast;\n  const constructorCastForQuery = Constructor.castForQuery;\n  const caster = this.caster;\n\n  if (Array.isArray(val)) {\n    this.setters.reverse().forEach(setter => {\n      val = setter.call(this, val, this);\n    });\n    val = val.map(function(v) {\n      if (utils.isObject(v) && v.$elemMatch) {\n        return v;\n      }\n      if (protoCastForQuery) {\n        v = protoCastForQuery.call(caster, null, v, context);\n        return v;\n      } else if (protoCast) {\n        v = protoCast.call(caster, v);\n        return v;\n      } else if (constructorCastForQuery) {\n        v = constructorCastForQuery.call(caster, null, v, context);\n        return v;\n      }\n      if (v != null) {\n        v = new Constructor(v);\n        return v;\n      }\n      return v;\n    });\n  } else if (protoCastForQuery) {\n    val = protoCastForQuery.call(caster, null, val, context);\n  } else if (protoCast) {\n    val = protoCast.call(caster, val);\n  } else if (constructorCastForQuery) {\n    val = constructorCastForQuery.call(caster, null, val, context);\n  } else if (val != null) {\n    val = new Constructor(val);\n  }\n\n  return val;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    return handler.call(this, val, context);\n  } else {\n    return this._castForQuery(val, context);\n  }\n};\n\nfunction cast$all(val, context) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map((v) => {\n    if (!utils.isObject(v)) {\n      return v;\n    }\n    if (v.$elemMatch != null) {\n      return { $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch, null, this && this.$$context) };\n    }\n\n    const o = {};\n    o[this.path] = v;\n    return cast(this.casterConstructor.schema, o, null, this && this.$$context)[this.path];\n  }, this);\n\n  return this.castForQuery(null, val, context);\n}\n\nfunction cast$elemMatch(val, context) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value, context);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = this &&\n    this.casterConstructor &&\n    this.casterConstructor.schema &&\n    this.casterConstructor.schema.options &&\n    this.casterConstructor.schema.options.discriminatorKey;\n  const discriminators = this &&\n  this.casterConstructor &&\n  this.casterConstructor.schema &&\n  this.casterConstructor.schema.discriminators || {};\n  if (discriminatorKey != null &&\n      val[discriminatorKey] != null &&\n      discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val, null, this && this.$$context);\n  }\n\n  return cast(this.casterConstructor.schema, val, null, this && this.$$context);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\n\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n\n    const ret = [];\n    for (const obj of val) {\n      ret.push(cast(this.casterConstructor.schema, obj, null, this && this.$$context));\n    }\n\n    return ret;\n  };\n}\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$lt =\nhandle.$lte =\nhandle.$not =\nhandle.$regex =\nhandle.$ne = SchemaArray.prototype._castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAC7C,MAAMC,KAAK,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AACzC,MAAME,aAAa,GAAGF,OAAO,CAAC,wBAAwB,CAAC;AACvD,MAAMG,kBAAkB,GAAGH,OAAO,CAAC,+BAA+B,CAAC;AACnE,MAAMI,UAAU,GAAGJ,OAAO,CAAC,eAAe,CAAC;AAC3C,MAAMK,SAAS,GAAGD,UAAU,CAACC,SAAS;AACtC,MAAMC,KAAK,GAAGN,OAAO,CAAC,SAAS,CAAC;AAChC,MAAMO,UAAU,GAAGP,OAAO,CAAC,uBAAuB,CAAC;AACnD,MAAMQ,IAAI,GAAGR,OAAO,CAAC,SAAS,CAAC;AAC/B,MAAMS,KAAK,GAAGT,OAAO,CAAC,kBAAkB,CAAC;AACzC,MAAMU,UAAU,GAAGV,OAAO,CAAC,6BAA6B,CAAC;AACzD,MAAMW,IAAI,GAAGX,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMY,KAAK,GAAGZ,OAAO,CAAC,UAAU,CAAC;AACjC,MAAMa,YAAY,GAAGb,OAAO,CAAC,qBAAqB,CAAC,CAACa,YAAY;AAChE,MAAMC,UAAU,GAAGd,OAAO,CAAC,wBAAwB,CAAC;AACpD,MAAMe,uBAAuB,GAAGf,OAAO,CAAC,kDAAkD,CAAC;AAE3F,IAAIgB,aAAa;AACjB,IAAIC,WAAW;AAEf,MAAMC,mBAAmB,GAAGC,MAAM,CAAC,wBAAwB,CAAC;AAC5D,MAAMC,SAAS,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,WAAWA,CAACC,GAAG,EAAEhB,IAAI,EAAEiB,OAAO,EAAEC,aAAa,EAAE;EACtD;EACAT,WAAW,KAAKA,WAAW,GAAGjB,OAAO,CAAC,UAAU,CAAC,CAAC2B,QAAQ,CAAC;EAE3D,IAAIC,OAAO,GAAG,MAAM;EACpB,IAAIF,aAAa,IAAIA,aAAa,CAACE,OAAO,EAAE;IAC1CA,OAAO,GAAGF,aAAa,CAACE,OAAO;EACjC;EACA,IAAI,CAACF,aAAa,GAAGA,aAAa;EAElC,IAAIlB,IAAI,EAAE;IACR,IAAIqB,WAAW,GAAG,CAAC,CAAC;IAEpB,IAAIjB,KAAK,CAACkB,MAAM,CAACtB,IAAI,CAAC,EAAE;MACtB,IAAIA,IAAI,CAACoB,OAAO,CAAC,EAAE;QACjB;QACAC,WAAW,GAAGpB,KAAK,CAACD,IAAI,CAAC,CAAC,CAAC;QAC3B,OAAOqB,WAAW,CAACD,OAAO,CAAC;QAC3BpB,IAAI,GAAGA,IAAI,CAACoB,OAAO,CAAC;MACtB,CAAC,MAAM;QACLpB,IAAI,GAAGF,KAAK;MACd;IACF;IAEA,IAAImB,OAAO,IAAI,IAAI,IAAIA,OAAO,CAACM,GAAG,IAAI,IAAI,IAAIF,WAAW,CAACE,GAAG,IAAI,IAAI,EAAE;MACrEF,WAAW,CAACE,GAAG,GAAGN,OAAO,CAACM,GAAG;IAC/B;IAEA,IAAIvB,IAAI,KAAKa,MAAM,EAAE;MACnBb,IAAI,GAAGF,KAAK;IACd;;IAEA;IACA,MAAM0B,IAAI,GAAG,OAAOxB,IAAI,KAAK,QAAQ,GACjCA,IAAI,GACJI,KAAK,CAACqB,eAAe,CAACzB,IAAI,CAAC;IAE/B,MAAM0B,KAAK,GAAGlC,OAAO,CAAC,YAAY,CAAC;IACnC,MAAMmC,MAAM,GAAGD,KAAK,CAACE,cAAc,CAACJ,IAAI,CAAC,GAAGE,KAAK,CAACF,IAAI,CAAC,GAAGxB,IAAI;IAE9D,IAAI,CAAC6B,iBAAiB,GAAGF,MAAM;IAE/B,IAAI,IAAI,CAACE,iBAAiB,YAAYd,WAAW,EAAE;MACjD,IAAI,CAACc,iBAAiB,CAACnB,mBAAmB,CAAC,GAAG,IAAI;IACpD;IAEA,IAAI,OAAOiB,MAAM,KAAK,UAAU,IAC5B,CAACA,MAAM,CAACG,mBAAmB,IAC3B,CAACH,MAAM,CAACI,YAAY,EAAE;MACxB,MAAMC,IAAI,GAAG,IAAI,CAACL,MAAM,YAAYlB,WAAW,GAAG,IAAI,GAAGO,GAAG;MAC5D,IAAI,CAACW,MAAM,GAAG,IAAIA,MAAM,CAACK,IAAI,EAAEX,WAAW,CAAC;IAC7C,CAAC,MAAM;MACL,IAAI,CAACM,MAAM,GAAGA,MAAM;MACpB,IAAI,EAAE,IAAI,CAACA,MAAM,YAAYlB,WAAW,CAAC,EAAE;QACzC,IAAI,CAACkB,MAAM,CAACK,IAAI,GAAGhB,GAAG;MACxB;IACF;IAEA,IAAI,CAACiB,mBAAmB,GAAG,IAAI,CAACN,MAAM;EACxC;EAEA,IAAI,CAACO,gBAAgB,GAAG,IAAI;EAE5BtC,UAAU,CAACuC,IAAI,CAAC,IAAI,EAAEnB,GAAG,EAAEC,OAAO,EAAE,OAAO,CAAC;EAE5C,IAAImB,UAAU;EACd,IAAIC,EAAE;EAEN,IAAI,IAAI,CAACC,YAAY,IAAI,IAAI,EAAE;IAC7BF,UAAU,GAAG,IAAI,CAACE,YAAY;IAC9BD,EAAE,GAAG,OAAOD,UAAU,KAAK,UAAU;EACvC;EAEA,IAAI,EAAE,cAAc,IAAI,IAAI,CAAC,IAAI,IAAI,CAACE,YAAY,KAAK,KAAK,CAAC,EAAE;IAC7D,MAAMC,SAAS,GAAG,SAAAA,CAAA,EAAW;MAC3B;MACA,OAAOF,EAAE,GACLD,UAAU,CAACD,IAAI,CAAC,IAAI,CAAC,GACrBC,UAAU,IAAI,IAAI,GAChB,EAAE,CAACI,MAAM,CAACJ,UAAU,CAAC,GACrB,EAAE;IACV,CAAC;IACDG,SAAS,CAACE,iBAAiB,GAAG,CAACJ,EAAE;IACjC,IAAI,CAACK,OAAO,CAACH,SAAS,CAAC;EACzB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACAxB,WAAW,CAAC4B,UAAU,GAAG,OAAO;;AAGhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA5B,WAAW,CAACE,OAAO,GAAG;EAAE2B,aAAa,EAAE;AAAK,CAAC;;AAE7C;AACA;AACA;;AAEA7B,WAAW,CAAC8B,cAAc,GAAG,CAAC,CAAC;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA9B,WAAW,CAAC+B,GAAG,GAAGlD,UAAU,CAACkD,GAAG;;AAEhC;AACA;AACA;AACA/B,WAAW,CAACgC,SAAS,GAAGlC,MAAM,CAACmC,MAAM,CAACpD,UAAU,CAACmD,SAAS,CAAC;AAC3DhC,WAAW,CAACgC,SAAS,CAACE,WAAW,GAAGlC,WAAW;AAC/CA,WAAW,CAACgC,SAAS,CAACG,kBAAkB,GAAGvD,kBAAkB;;AAE7D;AACA;AACA;;AAEAoB,WAAW,CAACoC,cAAc,GAAGvD,UAAU,CAACmD,SAAS,CAACK,aAAa;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEArC,WAAW,CAACqC,aAAa,GAAGxD,UAAU,CAACwD,aAAa;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEArC,WAAW,CAACgC,SAAS,CAACK,aAAa,GAAG,SAASA,aAAaA,CAACC,KAAK,EAAEC,GAAG,EAAE;EACvE,IAAI,OAAOD,KAAK,KAAK,QAAQ,IAAIzD,UAAU,CAAC2D,MAAM,CAAC,IAAI,EAAEF,KAAK,EAAEC,GAAG,EAAE,IAAI,CAAC,EAAE;IAC1E,OAAO,CAAC,CAACD,KAAK;EAChB;;EAEA;EACA;EACA,MAAMF,cAAc,GAAG,OAAO,IAAI,CAACF,WAAW,CAACG,aAAa,KAAK,UAAU,GACzE,IAAI,CAACH,WAAW,CAACG,aAAa,EAAE,GAChCrC,WAAW,CAACqC,aAAa,EAAE;EAE7B,OAAOD,cAAc,CAACE,KAAK,CAAC;AAC9B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAtC,WAAW,CAACgC,SAAS,CAACS,IAAI,GAAG,YAAW;EACtC,IAAIC,GAAG,GAAG,IAAI;EACd,OAAO,IAAI,EAAE;IACX,MAAMC,QAAQ,GAAGD,GAAG,IACpBA,GAAG,CAAC9B,MAAM,IACV8B,GAAG,CAAC9B,MAAM,CAAC+B,QAAQ;IACnB,IAAIA,QAAQ,KAAK,OAAO,EAAE;MACxBD,GAAG,GAAGA,GAAG,CAAC9B,MAAM;MAChB;IACF;IACA,IAAI+B,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,KAAK,QAAQ,EAAE;MAClD,MAAM,IAAIC,KAAK,CAAC,2DAA2D,GACzE,QAAQ,GAAGD,QAAQ,CAAC;IACxB;IACA;EACF;EAEA,IAAIE,SAAS,GAAGC,SAAS;EACzB,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,SAAS,CAAC,IAAIzD,KAAK,CAAC4D,QAAQ,CAACH,SAAS,CAAC,EAAE;IAC1DD,SAAS,GAAGxD,KAAK,CAAC6D,MAAM,CAACC,IAAI,CAACN,SAAS,CAAC;EAC1C;EAEAH,GAAG,CAAC9B,MAAM,CAAC6B,IAAI,CAACW,KAAK,CAACV,GAAG,CAAC9B,MAAM,EAAEiC,SAAS,CAAC;EAC5C,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA7C,WAAW,CAACgC,SAAS,CAACqB,YAAY,GAAG,UAASf,KAAK,EAAEgB,KAAK,EAAE;EAC1D,IAAIA,KAAK,IAAI,IAAI,IAAIA,KAAK,CAACC,GAAG,IAAI,IAAI,IAAID,KAAK,CAACE,UAAU,CAAC,IAAI,CAACvC,IAAI,CAAC,EAAE;IACrE;IACA,OAAOqB,KAAK;EACd;EAEA,MAAMmB,GAAG,GAAG5E,UAAU,CAACmD,SAAS,CAACqB,YAAY,CAACjC,IAAI,CAAC,IAAI,EAAEkB,KAAK,EAAEgB,KAAK,CAAC;EACtE,IAAIP,KAAK,CAACC,OAAO,CAACS,GAAG,CAAC,EAAE;IACtB,MAAMC,QAAQ,GAAGrE,KAAK,CAACsE,eAAe,CAACF,GAAG,CAAC,GAAGA,GAAG,CAACG,OAAO,GAAGH,GAAG;IAC/D,MAAMI,GAAG,GAAGH,QAAQ,CAACI,MAAM;IAC3B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,EAAE,EAAEE,CAAC,EAAE;MAC5BL,QAAQ,CAACK,CAAC,CAAC,GAAG,IAAI,CAACnD,MAAM,CAACyC,YAAY,CAACK,QAAQ,CAACK,CAAC,CAAC,EAAET,KAAK,CAAC;IAC5D;EACF;EACA,OAAOG,GAAG;AACZ,CAAC;AAEDzD,WAAW,CAACgC,SAAS,CAACgC,aAAa,GAAG,UAAS1B,KAAK,EAAEgB,KAAK,EAAEW,IAAI,EAAEC,QAAQ,EAAE;EAC3E,IAAI,IAAI,CAACpD,iBAAiB,CAACK,gBAAgB,IACvCnB,WAAW,CAACE,OAAO,CAAC2B,aAAa,IACjC,CAAC,IAAI,CAAClC,mBAAmB,CAAC,EAAE;IAC9B;IACA,IAAIwE,KAAK,GAAG,CAAC;IACb,IAAIzB,GAAG,GAAG,IAAI;IACd,OAAOA,GAAG,IAAI,IAAI,IAChBA,GAAG,CAACvB,gBAAgB,IACpB,CAACuB,GAAG,CAAC0B,wBAAwB,EAAE;MAC/B,EAAED,KAAK;MACPzB,GAAG,GAAGA,GAAG,CAAC5B,iBAAiB;IAC7B;;IAEA;IACA,IAAIwB,KAAK,IAAI,IAAI,IAAIA,KAAK,CAACwB,MAAM,KAAK,CAAC,EAAE;MACvC,MAAMO,UAAU,GAAGrF,UAAU,CAACsD,KAAK,CAAC;MACpC,IAAI+B,UAAU,CAACC,GAAG,KAAKD,UAAU,CAACE,GAAG,IAAIF,UAAU,CAACE,GAAG,GAAGJ,KAAK,IAAIE,UAAU,CAACG,oBAAoB,EAAE;QAClG,KAAK,IAAIT,CAAC,GAAGM,UAAU,CAACE,GAAG,EAAER,CAAC,GAAGI,KAAK,EAAE,EAAEJ,CAAC,EAAE;UAC3CzB,KAAK,GAAG,CAACA,KAAK,CAAC;QACjB;MACF;IACF;EACF;EAEA,OAAOzD,UAAU,CAACmD,SAAS,CAACgC,aAAa,CAAC5C,IAAI,CAAC,IAAI,EAAEkB,KAAK,EAAEgB,KAAK,EAAEW,IAAI,EAAEC,QAAQ,CAAC;AACpF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAlE,WAAW,CAACgC,SAAS,CAAC/C,IAAI,GAAG,UAASqD,KAAK,EAAEC,GAAG,EAAE0B,IAAI,EAAEQ,IAAI,EAAEvE,OAAO,EAAE;EACrE;EACAT,aAAa,KAAKA,aAAa,GAAGhB,OAAO,CAAC,UAAU,CAAC,CAACsE,KAAK,CAAC;EAE5D,IAAIgB,CAAC;EACL,IAAIW,CAAC;EAEL,IAAI3B,KAAK,CAACC,OAAO,CAACV,KAAK,CAAC,EAAE;IACxB,MAAMuB,GAAG,GAAGvB,KAAK,CAACwB,MAAM;IACxB,IAAI,CAACD,GAAG,IAAItB,GAAG,EAAE;MACf,MAAMoC,OAAO,GAAGpC,GAAG,CAACqC,MAAM,CAACC,YAAY,EAAE;MAEzC,MAAMC,SAAS,GAAG,IAAI,CAAC7D,IAAI;MAC3B,KAAK8C,CAAC,GAAG,CAAC,EAAEW,CAAC,GAAGC,OAAO,CAACb,MAAM,EAAEC,CAAC,GAAGW,CAAC,EAAE,EAAEX,CAAC,EAAE;QAC1C,MAAMgB,SAAS,GAAGJ,OAAO,CAACZ,CAAC,CAAC,CAAC,CAAC,CAAC,CAACe,SAAS,CAAC;QAC1C,IAAIC,SAAS,KAAK,UAAU,IAAIA,SAAS,KAAK,IAAI,EAAE;UAClD;QACF;MACF;;MAEA;MACA;MACA,MAAMC,gBAAgB,GAAG,IAAI,CAAC/D,IAAI,CAACgE,QAAQ,CAAC,cAAc,CAAC,GACzD,IAAI,CAAChE,IAAI,CAACiE,SAAS,CAAC,CAAC,EAAE,IAAI,CAACjE,IAAI,CAACkE,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI;MAC3D,IAAIH,gBAAgB,IAAI,IAAI,EAAE;QAC5B,KAAKjB,CAAC,GAAG,CAAC,EAAEW,CAAC,GAAGC,OAAO,CAACb,MAAM,EAAEC,CAAC,GAAGW,CAAC,EAAE,EAAEX,CAAC,EAAE;UAC1C,MAAMgB,SAAS,GAAGJ,OAAO,CAACZ,CAAC,CAAC,CAAC,CAAC,CAAC,CAACiB,gBAAgB,CAAC;UACjD,IAAID,SAAS,KAAK,UAAU,EAAE;YAC5B;UACF;QACF;MACF;IACF;IAEA7E,OAAO,GAAGA,OAAO,IAAIL,SAAS;IAE9B,IAAI6D,QAAQ,GAAGrE,KAAK,CAACsE,eAAe,CAACrB,KAAK,CAAC,GAAGA,KAAK,CAACsB,OAAO,GAAGtB,KAAK;IACnEA,KAAK,GAAG7C,aAAa,CAACiE,QAAQ,EAAExD,OAAO,CAACe,IAAI,IAAI,IAAI,CAACmE,UAAU,IAAI,IAAI,CAACnE,IAAI,EAAEsB,GAAG,EAAE,IAAI,CAAC;IACxFmB,QAAQ,GAAGpB,KAAK,CAACsB,OAAO;IAExB,IAAIK,IAAI,IAAI1B,GAAG,IAAI,IAAI,IAAIA,GAAG,CAACgB,GAAG,IAAI,IAAI,IAAIhB,GAAG,CAACiB,UAAU,CAAC,IAAI,CAACvC,IAAI,CAAC,EAAE;MACvE,OAAOqB,KAAK;IACd;IAEA,MAAM1B,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1B,MAAM+C,eAAe,GAAG/C,MAAM,CAACO,gBAAgB;IAC/C,IAAIP,MAAM,IAAI,IAAI,CAACE,iBAAiB,KAAK/B,KAAK,EAAE;MAC9C,IAAI;QACF,MAAM8E,GAAG,GAAGH,QAAQ,CAACI,MAAM;QAC3B,KAAKC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAE,EAAE;UACxB,MAAMsB,IAAI,GAAG,CAAC,CAAC;UACf;UACA;UACA;UACA,IAAI1B,eAAe,EAAE;YACnB,IAAIzD,OAAO,CAAC4E,SAAS,IAAI,IAAI,EAAE;cAC7BO,IAAI,CAACC,cAAc,GAAGvB,CAAC;YACzB,CAAC,MAAM,IAAInD,MAAM,CAAC2E,gBAAgB,IAAI,IAAI,EAAE;cAC1CF,IAAI,CAACC,cAAc,GAAGvB,CAAC;YACzB;UACF;UACAL,QAAQ,CAACK,CAAC,CAAC,GAAGnD,MAAM,CAAC4E,YAAY,CAAC9B,QAAQ,CAACK,CAAC,CAAC,EAAExB,GAAG,EAAE0B,IAAI,EAAE,KAAK,CAAC,EAAEoB,IAAI,CAAC;QACzE;MACF,CAAC,CAAC,OAAOI,CAAC,EAAE;QACV;QACA,MAAM,IAAI3G,SAAS,CAAC,GAAG,GAAG2G,CAAC,CAACC,IAAI,GAAG,GAAG,EAAEtG,IAAI,CAACuG,OAAO,CAACrD,KAAK,CAAC,EAAE,IAAI,CAACrB,IAAI,GAAG,GAAG,GAAG8C,CAAC,EAAE0B,CAAC,EAAE,IAAI,CAAC;MAC5F;IACF;IAEA,OAAOnD,KAAK;EACd;EAEA,MAAMsD,mBAAmB,GAAG,IAAI,CAAC1F,OAAO,CAAC2B,aAAa,IAAI,IAAI,GAAG,IAAI,CAAC3B,OAAO,CAAC2B,aAAa,GAAG7B,WAAW,CAACE,OAAO,CAAC2B,aAAa;EAC/H,IAAIoC,IAAI,IAAI2B,mBAAmB,EAAE;IAC/B;IACA;IACA,IAAI,CAAC,CAACrD,GAAG,IAAI,CAAC,CAAC0B,IAAI,EAAE;MACnB1B,GAAG,CAACsD,YAAY,CAAC,IAAI,CAAC5E,IAAI,CAAC;IAC7B;IACA,OAAO,IAAI,CAAChC,IAAI,CAAC,CAACqD,KAAK,CAAC,EAAEC,GAAG,EAAE0B,IAAI,CAAC;EACtC;EAEA,MAAM,IAAInF,SAAS,CAAC,OAAO,EAAEM,IAAI,CAACuG,OAAO,CAACrD,KAAK,CAAC,EAAE,IAAI,CAACrB,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;AAC1E,CAAC;;AAED;AACA;AACA;;AAEAjB,WAAW,CAACgC,SAAS,CAAC8D,gBAAgB,GAAG,SAASA,gBAAgBA,CAACxD,KAAK,EAAEC,GAAG,EAAE;EAC7E;EACA9C,aAAa,KAAKA,aAAa,GAAGhB,OAAO,CAAC,UAAU,CAAC,CAACsE,KAAK,CAAC;EAE5D,IAAIA,KAAK,CAACC,OAAO,CAACV,KAAK,CAAC,EAAE;IACxB,IAAIyB,CAAC;IACL,MAAML,QAAQ,GAAGpB,KAAK,CAACsB,OAAO,GAAGtB,KAAK,CAACsB,OAAO,GAAGtB,KAAK;IACtD,MAAMuB,GAAG,GAAGH,QAAQ,CAACI,MAAM;IAE3B,MAAMlD,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1B,IAAIA,MAAM,IAAI,IAAI,CAACE,iBAAiB,KAAK/B,KAAK,EAAE;MAC9C,IAAI;QACF,KAAKgF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAE,EAAE;UACxB,MAAMsB,IAAI,GAAG,CAAC,CAAC;UACf;UACA;UACA;UACA,IAAIzE,MAAM,CAACO,gBAAgB,IAAIP,MAAM,CAAC2E,gBAAgB,IAAI,IAAI,EAAE;YAC9DF,IAAI,CAACC,cAAc,GAAGvB,CAAC;UACzB;UAEAL,QAAQ,CAACK,CAAC,CAAC,GAAGnD,MAAM,CAAC3B,IAAI,CAACyE,QAAQ,CAACK,CAAC,CAAC,EAAExB,GAAG,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE8C,IAAI,CAAC;QAClE;MACF,CAAC,CAAC,OAAOI,CAAC,EAAE;QACV;QACA,MAAM,IAAI3G,SAAS,CAAC,GAAG,GAAG2G,CAAC,CAACC,IAAI,GAAG,GAAG,EAAEtG,IAAI,CAACuG,OAAO,CAACrD,KAAK,CAAC,EAAE,IAAI,CAACrB,IAAI,GAAG,GAAG,GAAG8C,CAAC,EAAE0B,CAAC,EAAE,IAAI,CAAC;MAC5F;IACF;IAEA,OAAOnD,KAAK;EACd;EAEA,MAAM,IAAIxD,SAAS,CAAC,OAAO,EAAEM,IAAI,CAACuG,OAAO,CAACrD,KAAK,CAAC,EAAE,IAAI,CAACrB,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;AAC1E,CAAC;AAEDjB,WAAW,CAACgC,SAAS,CAAC+D,SAAS,GAAG/F,WAAW,CAACgC,SAAS,CAACgE,QAAQ;;AAEhE;AACA;AACA;;AAEAhG,WAAW,CAACgC,SAAS,CAACiE,aAAa,GAAG,YAAkB;EACtD,IAAIvD,GAAG,GAAG,IAAI;EACd,OAAOA,GAAG,CAACvB,gBAAgB,IAAI,CAACuB,GAAG,CAAC0B,wBAAwB,EAAE;IAC5D1B,GAAG,GAAGA,GAAG,CAAC5B,iBAAiB;IAC3B,IAAI4B,GAAG,IAAI,IAAI,IAAI,OAAOA,GAAG,KAAK,UAAU,EAAE;MAC5C,MAAM,IAAI/D,aAAa,CAAC,gDAAgD,GACtE,oBAAoB,GAAG,IAAI,CAACsC,IAAI,GAAG,mBAAmB,CAAC;IAC3D;EACF;EACA,OAAOyB,GAAG,CAACuD,aAAa,CAAC,GAAAnD,SAAO,CAAC;AACnC,CAAC;;AAED;AACA;AACA;;AAEA9C,WAAW,CAACgC,SAAS,CAAC9C,KAAK,GAAG,YAAW;EACvC,MAAMgB,OAAO,GAAGJ,MAAM,CAACoG,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAAChG,OAAO,CAAC;EAC/C,MAAMiG,UAAU,GAAG,IAAI,IAAI,CAACjE,WAAW,CAAC,IAAI,CAACjB,IAAI,EAAE,IAAI,CAACL,MAAM,EAAEV,OAAO,EAAE,IAAI,CAACC,aAAa,CAAC;EAC5FgG,UAAU,CAACC,UAAU,GAAG,IAAI,CAACA,UAAU,CAACC,KAAK,EAAE;EAC/C,IAAI,IAAI,CAACC,iBAAiB,KAAKC,SAAS,EAAE;IACxCJ,UAAU,CAACG,iBAAiB,GAAG,IAAI,CAACA,iBAAiB;EACvD;EACA,OAAOH,UAAU;AACnB,CAAC;AAEDnG,WAAW,CAACgC,SAAS,CAACwE,aAAa,GAAG,UAASC,GAAG,EAAEC,OAAO,EAAE;EAC3D,IAAIC,WAAW,GAAG,IAAI,CAAC7F,iBAAiB;EAExC,IAAI2F,GAAG,IACHE,WAAW,CAACC,cAAc,IAC1BD,WAAW,CAAC/B,MAAM,IAClB+B,WAAW,CAAC/B,MAAM,CAAC1E,OAAO,IAC1ByG,WAAW,CAAC/B,MAAM,CAAC1E,OAAO,CAAC2G,gBAAgB,EAAE;IAC/C,IAAI,OAAOJ,GAAG,CAACE,WAAW,CAAC/B,MAAM,CAAC1E,OAAO,CAAC2G,gBAAgB,CAAC,KAAK,QAAQ,IACpEF,WAAW,CAACC,cAAc,CAACH,GAAG,CAACE,WAAW,CAAC/B,MAAM,CAAC1E,OAAO,CAAC2G,gBAAgB,CAAC,CAAC,EAAE;MAChFF,WAAW,GAAGA,WAAW,CAACC,cAAc,CAACH,GAAG,CAACE,WAAW,CAAC/B,MAAM,CAAC1E,OAAO,CAAC2G,gBAAgB,CAAC,CAAC;IAC5F,CAAC,MAAM;MACL,MAAMC,kBAAkB,GAAGtH,uBAAuB,CAACmH,WAAW,CAACC,cAAc,EAAEH,GAAG,CAACE,WAAW,CAAC/B,MAAM,CAAC1E,OAAO,CAAC2G,gBAAgB,CAAC,CAAC;MAChI,IAAIC,kBAAkB,EAAE;QACtBH,WAAW,GAAGG,kBAAkB;MAClC;IACF;EACF;EAEA,MAAMC,KAAK,GAAG,IAAI,CAACjG,iBAAiB,CAACkB,SAAS;EAC9C,MAAMgF,iBAAiB,GAAGD,KAAK,IAAIA,KAAK,CAACE,YAAY;EACrD,MAAMC,SAAS,GAAGH,KAAK,IAAIA,KAAK,CAAC9H,IAAI;EACrC,MAAMkI,uBAAuB,GAAGR,WAAW,CAACM,YAAY;EACxD,MAAMrG,MAAM,GAAG,IAAI,CAACA,MAAM;EAE1B,IAAImC,KAAK,CAACC,OAAO,CAACyD,GAAG,CAAC,EAAE;IACtB,IAAI,CAACW,OAAO,CAACC,OAAO,EAAE,CAACC,OAAO,CAACC,MAAM,IAAI;MACvCd,GAAG,GAAGc,MAAM,CAACnG,IAAI,CAAC,IAAI,EAAEqF,GAAG,EAAE,IAAI,CAAC;IACpC,CAAC,CAAC;IACFA,GAAG,GAAGA,GAAG,CAACe,GAAG,CAAC,UAASC,CAAC,EAAE;MACxB,IAAIpI,KAAK,CAAC4D,QAAQ,CAACwE,CAAC,CAAC,IAAIA,CAAC,CAACC,UAAU,EAAE;QACrC,OAAOD,CAAC;MACV;MACA,IAAIT,iBAAiB,EAAE;QACrBS,CAAC,GAAGT,iBAAiB,CAAC5F,IAAI,CAACR,MAAM,EAAE,IAAI,EAAE6G,CAAC,EAAEf,OAAO,CAAC;QACpD,OAAOe,CAAC;MACV,CAAC,MAAM,IAAIP,SAAS,EAAE;QACpBO,CAAC,GAAGP,SAAS,CAAC9F,IAAI,CAACR,MAAM,EAAE6G,CAAC,CAAC;QAC7B,OAAOA,CAAC;MACV,CAAC,MAAM,IAAIN,uBAAuB,EAAE;QAClCM,CAAC,GAAGN,uBAAuB,CAAC/F,IAAI,CAACR,MAAM,EAAE,IAAI,EAAE6G,CAAC,EAAEf,OAAO,CAAC;QAC1D,OAAOe,CAAC;MACV;MACA,IAAIA,CAAC,IAAI,IAAI,EAAE;QACbA,CAAC,GAAG,IAAId,WAAW,CAACc,CAAC,CAAC;QACtB,OAAOA,CAAC;MACV;MACA,OAAOA,CAAC;IACV,CAAC,CAAC;EACJ,CAAC,MAAM,IAAIT,iBAAiB,EAAE;IAC5BP,GAAG,GAAGO,iBAAiB,CAAC5F,IAAI,CAACR,MAAM,EAAE,IAAI,EAAE6F,GAAG,EAAEC,OAAO,CAAC;EAC1D,CAAC,MAAM,IAAIQ,SAAS,EAAE;IACpBT,GAAG,GAAGS,SAAS,CAAC9F,IAAI,CAACR,MAAM,EAAE6F,GAAG,CAAC;EACnC,CAAC,MAAM,IAAIU,uBAAuB,EAAE;IAClCV,GAAG,GAAGU,uBAAuB,CAAC/F,IAAI,CAACR,MAAM,EAAE,IAAI,EAAE6F,GAAG,EAAEC,OAAO,CAAC;EAChE,CAAC,MAAM,IAAID,GAAG,IAAI,IAAI,EAAE;IACtBA,GAAG,GAAG,IAAIE,WAAW,CAACF,GAAG,CAAC;EAC5B;EAEA,OAAOA,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAzG,WAAW,CAACgC,SAAS,CAACiF,YAAY,GAAG,UAASU,YAAY,EAAElB,GAAG,EAAEC,OAAO,EAAE;EACxE,IAAIkB,OAAO;EAEX,IAAID,YAAY,IAAI,IAAI,EAAE;IACxBC,OAAO,GAAG,IAAI,CAACC,oBAAoB,CAACF,YAAY,CAAC;IAEjD,IAAI,CAACC,OAAO,EAAE;MACZ,MAAM,IAAIhF,KAAK,CAAC,aAAa,GAAG+E,YAAY,GAAG,cAAc,CAAC;IAChE;IAEA,OAAOC,OAAO,CAACxG,IAAI,CAAC,IAAI,EAAEqF,GAAG,EAAEC,OAAO,CAAC;EACzC,CAAC,MAAM;IACL,OAAO,IAAI,CAACF,aAAa,CAACC,GAAG,EAAEC,OAAO,CAAC;EACzC;AACF,CAAC;AAED,SAASoB,QAAQA,CAACrB,GAAG,EAAEC,OAAO,EAAE;EAC9B,IAAI,CAAC3D,KAAK,CAACC,OAAO,CAACyD,GAAG,CAAC,EAAE;IACvBA,GAAG,GAAG,CAACA,GAAG,CAAC;EACb;EAEAA,GAAG,GAAGA,GAAG,CAACe,GAAG,CAAEC,CAAC,IAAK;IACnB,IAAI,CAACpI,KAAK,CAAC4D,QAAQ,CAACwE,CAAC,CAAC,EAAE;MACtB,OAAOA,CAAC;IACV;IACA,IAAIA,CAAC,CAACC,UAAU,IAAI,IAAI,EAAE;MACxB,OAAO;QAAEA,UAAU,EAAEzI,IAAI,CAAC,IAAI,CAAC6B,iBAAiB,CAAC8D,MAAM,EAAE6C,CAAC,CAACC,UAAU,EAAE,IAAI,EAAE,IAAI,IAAI,IAAI,CAACK,SAAS;MAAE,CAAC;IACxG;IAEA,MAAMC,CAAC,GAAG,CAAC,CAAC;IACZA,CAAC,CAAC,IAAI,CAAC/G,IAAI,CAAC,GAAGwG,CAAC;IAChB,OAAOxI,IAAI,CAAC,IAAI,CAAC6B,iBAAiB,CAAC8D,MAAM,EAAEoD,CAAC,EAAE,IAAI,EAAE,IAAI,IAAI,IAAI,CAACD,SAAS,CAAC,CAAC,IAAI,CAAC9G,IAAI,CAAC;EACxF,CAAC,EAAE,IAAI,CAAC;EAER,OAAO,IAAI,CAACgG,YAAY,CAAC,IAAI,EAAER,GAAG,EAAEC,OAAO,CAAC;AAC9C;AAEA,SAASuB,cAAcA,CAACxB,GAAG,EAAEC,OAAO,EAAE;EACpC,MAAMwB,IAAI,GAAGpI,MAAM,CAACoI,IAAI,CAACzB,GAAG,CAAC;EAC7B,MAAM0B,OAAO,GAAGD,IAAI,CAACpE,MAAM;EAC3B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoE,OAAO,EAAE,EAAEpE,CAAC,EAAE;IAChC,MAAM9D,GAAG,GAAGiI,IAAI,CAACnE,CAAC,CAAC;IACnB,MAAMzB,KAAK,GAAGmE,GAAG,CAACxG,GAAG,CAAC;IACtB,IAAId,UAAU,CAACc,GAAG,CAAC,IAAIqC,KAAK,IAAI,IAAI,EAAE;MACpCmE,GAAG,CAACxG,GAAG,CAAC,GAAG,IAAI,CAACgH,YAAY,CAAChH,GAAG,EAAEqC,KAAK,EAAEoE,OAAO,CAAC;IACnD;EACF;;EAEA;EACA;EACA,MAAMG,gBAAgB,GAAG,IAAI,IAC3B,IAAI,CAAC/F,iBAAiB,IACtB,IAAI,CAACA,iBAAiB,CAAC8D,MAAM,IAC7B,IAAI,CAAC9D,iBAAiB,CAAC8D,MAAM,CAAC1E,OAAO,IACrC,IAAI,CAACY,iBAAiB,CAAC8D,MAAM,CAAC1E,OAAO,CAAC2G,gBAAgB;EACxD,MAAMD,cAAc,GAAG,IAAI,IAC3B,IAAI,CAAC9F,iBAAiB,IACtB,IAAI,CAACA,iBAAiB,CAAC8D,MAAM,IAC7B,IAAI,CAAC9D,iBAAiB,CAAC8D,MAAM,CAACgC,cAAc,IAAI,CAAC,CAAC;EAClD,IAAIC,gBAAgB,IAAI,IAAI,IACxBJ,GAAG,CAACI,gBAAgB,CAAC,IAAI,IAAI,IAC7BD,cAAc,CAACH,GAAG,CAACI,gBAAgB,CAAC,CAAC,IAAI,IAAI,EAAE;IACjD,OAAO5H,IAAI,CAAC2H,cAAc,CAACH,GAAG,CAACI,gBAAgB,CAAC,CAAC,EAAEJ,GAAG,EAAE,IAAI,EAAE,IAAI,IAAI,IAAI,CAACsB,SAAS,CAAC;EACvF;EAEA,OAAO9I,IAAI,CAAC,IAAI,CAAC6B,iBAAiB,CAAC8D,MAAM,EAAE6B,GAAG,EAAE,IAAI,EAAE,IAAI,IAAI,IAAI,CAACsB,SAAS,CAAC;AAC/E;AAEA,MAAMK,MAAM,GAAGpI,WAAW,CAACgC,SAAS,CAAC6F,oBAAoB,GAAG,CAAC,CAAC;AAE9DO,MAAM,CAACC,IAAI,GAAGP,QAAQ;AACtBM,MAAM,CAACE,QAAQ,GAAGC,MAAM;AACxBH,MAAM,CAACV,UAAU,GAAGO,cAAc;AAClCG,MAAM,CAACI,cAAc,GAAGjJ,UAAU,CAACkJ,kBAAkB;AACrDL,MAAM,CAACM,GAAG,GAAGC,iCAAiC,CAAC,KAAK,CAAC;AACrDP,MAAM,CAACQ,IAAI,GAAGD,iCAAiC,CAAC,MAAM,CAAC;AACvDP,MAAM,CAACS,IAAI,GAAGF,iCAAiC,CAAC,MAAM,CAAC;AAEvD,SAASA,iCAAiCA,CAACG,EAAE,EAAE;EAC7C,OAAO,SAASC,2BAA2BA,CAACtC,GAAG,EAAE;IAC/C,IAAI,CAAC1D,KAAK,CAACC,OAAO,CAACyD,GAAG,CAAC,EAAE;MACvB,MAAM,IAAIuC,SAAS,CAAC,cAAc,GAAGF,EAAE,GAAG,oBAAoB,CAAC;IACjE;IAEA,MAAMrF,GAAG,GAAG,EAAE;IACd,KAAK,MAAMwF,GAAG,IAAIxC,GAAG,EAAE;MACrBhD,GAAG,CAACyF,IAAI,CAACjK,IAAI,CAAC,IAAI,CAAC6B,iBAAiB,CAAC8D,MAAM,EAAEqE,GAAG,EAAE,IAAI,EAAE,IAAI,IAAI,IAAI,CAAClB,SAAS,CAAC,CAAC;IAClF;IAEA,OAAOtE,GAAG;EACZ,CAAC;AACH;AAEA2E,MAAM,CAACe,KAAK,GACZf,MAAM,CAACgB,WAAW,GAAG7J,UAAU,CAAC8J,SAAS;AAEzCjB,MAAM,CAACkB,OAAO,GACdlB,MAAM,CAACmB,UAAU,GAAGhK,UAAU,CAACiK,WAAW;AAE1CpB,MAAM,CAACqB,KAAK,GACZrB,MAAM,CAACsB,YAAY,GACnBtB,MAAM,CAACuB,YAAY,GAAGrK,YAAY;AAElC8I,MAAM,CAAC5J,OAAO,GAAGA,OAAO;AACxB4J,MAAM,CAAC1J,KAAK,GAAGA,KAAK;AAEpB0J,MAAM,CAACwB,GAAG,GACVxB,MAAM,CAACyB,GAAG,GACVzB,MAAM,CAAC0B,IAAI,GACX1B,MAAM,CAAC2B,GAAG,GACV3B,MAAM,CAAC4B,IAAI,GACX5B,MAAM,CAAC6B,IAAI,GACX7B,MAAM,CAAC8B,MAAM,GACb9B,MAAM,CAAC+B,GAAG,GAAGnK,WAAW,CAACgC,SAAS,CAACwE,aAAa;;AAEhD;AACA;AACA4B,MAAM,CAACgC,IAAI,GAAGvL,UAAU,CAACmD,SAAS,CAAC6F,oBAAoB,CAACuC,IAAI;AAC5DhC,MAAM,CAACiC,GAAG,GAAGxL,UAAU,CAACmD,SAAS,CAAC6F,oBAAoB,CAACwC,GAAG;;AAE1D;AACA;AACA;;AAEAC,MAAM,CAACC,OAAO,GAAGvK,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}