{"ast":null,"code":"'use strict';\n\nconst MongooseMap = require('../../types/map');\nconst SkipPopulateValue = require('./SkipPopulateValue');\nconst assignRawDocsToIdStructure = require('./assignRawDocsToIdStructure');\nconst get = require('../get');\nconst getVirtual = require('./getVirtual');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst markArraySubdocsPopulated = require('./markArraySubdocsPopulated');\nconst mpath = require('mpath');\nconst sift = require('sift').default;\nconst utils = require('../../utils');\nconst {\n  populateModelSymbol\n} = require('../symbols');\nmodule.exports = function assignVals(o) {\n  // Options that aren't explicitly listed in `populateOptions`\n  const userOptions = Object.assign({}, get(o, 'allOptions.options.options'), get(o, 'allOptions.options'));\n  // `o.options` contains options explicitly listed in `populateOptions`, like\n  // `match` and `limit`.\n  const populateOptions = Object.assign({}, o.options, userOptions, {\n    justOne: o.justOne\n  });\n  populateOptions.$nullIfNotFound = o.isVirtual;\n  const populatedModel = o.populatedModel;\n  const originalIds = [].concat(o.rawIds);\n\n  // replace the original ids in our intermediate _ids structure\n  // with the documents found by query\n  o.allIds = [].concat(o.allIds);\n  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);\n\n  // now update the original documents being populated using the\n  // result structure that contains real documents.\n  const docs = o.docs;\n  const rawIds = o.rawIds;\n  const options = o.options;\n  const count = o.count && o.isVirtual;\n  let i;\n  function setValue(val) {\n    if (count) {\n      return val;\n    }\n    if (val instanceof SkipPopulateValue) {\n      return val.val;\n    }\n    if (val === void 0) {\n      return val;\n    }\n    const _allIds = o.allIds[i];\n    if (o.path.endsWith('.$*')) {\n      // Skip maps re: gh-12494\n      return valueFilter(val, options, populateOptions, _allIds);\n    }\n    if (o.justOne === true && Array.isArray(val)) {\n      // Might be an embedded discriminator (re: gh-9244) with multiple models, so make sure to pick the right\n      // model before assigning.\n      const ret = [];\n      for (const doc of val) {\n        const _docPopulatedModel = leanPopulateMap.get(doc);\n        if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {\n          ret.push(doc);\n        }\n      }\n      // Since we don't want to have to create a new mongoosearray, make sure to\n      // modify the array in place\n      while (val.length > ret.length) {\n        Array.prototype.pop.apply(val, []);\n      }\n      for (let i = 0; i < ret.length; ++i) {\n        val[i] = ret[i];\n      }\n      return valueFilter(val[0], options, populateOptions, _allIds);\n    } else if (o.justOne === false && !Array.isArray(val)) {\n      return valueFilter([val], options, populateOptions, _allIds);\n    }\n    return valueFilter(val, options, populateOptions, _allIds);\n  }\n  for (i = 0; i < docs.length; ++i) {\n    const _path = o.path.endsWith('.$*') ? o.path.slice(0, -3) : o.path;\n    const existingVal = mpath.get(_path, docs[i], lookupLocalFields);\n    if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {\n      continue;\n    }\n    let valueToSet;\n    if (count) {\n      valueToSet = numDocs(rawIds[i]);\n    } else if (Array.isArray(o.match)) {\n      valueToSet = Array.isArray(rawIds[i]) ? rawIds[i].filter(sift(o.match[i])) : [rawIds[i]].filter(sift(o.match[i]))[0];\n    } else {\n      valueToSet = rawIds[i];\n    }\n\n    // If we're populating a map, the existing value will be an object, so\n    // we need to transform again\n    const originalSchema = o.originalModel.schema;\n    const isDoc = get(docs[i], '$__', null) != null;\n    let isMap = isDoc ? existingVal instanceof Map : utils.isPOJO(existingVal);\n    // If we pass the first check, also make sure the local field's schematype\n    // is map (re: gh-6460)\n    isMap = isMap && get(originalSchema._getSchema(_path), '$isSchemaMap');\n    if (!o.isVirtual && isMap) {\n      const _keys = existingVal instanceof Map ? Array.from(existingVal.keys()) : Object.keys(existingVal);\n      valueToSet = valueToSet.reduce((cur, v, i) => {\n        cur.set(_keys[i], v);\n        return cur;\n      }, new Map());\n    }\n    if (isDoc && Array.isArray(valueToSet)) {\n      for (const val of valueToSet) {\n        if (val != null && val.$__ != null) {\n          val.$__.parent = docs[i];\n        }\n      }\n    } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {\n      valueToSet.$__.parent = docs[i];\n    }\n    if (o.isVirtual && isDoc) {\n      docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);\n      // If virtual populate and doc is already init-ed, need to walk through\n      // the actual doc to set rather than setting `_doc` directly\n      if (Array.isArray(valueToSet)) {\n        valueToSet = valueToSet.map(v => v == null ? void 0 : v);\n      }\n      mpath.set(_path, valueToSet, docs[i], void 0, setValue, false);\n      continue;\n    }\n    const parts = _path.split('.');\n    let cur = docs[i];\n    const curPath = parts[0];\n    for (let j = 0; j < parts.length - 1; ++j) {\n      // If we get to an array with a dotted path, like `arr.foo`, don't set\n      // `foo` on the array.\n      if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {\n        break;\n      }\n      if (parts[j] === '$*') {\n        break;\n      }\n      if (cur[parts[j]] == null) {\n        // If nothing to set, avoid creating an unnecessary array. Otherwise\n        // we'll end up with a single doc in the array with only defaults.\n        // See gh-8342, gh-8455\n        const schematype = originalSchema._getSchema(curPath);\n        if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {\n          break;\n        }\n        cur[parts[j]] = {};\n      }\n      cur = cur[parts[j]];\n      // If the property in MongoDB is a primitive, we won't be able to populate\n      // the nested path, so skip it. See gh-7545\n      if (typeof cur !== 'object') {\n        break;\n      }\n    }\n    if (docs[i].$__) {\n      o.allOptions.options[populateModelSymbol] = o.allOptions.model;\n      docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options);\n      if (valueToSet != null && valueToSet.$__ != null) {\n        valueToSet.$__.wasPopulated = {\n          value: o.unpopulatedValues[i]\n        };\n      }\n      if (valueToSet instanceof Map && !valueToSet.$isMongooseMap) {\n        valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType);\n      }\n    }\n\n    // If lean, need to check that each individual virtual respects\n    // `justOne`, because you may have a populated virtual with `justOne`\n    // underneath an array. See gh-6867\n    mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);\n    if (docs[i].$__) {\n      markArraySubdocsPopulated(docs[i], [o.allOptions.options]);\n    }\n  }\n};\nfunction numDocs(v) {\n  if (Array.isArray(v)) {\n    // If setting underneath an array of populated subdocs, we may have an\n    // array of arrays. See gh-7573\n    if (v.some(el => Array.isArray(el) || el === null)) {\n      return v.map(el => {\n        if (el == null) {\n          return 0;\n        }\n        if (Array.isArray(el)) {\n          return el.filter(el => el != null).length;\n        }\n        return 1;\n      });\n    }\n    return v.filter(el => el != null).length;\n  }\n  return v == null ? 0 : 1;\n}\n\n/**\n * 1) Apply backwards compatible find/findOne behavior to sub documents\n *\n *    find logic:\n *      a) filter out non-documents\n *      b) remove _id from sub docs when user specified\n *\n *    findOne\n *      a) if no doc found, set to null\n *      b) remove _id from sub docs when user specified\n *\n * 2) Remove _ids when specified by users query.\n *\n * background:\n * _ids are left in the query even when user excludes them so\n * that population mapping can occur.\n * @param {Any} val\n * @param {Object} assignmentOpts\n * @param {Object} populateOptions\n * @param {Function} [populateOptions.transform]\n * @param {Boolean} allIds\n * @api private\n */\n\nfunction valueFilter(val, assignmentOpts, populateOptions, allIds) {\n  const userSpecifiedTransform = typeof populateOptions.transform === 'function';\n  const transform = userSpecifiedTransform ? populateOptions.transform : noop;\n  if (Array.isArray(val)) {\n    // find logic\n    const ret = [];\n    const numValues = val.length;\n    for (let i = 0; i < numValues; ++i) {\n      let subdoc = val[i];\n      const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;\n      if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {\n        continue;\n      } else if (!populateOptions.retainNullValues && subdoc == null) {\n        continue;\n      } else if (userSpecifiedTransform) {\n        subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);\n      }\n      maybeRemoveId(subdoc, assignmentOpts);\n      ret.push(subdoc);\n      if (assignmentOpts.originalLimit && ret.length >= assignmentOpts.originalLimit) {\n        break;\n      }\n    }\n    const rLen = ret.length;\n    // Since we don't want to have to create a new mongoosearray, make sure to\n    // modify the array in place\n    while (val.length > rLen) {\n      Array.prototype.pop.apply(val, []);\n    }\n    let i = 0;\n    if (utils.isMongooseArray(val)) {\n      for (i = 0; i < rLen; ++i) {\n        val.set(i, ret[i], true);\n      }\n    } else {\n      for (i = 0; i < rLen; ++i) {\n        val[i] = ret[i];\n      }\n    }\n    return val;\n  }\n\n  // findOne\n  if (isPopulatedObject(val) || utils.isPOJO(val)) {\n    maybeRemoveId(val, assignmentOpts);\n    return transform(val, allIds);\n  }\n  if (val instanceof Map) {\n    return val;\n  }\n  if (populateOptions.justOne === false) {\n    return [];\n  }\n  return val == null ? transform(val, allIds) : transform(null, allIds);\n}\n\n/**\n * Remove _id from `subdoc` if user specified \"lean\" query option\n * @param {Document} subdoc\n * @param {Object} assignmentOpts\n * @api private\n */\n\nfunction maybeRemoveId(subdoc, assignmentOpts) {\n  if (subdoc != null && assignmentOpts.excludeId) {\n    if (typeof subdoc.$__setValue === 'function') {\n      delete subdoc._doc._id;\n    } else {\n      delete subdoc._id;\n    }\n  }\n}\n\n/**\n * Determine if `obj` is something we can set a populated path to. Can be a\n * document, a lean document, or an array/map that contains docs.\n * @param {Any} obj\n * @api private\n */\n\nfunction isPopulatedObject(obj) {\n  if (obj == null) {\n    return false;\n  }\n  return Array.isArray(obj) || obj.$isMongooseMap || obj.$__ != null || leanPopulateMap.has(obj);\n}\nfunction noop(v) {\n  return v;\n}","map":{"version":3,"names":["MongooseMap","require","SkipPopulateValue","assignRawDocsToIdStructure","get","getVirtual","leanPopulateMap","lookupLocalFields","markArraySubdocsPopulated","mpath","sift","default","utils","populateModelSymbol","module","exports","assignVals","o","userOptions","Object","assign","populateOptions","options","justOne","$nullIfNotFound","isVirtual","populatedModel","originalIds","concat","rawIds","allIds","rawDocs","rawOrder","docs","count","i","setValue","val","_allIds","path","endsWith","valueFilter","Array","isArray","ret","doc","_docPopulatedModel","push","length","prototype","pop","apply","_path","slice","existingVal","originalModel","schema","valueToSet","numDocs","match","filter","originalSchema","isDoc","isMap","Map","isPOJO","_getSchema","_keys","from","keys","reduce","cur","v","set","$__","parent","$populated","allOptions","map","parts","split","curPath","j","isArrayIndex","schematype","$isMongooseArray","model","unpopulatedValues","wasPopulated","value","$isMongooseMap","$__schemaType","some","el","assignmentOpts","userSpecifiedTransform","transform","noop","numValues","subdoc","isPopulatedObject","retainNullValues","maybeRemoveId","originalLimit","rLen","isMongooseArray","excludeId","$__setValue","_doc","_id","obj","has"],"sources":["C:/Users/sama/Documents/fullpage/node_modules/mongoose/lib/helpers/populate/assignVals.js"],"sourcesContent":["'use strict';\n\nconst MongooseMap = require('../../types/map');\nconst SkipPopulateValue = require('./SkipPopulateValue');\nconst assignRawDocsToIdStructure = require('./assignRawDocsToIdStructure');\nconst get = require('../get');\nconst getVirtual = require('./getVirtual');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst markArraySubdocsPopulated = require('./markArraySubdocsPopulated');\nconst mpath = require('mpath');\nconst sift = require('sift').default;\nconst utils = require('../../utils');\nconst { populateModelSymbol } = require('../symbols');\n\nmodule.exports = function assignVals(o) {\n  // Options that aren't explicitly listed in `populateOptions`\n  const userOptions = Object.assign({}, get(o, 'allOptions.options.options'), get(o, 'allOptions.options'));\n  // `o.options` contains options explicitly listed in `populateOptions`, like\n  // `match` and `limit`.\n  const populateOptions = Object.assign({}, o.options, userOptions, {\n    justOne: o.justOne\n  });\n  populateOptions.$nullIfNotFound = o.isVirtual;\n  const populatedModel = o.populatedModel;\n\n  const originalIds = [].concat(o.rawIds);\n\n  // replace the original ids in our intermediate _ids structure\n  // with the documents found by query\n  o.allIds = [].concat(o.allIds);\n  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);\n\n  // now update the original documents being populated using the\n  // result structure that contains real documents.\n  const docs = o.docs;\n  const rawIds = o.rawIds;\n  const options = o.options;\n  const count = o.count && o.isVirtual;\n  let i;\n\n  function setValue(val) {\n    if (count) {\n      return val;\n    }\n    if (val instanceof SkipPopulateValue) {\n      return val.val;\n    }\n    if (val === void 0) {\n      return val;\n    }\n\n    const _allIds = o.allIds[i];\n\n    if (o.path.endsWith('.$*')) {\n      // Skip maps re: gh-12494\n      return valueFilter(val, options, populateOptions, _allIds);\n    }\n\n    if (o.justOne === true && Array.isArray(val)) {\n      // Might be an embedded discriminator (re: gh-9244) with multiple models, so make sure to pick the right\n      // model before assigning.\n      const ret = [];\n      for (const doc of val) {\n        const _docPopulatedModel = leanPopulateMap.get(doc);\n        if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {\n          ret.push(doc);\n        }\n      }\n      // Since we don't want to have to create a new mongoosearray, make sure to\n      // modify the array in place\n      while (val.length > ret.length) {\n        Array.prototype.pop.apply(val, []);\n      }\n      for (let i = 0; i < ret.length; ++i) {\n        val[i] = ret[i];\n      }\n\n      return valueFilter(val[0], options, populateOptions, _allIds);\n    } else if (o.justOne === false && !Array.isArray(val)) {\n      return valueFilter([val], options, populateOptions, _allIds);\n    }\n    return valueFilter(val, options, populateOptions, _allIds);\n  }\n\n  for (i = 0; i < docs.length; ++i) {\n    const _path = o.path.endsWith('.$*') ? o.path.slice(0, -3) : o.path;\n    const existingVal = mpath.get(_path, docs[i], lookupLocalFields);\n    if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {\n      continue;\n    }\n\n    let valueToSet;\n    if (count) {\n      valueToSet = numDocs(rawIds[i]);\n    } else if (Array.isArray(o.match)) {\n      valueToSet = Array.isArray(rawIds[i]) ?\n        rawIds[i].filter(sift(o.match[i])) :\n        [rawIds[i]].filter(sift(o.match[i]))[0];\n    } else {\n      valueToSet = rawIds[i];\n    }\n\n    // If we're populating a map, the existing value will be an object, so\n    // we need to transform again\n    const originalSchema = o.originalModel.schema;\n    const isDoc = get(docs[i], '$__', null) != null;\n    let isMap = isDoc ?\n      existingVal instanceof Map :\n      utils.isPOJO(existingVal);\n    // If we pass the first check, also make sure the local field's schematype\n    // is map (re: gh-6460)\n    isMap = isMap && get(originalSchema._getSchema(_path), '$isSchemaMap');\n    if (!o.isVirtual && isMap) {\n      const _keys = existingVal instanceof Map ?\n        Array.from(existingVal.keys()) :\n        Object.keys(existingVal);\n      valueToSet = valueToSet.reduce((cur, v, i) => {\n        cur.set(_keys[i], v);\n        return cur;\n      }, new Map());\n    }\n\n    if (isDoc && Array.isArray(valueToSet)) {\n      for (const val of valueToSet) {\n        if (val != null && val.$__ != null) {\n          val.$__.parent = docs[i];\n        }\n      }\n    } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {\n      valueToSet.$__.parent = docs[i];\n    }\n\n    if (o.isVirtual && isDoc) {\n      docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);\n      // If virtual populate and doc is already init-ed, need to walk through\n      // the actual doc to set rather than setting `_doc` directly\n      if (Array.isArray(valueToSet)) {\n        valueToSet = valueToSet.map(v => v == null ? void 0 : v);\n      }\n      mpath.set(_path, valueToSet, docs[i], void 0, setValue, false);\n      continue;\n    }\n\n    const parts = _path.split('.');\n    let cur = docs[i];\n    const curPath = parts[0];\n    for (let j = 0; j < parts.length - 1; ++j) {\n      // If we get to an array with a dotted path, like `arr.foo`, don't set\n      // `foo` on the array.\n      if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {\n        break;\n      }\n\n      if (parts[j] === '$*') {\n        break;\n      }\n\n      if (cur[parts[j]] == null) {\n        // If nothing to set, avoid creating an unnecessary array. Otherwise\n        // we'll end up with a single doc in the array with only defaults.\n        // See gh-8342, gh-8455\n        const schematype = originalSchema._getSchema(curPath);\n        if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {\n          break;\n        }\n        cur[parts[j]] = {};\n      }\n      cur = cur[parts[j]];\n      // If the property in MongoDB is a primitive, we won't be able to populate\n      // the nested path, so skip it. See gh-7545\n      if (typeof cur !== 'object') {\n        break;\n      }\n    }\n    if (docs[i].$__) {\n      o.allOptions.options[populateModelSymbol] = o.allOptions.model;\n      docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options);\n\n      if (valueToSet != null && valueToSet.$__ != null) {\n        valueToSet.$__.wasPopulated = { value: o.unpopulatedValues[i] };\n      }\n\n      if (valueToSet instanceof Map && !valueToSet.$isMongooseMap) {\n        valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType);\n      }\n    }\n\n    // If lean, need to check that each individual virtual respects\n    // `justOne`, because you may have a populated virtual with `justOne`\n    // underneath an array. See gh-6867\n    mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);\n\n    if (docs[i].$__) {\n      markArraySubdocsPopulated(docs[i], [o.allOptions.options]);\n    }\n  }\n};\n\nfunction numDocs(v) {\n  if (Array.isArray(v)) {\n    // If setting underneath an array of populated subdocs, we may have an\n    // array of arrays. See gh-7573\n    if (v.some(el => Array.isArray(el) || el === null)) {\n      return v.map(el => {\n        if (el == null) {\n          return 0;\n        }\n        if (Array.isArray(el)) {\n          return el.filter(el => el != null).length;\n        }\n        return 1;\n      });\n    }\n    return v.filter(el => el != null).length;\n  }\n  return v == null ? 0 : 1;\n}\n\n/**\n * 1) Apply backwards compatible find/findOne behavior to sub documents\n *\n *    find logic:\n *      a) filter out non-documents\n *      b) remove _id from sub docs when user specified\n *\n *    findOne\n *      a) if no doc found, set to null\n *      b) remove _id from sub docs when user specified\n *\n * 2) Remove _ids when specified by users query.\n *\n * background:\n * _ids are left in the query even when user excludes them so\n * that population mapping can occur.\n * @param {Any} val\n * @param {Object} assignmentOpts\n * @param {Object} populateOptions\n * @param {Function} [populateOptions.transform]\n * @param {Boolean} allIds\n * @api private\n */\n\nfunction valueFilter(val, assignmentOpts, populateOptions, allIds) {\n  const userSpecifiedTransform = typeof populateOptions.transform === 'function';\n  const transform = userSpecifiedTransform ? populateOptions.transform : noop;\n  if (Array.isArray(val)) {\n    // find logic\n    const ret = [];\n    const numValues = val.length;\n    for (let i = 0; i < numValues; ++i) {\n      let subdoc = val[i];\n      const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;\n      if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {\n        continue;\n      } else if (!populateOptions.retainNullValues && subdoc == null) {\n        continue;\n      } else if (userSpecifiedTransform) {\n        subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);\n      }\n      maybeRemoveId(subdoc, assignmentOpts);\n      ret.push(subdoc);\n      if (assignmentOpts.originalLimit &&\n          ret.length >= assignmentOpts.originalLimit) {\n        break;\n      }\n    }\n\n    const rLen = ret.length;\n    // Since we don't want to have to create a new mongoosearray, make sure to\n    // modify the array in place\n    while (val.length > rLen) {\n      Array.prototype.pop.apply(val, []);\n    }\n    let i = 0;\n    if (utils.isMongooseArray(val)) {\n      for (i = 0; i < rLen; ++i) {\n        val.set(i, ret[i], true);\n      }\n    } else {\n      for (i = 0; i < rLen; ++i) {\n        val[i] = ret[i];\n      }\n    }\n    return val;\n  }\n\n  // findOne\n  if (isPopulatedObject(val) || utils.isPOJO(val)) {\n    maybeRemoveId(val, assignmentOpts);\n    return transform(val, allIds);\n  }\n  if (val instanceof Map) {\n    return val;\n  }\n\n  if (populateOptions.justOne === false) {\n    return [];\n  }\n\n  return val == null ? transform(val, allIds) : transform(null, allIds);\n}\n\n/**\n * Remove _id from `subdoc` if user specified \"lean\" query option\n * @param {Document} subdoc\n * @param {Object} assignmentOpts\n * @api private\n */\n\nfunction maybeRemoveId(subdoc, assignmentOpts) {\n  if (subdoc != null && assignmentOpts.excludeId) {\n    if (typeof subdoc.$__setValue === 'function') {\n      delete subdoc._doc._id;\n    } else {\n      delete subdoc._id;\n    }\n  }\n}\n\n/**\n * Determine if `obj` is something we can set a populated path to. Can be a\n * document, a lean document, or an array/map that contains docs.\n * @param {Any} obj\n * @api private\n */\n\nfunction isPopulatedObject(obj) {\n  if (obj == null) {\n    return false;\n  }\n\n  return Array.isArray(obj) ||\n    obj.$isMongooseMap ||\n    obj.$__ != null ||\n    leanPopulateMap.has(obj);\n}\n\nfunction noop(v) {\n  return v;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}