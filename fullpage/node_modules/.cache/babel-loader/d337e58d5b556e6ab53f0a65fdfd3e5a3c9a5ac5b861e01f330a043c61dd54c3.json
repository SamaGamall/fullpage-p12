{"ast":null,"code":"/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseConnection = require('../../connection');\nconst STATES = require('../../connectionstate');\nconst setTimeout = require('../../helpers/timers').setTimeout;\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.\n *\n * @inherits Connection\n * @api private\n */\n\nfunction NativeConnection() {\n  MongooseConnection.apply(this, arguments);\n  this._listening = false;\n}\n\n/**\n * Expose the possible connection states.\n * @api public\n */\n\nNativeConnection.STATES = STATES;\n\n/*!\n * Inherits from Connection.\n */\n\nObject.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);\n\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db. If you set the `useCache`\n * option, `useDb()` will cache connections by `name`.\n *\n * **Note:** Calling `close()` on a `useDb()` connection will close the base connection as well.\n *\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @param {Boolean} [options.noListener=false] If true, the new connection object won't listen to any events on the base connection. This is better for memory usage in cases where you're calling `useDb()` for every request.\n * @return {Connection} New Connection Object\n * @api public\n */\n\nNativeConnection.prototype.useDb = function (name, options) {\n  // Return immediately if cached\n  options = options || {};\n  if (options.useCache && this.relatedDbs[name]) {\n    return this.relatedDbs[name];\n  }\n\n  // we have to manually copy all of the attributes...\n  const newConn = new this.constructor();\n  newConn.name = name;\n  newConn.base = this.base;\n  newConn.collections = {};\n  newConn.models = {};\n  newConn.replica = this.replica;\n  newConn.config = Object.assign({}, this.config, newConn.config);\n  newConn.name = this.name;\n  newConn.options = this.options;\n  newConn._readyState = this._readyState;\n  newConn._closeCalled = this._closeCalled;\n  newConn._hasOpened = this._hasOpened;\n  newConn._listening = false;\n  newConn._parent = this;\n  newConn.host = this.host;\n  newConn.port = this.port;\n  newConn.user = this.user;\n  newConn.pass = this.pass;\n\n  // First, when we create another db object, we are not guaranteed to have a\n  // db object to work with. So, in the case where we have a db object and it\n  // is connected, we can just proceed with setting everything up. However, if\n  // we do not have a db or the state is not connected, then we need to wait on\n  // the 'open' event of the connection before doing the rest of the setup\n  // the 'connected' event is the first time we'll have access to the db object\n\n  const _this = this;\n  newConn.client = _this.client;\n  if (this.db && this._readyState === STATES.connected) {\n    wireup();\n  } else {\n    this.once('connected', wireup);\n  }\n  function wireup() {\n    newConn.client = _this.client;\n    const _opts = {};\n    if (options.hasOwnProperty('noListener')) {\n      _opts.noListener = options.noListener;\n    }\n    newConn.db = _this.client.db(name, _opts);\n    newConn.onOpen();\n  }\n  newConn.name = name;\n\n  // push onto the otherDbs stack, this is used when state changes\n  if (options.noListener !== true) {\n    this.otherDbs.push(newConn);\n  }\n  newConn.otherDbs.push(this);\n\n  // push onto the relatedDbs cache, this is used when state changes\n  if (options && options.useCache) {\n    this.relatedDbs[newConn.name] = newConn;\n    newConn.relatedDbs = this.relatedDbs;\n  }\n  return newConn;\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force]\n * @return {Connection} this\n * @api private\n */\n\nNativeConnection.prototype.doClose = async function doClose(force) {\n  if (this.client == null) {\n    return this;\n  }\n  let skipCloseClient = false;\n  if (force != null && typeof force === 'object') {\n    skipCloseClient = force.skipCloseClient;\n    force = force.force;\n  }\n  if (skipCloseClient) {\n    return this;\n  }\n  await this.client.close(force);\n  // Defer because the driver will wait at least 1ms before finishing closing\n  // the pool, see https://github.com/mongodb-js/mongodb-core/blob/a8f8e4ce41936babc3b9112bf42d609779f03b39/lib/connection/pool.js#L1026-L1030.\n  // If there's queued operations, you may still get some background work\n  // after the callback is called.\n  await new Promise(resolve => setTimeout(resolve, 1));\n  return this;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeConnection;","map":{"version":3,"names":["MongooseConnection","require","STATES","setTimeout","NativeConnection","apply","arguments","_listening","Object","setPrototypeOf","prototype","useDb","name","options","useCache","relatedDbs","newConn","constructor","base","collections","models","replica","config","assign","_readyState","_closeCalled","_hasOpened","_parent","host","port","user","pass","_this","client","db","connected","wireup","once","_opts","hasOwnProperty","noListener","onOpen","otherDbs","push","doClose","force","skipCloseClient","close","Promise","resolve","module","exports"],"sources":["C:/Users/sama/Documents/fullpage/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js"],"sourcesContent":["/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseConnection = require('../../connection');\nconst STATES = require('../../connectionstate');\nconst setTimeout = require('../../helpers/timers').setTimeout;\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.\n *\n * @inherits Connection\n * @api private\n */\n\nfunction NativeConnection() {\n  MongooseConnection.apply(this, arguments);\n  this._listening = false;\n}\n\n/**\n * Expose the possible connection states.\n * @api public\n */\n\nNativeConnection.STATES = STATES;\n\n/*!\n * Inherits from Connection.\n */\n\nObject.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);\n\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db. If you set the `useCache`\n * option, `useDb()` will cache connections by `name`.\n *\n * **Note:** Calling `close()` on a `useDb()` connection will close the base connection as well.\n *\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @param {Boolean} [options.noListener=false] If true, the new connection object won't listen to any events on the base connection. This is better for memory usage in cases where you're calling `useDb()` for every request.\n * @return {Connection} New Connection Object\n * @api public\n */\n\nNativeConnection.prototype.useDb = function(name, options) {\n  // Return immediately if cached\n  options = options || {};\n  if (options.useCache && this.relatedDbs[name]) {\n    return this.relatedDbs[name];\n  }\n\n  // we have to manually copy all of the attributes...\n  const newConn = new this.constructor();\n  newConn.name = name;\n  newConn.base = this.base;\n  newConn.collections = {};\n  newConn.models = {};\n  newConn.replica = this.replica;\n  newConn.config = Object.assign({}, this.config, newConn.config);\n  newConn.name = this.name;\n  newConn.options = this.options;\n  newConn._readyState = this._readyState;\n  newConn._closeCalled = this._closeCalled;\n  newConn._hasOpened = this._hasOpened;\n  newConn._listening = false;\n  newConn._parent = this;\n\n  newConn.host = this.host;\n  newConn.port = this.port;\n  newConn.user = this.user;\n  newConn.pass = this.pass;\n\n  // First, when we create another db object, we are not guaranteed to have a\n  // db object to work with. So, in the case where we have a db object and it\n  // is connected, we can just proceed with setting everything up. However, if\n  // we do not have a db or the state is not connected, then we need to wait on\n  // the 'open' event of the connection before doing the rest of the setup\n  // the 'connected' event is the first time we'll have access to the db object\n\n  const _this = this;\n\n  newConn.client = _this.client;\n\n  if (this.db && this._readyState === STATES.connected) {\n    wireup();\n  } else {\n    this.once('connected', wireup);\n  }\n\n  function wireup() {\n    newConn.client = _this.client;\n    const _opts = {};\n    if (options.hasOwnProperty('noListener')) {\n      _opts.noListener = options.noListener;\n    }\n    newConn.db = _this.client.db(name, _opts);\n    newConn.onOpen();\n  }\n\n  newConn.name = name;\n\n  // push onto the otherDbs stack, this is used when state changes\n  if (options.noListener !== true) {\n    this.otherDbs.push(newConn);\n  }\n  newConn.otherDbs.push(this);\n\n  // push onto the relatedDbs cache, this is used when state changes\n  if (options && options.useCache) {\n    this.relatedDbs[newConn.name] = newConn;\n    newConn.relatedDbs = this.relatedDbs;\n  }\n\n  return newConn;\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force]\n * @return {Connection} this\n * @api private\n */\n\nNativeConnection.prototype.doClose = async function doClose(force) {\n  if (this.client == null) {\n    return this;\n  }\n\n  let skipCloseClient = false;\n  if (force != null && typeof force === 'object') {\n    skipCloseClient = force.skipCloseClient;\n    force = force.force;\n  }\n\n  if (skipCloseClient) {\n    return this;\n  }\n\n  await this.client.close(force);\n  // Defer because the driver will wait at least 1ms before finishing closing\n  // the pool, see https://github.com/mongodb-js/mongodb-core/blob/a8f8e4ce41936babc3b9112bf42d609779f03b39/lib/connection/pool.js#L1026-L1030.\n  // If there's queued operations, you may still get some background work\n  // after the callback is called.\n  await new Promise(resolve => setTimeout(resolve, 1));\n\n  return this;\n};\n\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeConnection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}