{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst Aggregate = require('./aggregate');\nconst ChangeStream = require('./cursor/ChangeStream');\nconst Document = require('./document');\nconst DocumentNotFoundError = require('./error/notFound');\nconst DivergentArrayError = require('./error/divergentArray');\nconst EventEmitter = require('events').EventEmitter;\nconst MongooseBuffer = require('./types/buffer');\nconst MongooseError = require('./error/index');\nconst OverwriteModelError = require('./error/overwriteModel');\nconst Query = require('./query');\nconst SaveOptions = require('./options/saveOptions');\nconst Schema = require('./schema');\nconst ValidationError = require('./error/validation');\nconst VersionError = require('./error/version');\nconst ParallelSaveError = require('./error/parallelSave');\nconst applyDefaultsHelper = require('./helpers/document/applyDefaults');\nconst applyDefaultsToPOJO = require('./helpers/model/applyDefaultsToPOJO');\nconst applyQueryMiddleware = require('./helpers/query/applyQueryMiddleware');\nconst applyHooks = require('./helpers/model/applyHooks');\nconst applyMethods = require('./helpers/model/applyMethods');\nconst applyProjection = require('./helpers/projection/applyProjection');\nconst applySchemaCollation = require('./helpers/indexes/applySchemaCollation');\nconst applyStaticHooks = require('./helpers/model/applyStaticHooks');\nconst applyStatics = require('./helpers/model/applyStatics');\nconst applyWriteConcern = require('./helpers/schema/applyWriteConcern');\nconst assignVals = require('./helpers/populate/assignVals');\nconst castBulkWrite = require('./helpers/model/castBulkWrite');\nconst clone = require('./helpers/clone');\nconst createPopulateQueryFilter = require('./helpers/populate/createPopulateQueryFilter');\nconst getDefaultBulkwriteResult = require('./helpers/getDefaultBulkwriteResult');\nconst getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');\nconst discriminator = require('./helpers/model/discriminator');\nconst firstKey = require('./helpers/firstKey');\nconst each = require('./helpers/each');\nconst get = require('./helpers/get');\nconst getConstructorName = require('./helpers/getConstructorName');\nconst getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');\nconst getModelsMapForPopulate = require('./helpers/populate/getModelsMapForPopulate');\nconst immediate = require('./helpers/immediate');\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\nconst isDefaultIdIndex = require('./helpers/indexes/isDefaultIdIndex');\nconst isIndexEqual = require('./helpers/indexes/isIndexEqual');\nconst {\n  getRelatedDBIndexes,\n  getRelatedSchemaIndexes\n} = require('./helpers/indexes/getRelatedIndexes');\nconst isPathExcluded = require('./helpers/projection/isPathExcluded');\nconst decorateDiscriminatorIndexOptions = require('./helpers/indexes/decorateDiscriminatorIndexOptions');\nconst isPathSelectedInclusive = require('./helpers/projection/isPathSelectedInclusive');\nconst leanPopulateMap = require('./helpers/populate/leanPopulateMap');\nconst modifiedPaths = require('./helpers/update/modifiedPaths');\nconst parallelLimit = require('./helpers/parallelLimit');\nconst parentPaths = require('./helpers/path/parentPaths');\nconst prepareDiscriminatorPipeline = require('./helpers/aggregate/prepareDiscriminatorPipeline');\nconst pushNestedArrayPaths = require('./helpers/model/pushNestedArrayPaths');\nconst removeDeselectedForeignField = require('./helpers/populate/removeDeselectedForeignField');\nconst setDottedPath = require('./helpers/path/setDottedPath');\nconst STATES = require('./connectionstate');\nconst util = require('util');\nconst utils = require('./utils');\nconst VERSION_WHERE = 1;\nconst VERSION_INC = 2;\nconst VERSION_ALL = VERSION_WHERE | VERSION_INC;\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\nconst modelCollectionSymbol = Symbol('mongoose#Model#collection');\nconst modelDbSymbol = Symbol('mongoose#Model#db');\nconst modelSymbol = require('./helpers/symbols').modelSymbol;\nconst subclassedSymbol = Symbol('mongoose#Model#subclassed');\nconst saveToObjectOptions = Object.assign({}, internalToObjectOptions, {\n  bson: true\n});\n\n/**\n * A Model is a class that's your primary tool for interacting with MongoDB.\n * An instance of a Model is called a [Document](https://mongoosejs.com/docs/api/document.html#Document).\n *\n * In Mongoose, the term \"Model\" refers to subclasses of the `mongoose.Model`\n * class. You should not use the `mongoose.Model` class directly. The\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) and\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()) functions\n * create subclasses of `mongoose.Model` as shown below.\n *\n * #### Example:\n *\n *     // `UserModel` is a \"Model\", a subclass of `mongoose.Model`.\n *     const UserModel = mongoose.model('User', new Schema({ name: String }));\n *\n *     // You can use a Model to create new documents using `new`:\n *     const userDoc = new UserModel({ name: 'Foo' });\n *     await userDoc.save();\n *\n *     // You also use a model to create queries:\n *     const userFromDb = await UserModel.findOne({ name: 'Foo' });\n *\n * @param {Object} doc values for initial set\n * @param {Object} [fields] optional object containing the fields that were selected in the query which returned this document. You do **not** need to set this parameter to ensure Mongoose handles your [query projection](https://mongoosejs.com/docs/api/query.html#Query.prototype.select()).\n * @param {Boolean} [skipId=false] optional boolean. If true, mongoose doesn't add an `_id` field to the document.\n * @inherits Document https://mongoosejs.com/docs/api/document.html\n * @event `error`: If listening to this event, 'error' is emitted when a document was saved and an `error` occurred. If not listening, the event bubbles to the connection used to create this Model.\n * @event `index`: Emitted after `Model#ensureIndexes` completes. If an error occurred it is passed with the event.\n * @event `index-single-start`: Emitted when an individual index starts within `Model#ensureIndexes`. The fields and options being used to build the index are also passed with the event.\n * @event `index-single-done`: Emitted when an individual index finishes within `Model#ensureIndexes`. If an error occurred it is passed with the event. The fields, options, and index name are also passed.\n * @api public\n */\n\nfunction Model(doc, fields, skipId) {\n  if (fields instanceof Schema) {\n    throw new TypeError('2nd argument to `Model` must be a POJO or string, ' + '**not** a schema. Make sure you\\'re calling `mongoose.model()`, not ' + '`mongoose.Model()`.');\n  }\n  Document.call(this, doc, fields, skipId);\n}\n\n/**\n * Inherits from Document.\n *\n * All Model.prototype features are available on\n * top level (non-sub) documents.\n * @api private\n */\n\nObject.setPrototypeOf(Model.prototype, Document.prototype);\nModel.prototype.$isMongooseModelPrototype = true;\n\n/**\n * Connection the model uses.\n *\n * @api public\n * @property db\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.db;\n\n/**\n * Collection the model uses.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api public\n * @property collection\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.collection;\n\n/**\n * Internal collection the model uses.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api private\n * @property collection\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__collection;\n\n/**\n * The name of the model\n *\n * @api public\n * @property modelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.modelName;\n\n/**\n * Additional properties to attach to the query when calling `save()` and\n * `isNew` is false.\n *\n * @api public\n * @property $where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$where;\n\n/**\n * If this is a discriminator model, `baseModelName` is the name of\n * the base model.\n *\n * @api public\n * @property baseModelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.baseModelName;\n\n/**\n * Event emitter that reports any errors that occurred. Useful for global error\n * handling.\n *\n * #### Example:\n *\n *     MyModel.events.on('error', err => console.log(err.message));\n *\n *     // Prints a 'CastError' because of the above handler\n *     await MyModel.findOne({ _id: 'Not a valid ObjectId' }).catch(noop);\n *\n * @api public\n * @property events\n * @fires error whenever any query or model function errors\n * @memberOf Model\n * @static\n */\n\nModel.events;\n\n/**\n * Compiled middleware for this model. Set in `applyHooks()`.\n *\n * @api private\n * @property _middleware\n * @memberOf Model\n * @static\n */\n\nModel._middleware;\n\n/*!\n * ignore\n */\n\nfunction _applyCustomWhere(doc, where) {\n  if (doc.$where == null) {\n    return;\n  }\n  for (const key of Object.keys(doc.$where)) {\n    where[key] = doc.$where[key];\n  }\n}\n\n/*!\n * ignore\n */\n\nModel.prototype.$__handleSave = function (options, callback) {\n  const saveOptions = {};\n  applyWriteConcern(this.$__schema, options);\n  if (typeof options.writeConcern !== 'undefined') {\n    saveOptions.writeConcern = {};\n    if ('w' in options.writeConcern) {\n      saveOptions.writeConcern.w = options.writeConcern.w;\n    }\n    if ('j' in options.writeConcern) {\n      saveOptions.writeConcern.j = options.writeConcern.j;\n    }\n    if ('wtimeout' in options.writeConcern) {\n      saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;\n    }\n  } else {\n    if ('w' in options) {\n      saveOptions.w = options.w;\n    }\n    if ('j' in options) {\n      saveOptions.j = options.j;\n    }\n    if ('wtimeout' in options) {\n      saveOptions.wtimeout = options.wtimeout;\n    }\n  }\n  if ('checkKeys' in options) {\n    saveOptions.checkKeys = options.checkKeys;\n  }\n  const session = this.$session();\n  if (!saveOptions.hasOwnProperty('session') && session != null) {\n    saveOptions.session = session;\n  }\n  if (this.$isNew) {\n    // send entire doc\n    const obj = this.toObject(saveToObjectOptions);\n    if ((obj || {})._id === void 0) {\n      // documents must have an _id else mongoose won't know\n      // what to update later if more changes are made. the user\n      // wouldn't know what _id was generated by mongodb either\n      // nor would the ObjectId generated by mongodb necessarily\n      // match the schema definition.\n      immediate(function () {\n        callback(new MongooseError('document must have an _id before saving'));\n      });\n      return;\n    }\n    this.$__version(true, obj);\n    this[modelCollectionSymbol].insertOne(obj, saveOptions).then(ret => callback(null, ret), err => {\n      _setIsNew(this, true);\n      callback(err, null);\n    });\n    this.$__reset();\n    _setIsNew(this, false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n    return;\n  }\n\n  // Make sure we don't treat it as a new object on error,\n  // since it already exists\n  this.$__.inserting = false;\n  const delta = this.$__delta();\n  if (delta) {\n    if (delta instanceof MongooseError) {\n      callback(delta);\n      return;\n    }\n    const where = this.$__where(delta[0]);\n    if (where instanceof MongooseError) {\n      callback(where);\n      return;\n    }\n    _applyCustomWhere(this, where);\n    this[modelCollectionSymbol].updateOne(where, delta[1], saveOptions).then(ret => {\n      ret.$where = where;\n      callback(null, ret);\n    }, err => {\n      this.$__undoReset();\n      callback(err);\n    });\n  } else {\n    const optionsWithCustomValues = Object.assign({}, options, saveOptions);\n    const where = this.$__where();\n    const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;\n    if (optimisticConcurrency) {\n      const key = this.$__schema.options.versionKey;\n      const val = this.$__getValue(key);\n      if (val != null) {\n        where[key] = val;\n      }\n    }\n    this.constructor.collection.findOne(where, optionsWithCustomValues).then(documentExists => {\n      const matchedCount = !documentExists ? 0 : 1;\n      callback(null, {\n        $where: where,\n        matchedCount\n      });\n    }).catch(callback);\n    return;\n  }\n\n  // store the modified paths before the document is reset\n  this.$__.modifiedPaths = this.modifiedPaths();\n  this.$__reset();\n  _setIsNew(this, false);\n};\n\n/*!\n * ignore\n */\n\nModel.prototype.$__save = function (options, callback) {\n  this.$__handleSave(options, (error, result) => {\n    if (error) {\n      const hooks = this.$__schema.s.hooks;\n      return hooks.execPost('save:error', this, [this], {\n        error: error\n      }, error => {\n        callback(error, this);\n      });\n    }\n    let numAffected = 0;\n    const writeConcern = options != null ? options.writeConcern != null ? options.writeConcern.w : options.w : 0;\n    if (writeConcern !== 0) {\n      // Skip checking if write succeeded if writeConcern is set to\n      // unacknowledged writes, because otherwise `numAffected` will always be 0\n      if (result != null) {\n        if (Array.isArray(result)) {\n          numAffected = result.length;\n        } else if (result.matchedCount != null) {\n          numAffected = result.matchedCount;\n        } else {\n          numAffected = result;\n        }\n      }\n      const versionBump = this.$__.version;\n      // was this an update that required a version bump?\n      if (versionBump && !this.$__.inserting) {\n        const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);\n        this.$__.version = undefined;\n        const key = this.$__schema.options.versionKey;\n        const version = this.$__getValue(key) || 0;\n        if (numAffected <= 0) {\n          // the update failed. pass an error back\n          this.$__undoReset();\n          const err = this.$__.$versionError || new VersionError(this, version, this.$__.modifiedPaths);\n          return callback(err);\n        }\n\n        // increment version if was successful\n        if (doIncrement) {\n          this.$__setValue(key, version + 1);\n        }\n      }\n      if (result != null && numAffected <= 0) {\n        this.$__undoReset();\n        error = new DocumentNotFoundError(result.$where, this.constructor.modelName, numAffected, result);\n        const hooks = this.$__schema.s.hooks;\n        return hooks.execPost('save:error', this, [this], {\n          error: error\n        }, error => {\n          callback(error, this);\n        });\n      }\n    }\n    this.$__.saving = undefined;\n    this.$__.savedState = {};\n    this.$emit('save', this, numAffected);\n    this.constructor.emit('save', this, numAffected);\n    callback(null, this);\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction generateVersionError(doc, modifiedPaths) {\n  const key = doc.$__schema.options.versionKey;\n  if (!key) {\n    return null;\n  }\n  const version = doc.$__getValue(key) || 0;\n  return new VersionError(doc, version, modifiedPaths);\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) is `true`,\n * or sends an [updateOne](https://mongoosejs.com/docs/api/document.html#Document.prototype.updateOne()) operation with just the modified paths if `isNew` is `false`.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](https://mongoosejs.com/docs/api/document.html#Document.prototype.session()).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com/docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] if `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#mongodb-limit-Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @throws {DocumentNotFoundError} if this [save updates an existing document](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise}\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\nModel.prototype.save = async function save(options) {\n  if (typeof options === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.save() no longer accepts a callback');\n  }\n  let parallelSave;\n  this.$op = 'save';\n  if (this.$__.saving) {\n    parallelSave = new ParallelSaveError(this);\n  } else {\n    this.$__.saving = new ParallelSaveError(this);\n  }\n  options = new SaveOptions(options);\n  if (options.hasOwnProperty('session')) {\n    this.$session(options.session);\n  }\n  if (this.$__.timestamps != null) {\n    options.timestamps = this.$__.timestamps;\n  }\n  this.$__.$versionError = generateVersionError(this, this.modifiedPaths());\n  if (parallelSave) {\n    this.$__handleReject(parallelSave);\n    throw parallelSave;\n  }\n  this.$__.saveOptions = options;\n  await new Promise((resolve, reject) => {\n    this.$__save(options, error => {\n      this.$__.saving = null;\n      this.$__.saveOptions = null;\n      this.$__.$versionError = null;\n      this.$op = null;\n      if (error != null) {\n        this.$__handleReject(error);\n        return reject(error);\n      }\n      resolve();\n    });\n  });\n  return this;\n};\nModel.prototype.$save = Model.prototype.save;\n\n/**\n * Determines whether versioning should be skipped for the given path\n *\n * @param {Document} self\n * @param {String} path\n * @return {Boolean} true if versioning should be skipped for the given path\n * @api private\n */\nfunction shouldSkipVersioning(self, path) {\n  const skipVersioning = self.$__schema.options.skipVersioning;\n  if (!skipVersioning) return false;\n\n  // Remove any array indexes from the path\n  path = path.replace(/\\.\\d+\\./, '.');\n  return skipVersioning[path];\n}\n\n/**\n * Apply the operation to the delta (update) clause as\n * well as track versioning for our where clause.\n *\n * @param {Document} self\n * @param {Object} where Unused\n * @param {Object} delta\n * @param {Object} data\n * @param {Mixed} val\n * @param {String} [op]\n * @api private\n */\n\nfunction operand(self, where, delta, data, val, op) {\n  // delta\n  op || (op = '$set');\n  if (!delta[op]) delta[op] = {};\n  delta[op][data.path] = val;\n  // disabled versioning?\n  if (self.$__schema.options.versionKey === false) return;\n\n  // path excluded from versioning?\n  if (shouldSkipVersioning(self, data.path)) return;\n\n  // already marked for versioning?\n  if (VERSION_ALL === (VERSION_ALL & self.$__.version)) return;\n  if (self.$__schema.options.optimisticConcurrency) {\n    return;\n  }\n  switch (op) {\n    case '$set':\n    case '$unset':\n    case '$pop':\n    case '$pull':\n    case '$pullAll':\n    case '$push':\n    case '$addToSet':\n    case '$inc':\n      break;\n    default:\n      // nothing to do\n      return;\n  }\n\n  // ensure updates sent with positional notation are\n  // editing the correct array element.\n  // only increment the version if an array position changes.\n  // modifying elements of an array is ok if position does not change.\n  if (op === '$push' || op === '$addToSet' || op === '$pullAll' || op === '$pull') {\n    if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {\n      increment.call(self);\n    } else {\n      self.$__.version = VERSION_INC;\n    }\n  } else if (/^\\$p/.test(op)) {\n    // potentially changing array positions\n    increment.call(self);\n  } else if (Array.isArray(val)) {\n    // $set an array\n    increment.call(self);\n  } else if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {\n    // now handling $set, $unset\n    // subpath of array\n    self.$__.version = VERSION_WHERE;\n  }\n}\n\n/**\n * Compiles an update and where clause for a `val` with _atomics.\n *\n * @param {Document} self\n * @param {Object} where\n * @param {Object} delta\n * @param {Object} data\n * @param {Array} value\n * @api private\n */\n\nfunction handleAtomics(self, where, delta, data, value) {\n  if (delta.$set && delta.$set[data.path]) {\n    // $set has precedence over other atomics\n    return;\n  }\n  if (typeof value.$__getAtomics === 'function') {\n    value.$__getAtomics().forEach(function (atomic) {\n      const op = atomic[0];\n      const val = atomic[1];\n      operand(self, where, delta, data, val, op);\n    });\n    return;\n  }\n\n  // legacy support for plugins\n\n  const atomics = value[arrayAtomicsSymbol];\n  const ops = Object.keys(atomics);\n  let i = ops.length;\n  let val;\n  let op;\n  if (i === 0) {\n    // $set\n\n    if (utils.isMongooseObject(value)) {\n      value = value.toObject({\n        depopulate: 1,\n        _isNested: true\n      });\n    } else if (value.valueOf) {\n      value = value.valueOf();\n    }\n    return operand(self, where, delta, data, value);\n  }\n  function iter(mem) {\n    return utils.isMongooseObject(mem) ? mem.toObject({\n      depopulate: 1,\n      _isNested: true\n    }) : mem;\n  }\n  while (i--) {\n    op = ops[i];\n    val = atomics[op];\n    if (utils.isMongooseObject(val)) {\n      val = val.toObject({\n        depopulate: true,\n        transform: false,\n        _isNested: true\n      });\n    } else if (Array.isArray(val)) {\n      val = val.map(iter);\n    } else if (val.valueOf) {\n      val = val.valueOf();\n    }\n    if (op === '$addToSet') {\n      val = {\n        $each: val\n      };\n    }\n    operand(self, where, delta, data, val, op);\n  }\n}\n\n/**\n * Produces a special query document of the modified properties used in updates.\n *\n * @api private\n * @method $__delta\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__delta = function () {\n  const dirty = this.$__dirty();\n  const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;\n  if (optimisticConcurrency) {\n    this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;\n  }\n  if (!dirty.length && VERSION_ALL !== this.$__.version) {\n    return;\n  }\n  const where = {};\n  const delta = {};\n  const len = dirty.length;\n  const divergent = [];\n  let d = 0;\n  where._id = this._doc._id;\n  // If `_id` is an object, need to depopulate, but also need to be careful\n  // because `_id` can technically be null (see gh-6406)\n  if ((where && where._id && where._id.$__ || null) != null) {\n    where._id = where._id.toObject({\n      transform: false,\n      depopulate: true\n    });\n  }\n  for (; d < len; ++d) {\n    const data = dirty[d];\n    let value = data.value;\n    const match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n    const pop = this.$populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      const pathSplit = data.path.split('.');\n      const top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === 'undefined') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = '$';\n          data.path = pathSplit.join('.');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    // If this path is set to default, and either this path or one of\n    // its parents is excluded, don't treat this path as dirty.\n    if (this.$isDefault(data.path) && this.$__.selected) {\n      if (data.path.indexOf('.') === -1 && isPathExcluded(this.$__.selected, data.path)) {\n        continue;\n      }\n      const pathsToCheck = parentPaths(data.path);\n      if (pathsToCheck.find(path => isPathExcluded(this.$__.isSelected, path))) {\n        continue;\n      }\n    }\n    if (divergent.length) continue;\n    if (value === undefined) {\n      operand(this, where, delta, data, 1, '$unset');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (utils.isMongooseArray(value) && value.$path() && value[arrayAtomicsSymbol]) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value[MongooseBuffer.pathSymbol] && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[data.path] != null) {\n        const val = this.$__.primitiveAtomics[data.path];\n        const op = firstKey(val);\n        operand(this, where, delta, data, val[op], op);\n      } else {\n        value = clone(value, {\n          depopulate: true,\n          transform: false,\n          virtuals: false,\n          getters: false,\n          omitUndefined: true,\n          _isNested: true\n        });\n        operand(this, where, delta, data, value);\n      }\n    }\n  }\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n  if (Object.keys(delta).length === 0) {\n    return [where, null];\n  }\n  return [where, delta];\n};\n\n/**\n * Determine if array was populated with some form of filter and is now\n * being updated in a manner which could overwrite data unintentionally.\n *\n * @see https://github.com/Automattic/mongoose/issues/1334\n * @param {Document} doc\n * @param {String} path\n * @param {Any} array\n * @return {String|undefined}\n * @api private\n */\n\nfunction checkDivergentArray(doc, path, array) {\n  // see if we populated this path\n  const pop = doc.$populated(path, true);\n  if (!pop && doc.$__.selected) {\n    // If any array was selected using an $elemMatch projection, we deny the update.\n    // NOTE: MongoDB only supports projected $elemMatch on top level array.\n    const top = path.split('.')[0];\n    if (doc.$__.selected[top + '.$']) {\n      return top;\n    }\n  }\n  if (!(pop && utils.isMongooseArray(array))) return;\n\n  // If the array was populated using options that prevented all\n  // documents from being returned (match, skip, limit) or they\n  // deselected the _id field, $pop and $set of the array are\n  // not safe operations. If _id was deselected, we do not know\n  // how to remove elements. $pop will pop off the _id from the end\n  // of the array in the db which is not guaranteed to be the\n  // same as the last element we have here. $set of the entire array\n  // would be similarly destructive as we never received all\n  // elements of the array and potentially would overwrite data.\n  const check = pop.options.match || pop.options.options && utils.object.hasOwnProperty(pop.options.options, 'limit') ||\n  // 0 is not permitted\n  pop.options.options && pop.options.options.skip ||\n  // 0 is permitted\n  pop.options.select && (\n  // deselected _id?\n  pop.options.select._id === 0 || /\\s?-_id\\s?/.test(pop.options.select));\n  if (check) {\n    const atomics = array[arrayAtomicsSymbol];\n    if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {\n      return path;\n    }\n  }\n}\n\n/**\n * Appends versioning to the where and update clauses.\n *\n * @api private\n * @method $__version\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__version = function (where, delta) {\n  const key = this.$__schema.options.versionKey;\n  if (where === true) {\n    // this is an insert\n    if (key) {\n      setDottedPath(delta, key, 0);\n      this.$__setValue(key, 0);\n    }\n    return;\n  }\n  if (key === false) {\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n\n  if (!this.$__isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don't need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    const value = this.$__getValue(key);\n    if (value != null) where[key] = value;\n  }\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (get(delta.$set, key, null) != null) {\n      // Version key is getting set, means we'll increment the doc's version\n      // after a successful save, so we should set the incremented version so\n      // future saves don't fail (gh-5779)\n      ++delta.$set[key];\n    } else {\n      delta.$inc = delta.$inc || {};\n      delta.$inc[key] = 1;\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}\n\n/**\n * Signal that we desire an increment of this documents version.\n *\n * #### Example:\n *\n *     const doc = await Model.findById(id);\n *     doc.increment();\n *     await doc.save();\n *\n * @see versionKeys https://mongoosejs.com/docs/guide.html#versionKey\n * @memberOf Model\n * @method increment\n * @api public\n */\n\nModel.prototype.increment = increment;\n\n/**\n * Returns a query object\n *\n * @api private\n * @method $__where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__where = function _where(where) {\n  where || (where = {});\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n  if (this._doc._id === void 0) {\n    return new MongooseError('No _id found on document!');\n  }\n  return where;\n};\n\n/**\n * Removes this document from the db. Equivalent to `.remove()`.\n *\n * #### Example:\n *\n *     product = await product.deleteOne();\n *     await Product.findById(product._id); // null\n *\n * @return {Promise} Promise\n * @api public\n */\n\nModel.prototype.deleteOne = async function deleteOne(options) {\n  if (typeof options === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n  if (!options) {\n    options = {};\n  }\n  if (options.hasOwnProperty('session')) {\n    this.$session(options.session);\n  }\n  const res = await new Promise((resolve, reject) => {\n    this.$__deleteOne(options, (err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n  return res;\n};\n\n/*!\n * ignore\n */\n\nModel.prototype.$__deleteOne = function $__deleteOne(options, cb) {\n  if (this.$__.isDeleted) {\n    return immediate(() => cb(null, this));\n  }\n  const where = this.$__where();\n  if (where instanceof MongooseError) {\n    return cb(where);\n  }\n  _applyCustomWhere(this, where);\n  const session = this.$session();\n  if (!options.hasOwnProperty('session')) {\n    options.session = session;\n  }\n  this[modelCollectionSymbol].deleteOne(where, options, err => {\n    if (!err) {\n      this.$__.isDeleted = true;\n      this.$emit('deleteOne', this);\n      this.constructor.emit('deleteOne', this);\n      return cb(null, this);\n    }\n    this.$__.isDeleted = false;\n    cb(err);\n  });\n};\n\n/**\n * Returns another Model instance.\n *\n * #### Example:\n *\n *     const doc = new Tank;\n *     await doc.model('User').findById(id);\n *\n * @param {String} name model name\n * @method model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.model = function model(name) {\n  return this[modelDbSymbol].model(name);\n};\n\n/**\n * Returns another Model instance.\n *\n * #### Example:\n *\n *     const doc = new Tank;\n *     await doc.model('User').findById(id);\n *\n * @param {String} name model name\n * @method $model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.$model = function $model(name) {\n  return this[modelDbSymbol].model(name);\n};\n\n/**\n * Returns a document with `_id` only if at least one document exists in the database that matches\n * the given `filter`, and `null` otherwise.\n *\n * Under the hood, `MyModel.exists({ answer: 42 })` is equivalent to\n * `MyModel.findOne({ answer: 42 }).select({ _id: 1 }).lean()`\n *\n * #### Example:\n *\n *     await Character.deleteMany({});\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     await Character.exists({ name: /picard/i }); // { _id: ... }\n *     await Character.exists({ name: /riker/i }); // null\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * @param {Object} filter\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n */\n\nModel.exists = function exists(filter, options) {\n  _checkContext(this, 'exists');\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.exists() no longer accepts a callback');\n  }\n  const query = this.findOne(filter).select({\n    _id: 1\n  }).lean().setOptions(options);\n  return query;\n};\n\n/**\n * Adds a discriminator type.\n *\n * #### Example:\n *\n *     function BaseSchema() {\n *       Schema.apply(this, arguments);\n *\n *       this.add({\n *         name: String,\n *         createdAt: Date\n *       });\n *     }\n *     util.inherits(BaseSchema, Schema);\n *\n *     const PersonSchema = new BaseSchema();\n *     const BossSchema = new BaseSchema({ department: String });\n *\n *     const Person = mongoose.model('Person', PersonSchema);\n *     const Boss = Person.discriminator('Boss', BossSchema);\n *     new Boss().__t; // \"Boss\". `__t` is the default `discriminatorKey`\n *\n *     const employeeSchema = new Schema({ boss: ObjectId });\n *     const Employee = Person.discriminator('Employee', employeeSchema, 'staff');\n *     new Employee().__t; // \"staff\" because of 3rd argument above\n *\n * @param {String} name discriminator model name\n * @param {Schema} schema discriminator model schema\n * @param {Object|String} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @param {Boolean} [options.overwriteModels=false] by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.\n * @param {Boolean} [options.mergeHooks=true] By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to `false` to make Mongoose use the discriminator schema's hooks instead.\n * @param {Boolean} [options.mergePlugins=true] By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to `false` to make Mongoose use the discriminator schema's plugins instead.\n * @return {Model} The newly created discriminator model\n * @api public\n */\n\nModel.discriminator = function (name, schema, options) {\n  let model;\n  if (typeof name === 'function') {\n    model = name;\n    name = utils.getFunctionName(model);\n    if (!(model.prototype instanceof Model)) {\n      throw new MongooseError('The provided class ' + name + ' must extend Model');\n    }\n  }\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n  const mergePlugins = typeof options.mergePlugins === 'boolean' ? options.mergePlugins : true;\n  _checkContext(this, 'discriminator');\n  if (utils.isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n  if (schema instanceof Schema && clone) {\n    schema = schema.clone();\n  }\n  schema = discriminator(this, name, schema, value, mergePlugins, options.mergeHooks);\n  if (this.db.models[name] && !schema.options.overwriteModels) {\n    throw new OverwriteModelError(name);\n  }\n  schema.$isRootDiscriminator = true;\n  schema.$globalPluginsApplied = true;\n  model = this.db.model(model || name, schema, this.$__collection.name);\n  this.discriminators[name] = model;\n  const d = this.discriminators[name];\n  Object.setPrototypeOf(d.prototype, this.prototype);\n  Object.defineProperty(d, 'baseModelName', {\n    value: this.modelName,\n    configurable: true,\n    writable: false\n  });\n\n  // apply methods and statics\n  applyMethods(d, schema);\n  applyStatics(d, schema);\n  if (this[subclassedSymbol] != null) {\n    for (const submodel of this[subclassedSymbol]) {\n      submodel.discriminators = submodel.discriminators || {};\n      submodel.discriminators[name] = model.__subclass(model.db, schema, submodel.collection.name);\n    }\n  }\n  return d;\n};\n\n/**\n * Make sure `this` is a model\n * @api private\n */\n\nfunction _checkContext(ctx, fnName) {\n  // Check context, because it is easy to mistakenly type\n  // `new Model.discriminator()` and get an incomprehensible error\n  if (ctx == null || ctx === global) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' + 'model as `this`. Make sure you are calling `MyModel.' + fnName + '()` ' + 'where `MyModel` is a Mongoose model.');\n  } else if (ctx[modelSymbol] == null) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' + 'model as `this`. Make sure you are not calling ' + '`new Model.' + fnName + '()`');\n  }\n}\n\n// Model (class) features\n\n/*!\n * Give the constructor the ability to emit events.\n */\n\nfor (const i in EventEmitter.prototype) {\n  Model[i] = EventEmitter.prototype[i];\n}\n\n/**\n * This function is responsible for building [indexes](https://www.mongodb.com/docs/manual/indexes/),\n * unless [`autoIndex`](https://mongoosejs.com/docs/guide.html#autoIndex) is turned off.\n *\n * Mongoose calls this function automatically when a model is created using\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) or\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()), so you\n * don't need to call `init()` to trigger index builds.\n *\n * However, you _may_ need to call `init()`  to get back a promise that will resolve when your indexes are finished.\n * Calling `await Model.init()` is helpful if you need to wait for indexes to build before continuing.\n * For example, if you want to wait for unique indexes to build before continuing with a test case.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     // This calls `Event.init()` implicitly, so you don't need to call\n *     // `Event.init()` on your own.\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     await Event.init();\n *     console.log('Indexes are done building!');\n *\n * @api public\n * @returns {Promise}\n */\n\nModel.init = function init() {\n  _checkContext(this, 'init');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.init() no longer accepts a callback');\n  }\n  this.schema.emit('init', this);\n  if (this.$init != null) {\n    return this.$init;\n  }\n  const conn = this.db;\n  const _ensureIndexes = async () => {\n    const autoIndex = utils.getOption('autoIndex', this.schema.options, conn.config, conn.base.options);\n    if (!autoIndex) {\n      return;\n    }\n    return await this.ensureIndexes({\n      _automatic: true\n    });\n  };\n  const _createCollection = async () => {\n    if ((conn.readyState === STATES.connecting || conn.readyState === STATES.disconnected) && conn._shouldBufferCommands()) {\n      await new Promise(resolve => {\n        conn._queue.push({\n          fn: resolve\n        });\n      });\n    }\n    const autoCreate = utils.getOption('autoCreate', this.schema.options, conn.config, conn.base.options);\n    if (!autoCreate) {\n      return;\n    }\n    return await this.createCollection();\n  };\n  this.$init = _createCollection().then(() => _ensureIndexes());\n  const _catch = this.$init.catch;\n  const _this = this;\n  this.$init.catch = function () {\n    _this.$caught = true;\n    return _catch.apply(_this.$init, arguments);\n  };\n  return this.$init;\n};\n\n/**\n * Create the collection for this model. By default, if no indexes are specified,\n * mongoose will not create the collection for the model until any documents are\n * created. Use this method to create the collection explicitly.\n *\n * Note 1: You may need to call this before starting a transaction\n * See https://www.mongodb.com/docs/manual/core/transactions/#transactions-and-operations\n *\n * Note 2: You don't have to call this if your schema contains index or unique field.\n * In that case, just use `Model.init()`\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String })\n *     const User = mongoose.model('User', userSchema);\n *\n *     User.createCollection().then(function(collection) {\n *       console.log('Collection is created!');\n *     });\n *\n * @api public\n * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n * @returns {Promise}\n */\n\nModel.createCollection = async function createCollection(options) {\n  _checkContext(this, 'createCollection');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createCollection() no longer accepts a callback');\n  }\n  const schemaCollation = this && this.schema && this.schema.options && this.schema.options.collation;\n  if (schemaCollation != null) {\n    options = Object.assign({\n      collation: schemaCollation\n    }, options);\n  }\n  const capped = this && this.schema && this.schema.options && this.schema.options.capped;\n  if (capped != null) {\n    if (typeof capped === 'number') {\n      options = Object.assign({\n        capped: true,\n        size: capped\n      }, options);\n    } else if (typeof capped === 'object') {\n      options = Object.assign({\n        capped: true\n      }, capped, options);\n    }\n  }\n  const timeseries = this && this.schema && this.schema.options && this.schema.options.timeseries;\n  if (timeseries != null) {\n    options = Object.assign({\n      timeseries\n    }, options);\n    if (options.expireAfterSeconds != null) {\n      // do nothing\n    } else if (options.expires != null) {\n      utils.expires(options);\n    } else if (this.schema.options.expireAfterSeconds != null) {\n      options.expireAfterSeconds = this.schema.options.expireAfterSeconds;\n    } else if (this.schema.options.expires != null) {\n      options.expires = this.schema.options.expires;\n      utils.expires(options);\n    }\n  }\n  const clusteredIndex = this && this.schema && this.schema.options && this.schema.options.clusteredIndex;\n  if (clusteredIndex != null) {\n    options = Object.assign({\n      clusteredIndex: {\n        ...clusteredIndex,\n        unique: true\n      }\n    }, options);\n  }\n  try {\n    await this.db.createCollection(this.$__collection.collectionName, options);\n  } catch (err) {\n    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n      throw err;\n    }\n  }\n  return this.$__collection;\n};\n\n/**\n * Makes the indexes in MongoDB match the indexes defined in this model's\n * schema. This function will drop any indexes that are not defined in\n * the model's schema except the `_id` index, and build any indexes that\n * are in your schema but not in MongoDB.\n *\n * See the [introductory blog post](https://thecodebarbarian.com/whats-new-in-mongoose-5-2-syncindexes)\n * for more information.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.collection.createIndex({ age: 1 }); // Index is not in schema\n *     // Will drop the 'age' index and create an index on `name`\n *     await Customer.syncIndexes();\n *\n * @param {Object} [options] options to pass to `ensureIndexes()`\n * @param {Boolean} [options.background=null] if specified, overrides each index's `background` property\n * @return {Promise}\n * @api public\n */\n\nModel.syncIndexes = async function syncIndexes(options) {\n  _checkContext(this, 'syncIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n  const model = this;\n  try {\n    await model.createCollection();\n  } catch (err) {\n    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n      throw err;\n    }\n  }\n  const diffIndexesResult = await model.diffIndexes();\n  const dropped = await model.cleanIndexes({\n    ...options,\n    toDrop: diffIndexesResult.toDrop\n  });\n  await model.createIndexes({\n    ...options,\n    toCreate: diffIndexesResult.toCreate\n  });\n  return dropped;\n};\n\n/**\n * Does a dry-run of Model.syncIndexes(), meaning that\n * the result of this function would be the result of\n * Model.syncIndexes().\n *\n * @param {Object} [options]\n * @returns {Promise} which contains an object, {toDrop, toCreate}, which\n * are indexes that would be dropped in MongoDB and indexes that would be created in MongoDB.\n */\n\nModel.diffIndexes = async function diffIndexes() {\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n  const model = this;\n  let dbIndexes = await model.listIndexes();\n  if (dbIndexes === undefined) {\n    dbIndexes = [];\n  }\n  dbIndexes = getRelatedDBIndexes(model, dbIndexes);\n  const schema = model.schema;\n  const schemaIndexes = getRelatedSchemaIndexes(model, schema.indexes());\n  const toDrop = getIndexesToDrop(schema, schemaIndexes, dbIndexes);\n  const toCreate = getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop);\n  return {\n    toDrop,\n    toCreate\n  };\n};\nfunction getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop) {\n  const toCreate = [];\n  for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n    let found = false;\n    const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n    for (const index of dbIndexes) {\n      if (isDefaultIdIndex(index)) {\n        continue;\n      }\n      if (isIndexEqual(schemaIndexKeysObject, options, index) && !toDrop.includes(index.name)) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      toCreate.push(schemaIndexKeysObject);\n    }\n  }\n  return toCreate;\n}\nfunction getIndexesToDrop(schema, schemaIndexes, dbIndexes) {\n  const toDrop = [];\n  for (const dbIndex of dbIndexes) {\n    let found = false;\n    // Never try to drop `_id` index, MongoDB server doesn't allow it\n    if (isDefaultIdIndex(dbIndex)) {\n      continue;\n    }\n    for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n      const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n      applySchemaCollation(schemaIndexKeysObject, options, schema.options);\n      if (isIndexEqual(schemaIndexKeysObject, options, dbIndex)) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      toDrop.push(dbIndex.name);\n    }\n  }\n  return toDrop;\n}\n/**\n * Deletes all indexes that aren't defined in this model's schema. Used by\n * `syncIndexes()`.\n *\n * The returned promise resolves to a list of the dropped indexes' names as an array\n *\n * @param {Function} [callback] optional callback\n * @return {Promise|undefined} Returns `undefined` if callback is specified, returns a promise if no callback.\n * @api public\n */\n\nModel.cleanIndexes = async function cleanIndexes(options) {\n  _checkContext(this, 'cleanIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.cleanIndexes() no longer accepts a callback');\n  }\n  const model = this;\n  const collection = model.$__collection;\n  if (Array.isArray(options && options.toDrop)) {\n    const res = await _dropIndexes(options.toDrop, collection);\n    return res;\n  }\n  const res = await model.diffIndexes();\n  return await _dropIndexes(res.toDrop, collection);\n};\nasync function _dropIndexes(toDrop, collection) {\n  if (toDrop.length === 0) {\n    return [];\n  }\n  await Promise.all(toDrop.map(indexName => collection.dropIndex(indexName)));\n  return toDrop;\n}\n\n/**\n * Lists the indexes currently defined in MongoDB. This may or may not be\n * the same as the indexes defined in your schema depending on whether you\n * use the [`autoIndex` option](https://mongoosejs.com/docs/guide.html#autoIndex) and if you\n * build indexes manually.\n *\n * @return {Promise}\n * @api public\n */\n\nModel.listIndexes = async function listIndexes() {\n  _checkContext(this, 'listIndexes');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.listIndexes() no longer accepts a callback');\n  }\n  if (this.$__collection.buffer) {\n    await new Promise(resolve => {\n      this.$__collection.addQueue(resolve);\n    });\n  }\n  return this.$__collection.listIndexes().toArray();\n};\n\n/**\n * Sends `createIndex` commands to mongo for each index declared in the schema.\n * The `createIndex` commands are sent in series.\n *\n * #### Example:\n *\n *     Event.ensureIndexes(function (err) {\n *       if (err) return handleError(err);\n *     });\n *\n * After completion, an `index` event is emitted on this `Model` passing an error if one occurred.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     Event.on('index', function (err) {\n *       if (err) console.error(err); // error occurred during index creation\n *     })\n *\n * _NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution._\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.ensureIndexes = async function ensureIndexes(options) {\n  _checkContext(this, 'ensureIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.ensureIndexes() no longer accepts a callback');\n  }\n  await new Promise((resolve, reject) => {\n    _ensureIndexes(this, options, err => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n};\n\n/**\n * Similar to `ensureIndexes()`, except for it uses the [`createIndex`](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createIndex)\n * function.\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.createIndexes = async function createIndexes(options) {\n  _checkContext(this, 'createIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createIndexes() no longer accepts a callback');\n  }\n  return this.ensureIndexes(options);\n};\n\n/*!\n * ignore\n */\n\nfunction _ensureIndexes(model, options, callback) {\n  const indexes = model.schema.indexes();\n  let indexError;\n  options = options || {};\n  const done = function (err) {\n    if (err && !model.$caught) {\n      model.emit('error', err);\n    }\n    model.emit('index', err || indexError);\n    callback && callback(err || indexError);\n  };\n  for (const index of indexes) {\n    if (isDefaultIdIndex(index)) {\n      utils.warn('mongoose: Cannot specify a custom index on `_id` for ' + 'model name \"' + model.modelName + '\", ' + 'MongoDB does not allow overwriting the default `_id` index. See ' + 'https://bit.ly/mongodb-id-index');\n    }\n  }\n  if (!indexes.length) {\n    immediate(function () {\n      done();\n    });\n    return;\n  }\n  // Indexes are created one-by-one to support how MongoDB < 2.4 deals\n  // with background indexes.\n\n  const indexSingleDone = function (err, fields, options, name) {\n    model.emit('index-single-done', err, fields, options, name);\n  };\n  const indexSingleStart = function (fields, options) {\n    model.emit('index-single-start', fields, options);\n  };\n  const baseSchema = model.schema._baseSchema;\n  const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];\n  immediate(function () {\n    // If buffering is off, do this manually.\n    if (options._automatic && !model.collection.collection) {\n      model.collection.addQueue(create, []);\n    } else {\n      create();\n    }\n  });\n  function create() {\n    if (options._automatic) {\n      if (model.schema.options.autoIndex === false || model.schema.options.autoIndex == null && model.db.config.autoIndex === false) {\n        return done();\n      }\n    }\n    const index = indexes.shift();\n    if (!index) {\n      return done();\n    }\n    if (options._automatic && index[1]._autoIndex === false) {\n      return create();\n    }\n    if (baseSchemaIndexes.find(i => utils.deepEqual(i, index))) {\n      return create();\n    }\n    const indexFields = clone(index[0]);\n    const indexOptions = clone(index[1]);\n    delete indexOptions._autoIndex;\n    decorateDiscriminatorIndexOptions(model.schema, indexOptions);\n    applyWriteConcern(model.schema, indexOptions);\n    applySchemaCollation(indexFields, indexOptions, model.schema.options);\n    indexSingleStart(indexFields, options);\n    if ('background' in options) {\n      indexOptions.background = options.background;\n    }\n    if ('toCreate' in options) {\n      if (options.toCreate.length === 0) {\n        return done();\n      }\n    }\n    model.collection.createIndex(indexFields, indexOptions).then(name => {\n      indexSingleDone(null, indexFields, indexOptions, name);\n      create();\n    }, err => {\n      if (!indexError) {\n        indexError = err;\n      }\n      if (!model.$caught) {\n        model.emit('error', err);\n      }\n      indexSingleDone(err, indexFields, indexOptions);\n      create();\n    });\n  }\n}\n\n/**\n * Schema the model uses.\n *\n * @property schema\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.schema;\n\n/**\n * Connection instance the model uses.\n *\n * @property db\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.db;\n\n/**\n * Collection the model uses.\n *\n * @property collection\n * @api public\n * @memberOf Model\n */\n\nModel.collection;\n\n/**\n * Internal collection the model uses.\n *\n * @property collection\n * @api private\n * @memberOf Model\n */\nModel.$__collection;\n\n/**\n * Base Mongoose instance the model uses.\n *\n * @property base\n * @api public\n * @memberOf Model\n */\n\nModel.base;\n\n/**\n * Registered discriminators for this model.\n *\n * @property discriminators\n * @api public\n * @memberOf Model\n */\n\nModel.discriminators;\n\n/**\n * Translate any aliases fields/conditions so the final query or document object is pure\n *\n * #### Example:\n *\n *     Character\n *       .find(Character.translateAliases({\n *         '名': 'Eddard Stark' // Alias for 'name'\n *       })\n *       .exec(function(err, characters) {})\n *\n * #### Note:\n *\n * Only translate arguments of object type anything else is returned raw\n *\n * @param {Object} fields fields/conditions that may contain aliased keys\n * @return {Object} the translated 'pure' fields/conditions\n */\nModel.translateAliases = function translateAliases(fields) {\n  _checkContext(this, 'translateAliases');\n  const translate = (key, value) => {\n    let alias;\n    const translated = [];\n    const fieldKeys = key.split('.');\n    let currentSchema = this.schema;\n    for (const i in fieldKeys) {\n      const name = fieldKeys[i];\n      if (currentSchema && currentSchema.aliases[name]) {\n        alias = currentSchema.aliases[name];\n        // Alias found,\n        translated.push(alias);\n      } else {\n        alias = name;\n        // Alias not found, so treat as un-aliased key\n        translated.push(name);\n      }\n\n      // Check if aliased path is a schema\n      if (currentSchema && currentSchema.paths[alias]) {\n        currentSchema = currentSchema.paths[alias].schema;\n      } else currentSchema = null;\n    }\n    const translatedKey = translated.join('.');\n    if (fields instanceof Map) fields.set(translatedKey, value);else fields[translatedKey] = value;\n    if (translatedKey !== key) {\n      // We'll be using the translated key instead\n      if (fields instanceof Map) {\n        // Delete from map\n        fields.delete(key);\n      } else {\n        // Delete from object\n        delete fields[key]; // We'll be using the translated key instead\n      }\n    }\n\n    return fields;\n  };\n  if (typeof fields === 'object') {\n    // Fields is an object (query conditions or document fields)\n    if (fields instanceof Map) {\n      // A Map was supplied\n      for (const field of new Map(fields)) {\n        fields = translate(field[0], field[1]);\n      }\n    } else {\n      // Infer a regular object was supplied\n      for (const key of Object.keys(fields)) {\n        fields = translate(key, fields[key]);\n        if (key[0] === '$') {\n          if (Array.isArray(fields[key])) {\n            for (const i in fields[key]) {\n              // Recursively translate nested queries\n              fields[key][i] = this.translateAliases(fields[key][i]);\n            }\n          }\n        }\n      }\n    }\n    return fields;\n  } else {\n    // Don't know typeof fields\n    return fields;\n  }\n};\n\n/**\n * Deletes the first document that matches `conditions` from the collection.\n * It returns an object with the property `deletedCount` indicating how many documents were deleted.\n * Behaves like `remove()`, but deletes at most one document regardless of the\n * `single` option.\n *\n * #### Example:\n *\n *     await Character.deleteOne({ name: 'Eddard Stark' }); // returns {deletedCount: 1}\n *\n * #### Note:\n *\n * This function triggers `deleteOne` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @api public\n */\n\nModel.deleteOne = function deleteOne(conditions, options) {\n  _checkContext(this, 'deleteOne');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n  return mq.deleteOne(conditions);\n};\n\n/**\n * Deletes all of the documents that match `conditions` from the collection.\n * It returns an object with the property `deletedCount` containing the number of documents deleted.\n * Behaves like `remove()`, but deletes all documents that match `conditions`\n * regardless of the `single` option.\n *\n * #### Example:\n *\n *     await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }); // returns {deletedCount: x} where x is the number of documents deleted.\n *\n * #### Note:\n *\n * This function triggers `deleteMany` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @api public\n */\n\nModel.deleteMany = function deleteMany(conditions, options) {\n  _checkContext(this, 'deleteMany');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.deleteMany() no longer accepts a callback');\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n  return mq.deleteMany(conditions);\n};\n\n/**\n * Finds documents.\n *\n * Mongoose casts the `filter` to match the model's schema before the command is sent.\n * See our [query casting tutorial](https://mongoosejs.com/docs/tutorials/query_casting.html) for\n * more information on how Mongoose casts `filter`.\n *\n * #### Example:\n *\n *     // find all documents\n *     await MyModel.find({});\n *\n *     // find all documents named john and at least 18\n *     await MyModel.find({ name: 'john', age: { $gte: 18 } }).exec();\n *\n *     // executes, name LIKE john and only selecting the \"name\" and \"friends\" fields\n *     await MyModel.find({ name: /john/i }, 'name friends').exec();\n *\n *     // passing options\n *     await MyModel.find({ name: /john/i }, null, { skip: 10 }).exec();\n *\n * @param {Object|ObjectId} filter\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see query casting https://mongoosejs.com/docs/tutorials/query_casting.html\n * @api public\n */\n\nModel.find = function find(conditions, projection, options) {\n  _checkContext(this, 'find');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.find() no longer accepts a callback');\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n  return mq.find(conditions);\n};\n\n/**\n * Finds a single document by its _id field. `findById(id)` is almost*\n * equivalent to `findOne({ _id: id })`. If you want to query by a document's\n * `_id`, use `findById()` instead of `findOne()`.\n *\n * The `id` is cast based on the Schema before sending the command.\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * \\* Except for how it treats `undefined`. If you use `findOne()`, you'll see\n * that `findOne(undefined)` and `findOne({ _id: undefined })` are equivalent\n * to `findOne({})` and return arbitrary documents. However, mongoose\n * translates `findById(undefined)` into `findOne({ _id: null })`.\n *\n * #### Example:\n *\n *     // Find the adventure with the given `id`, or `null` if not found\n *     await Adventure.findById(id).exec();\n *\n *     // select only the adventures name and length\n *     await Adventure.findById(id, 'name length').exec();\n *\n * @param {Any} id value of `_id` to query by\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @see findById in Mongoose https://masteringjs.io/tutorials/mongoose/find-by-id\n * @api public\n */\n\nModel.findById = function findById(id, projection, options) {\n  _checkContext(this, 'findById');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findById() no longer accepts a callback');\n  }\n  if (typeof id === 'undefined') {\n    id = null;\n  }\n  return this.findOne({\n    _id: id\n  }, projection, options);\n};\n\n/**\n * Finds one document.\n *\n * The `conditions` are cast to their respective SchemaTypes before the command is sent.\n *\n * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `findById()` instead.\n *\n * #### Example:\n *\n *     // Find one adventure whose `country` is 'Croatia', otherwise `null`\n *     await Adventure.findOne({ country: 'Croatia' }).exec();\n *\n *     // Model.findOne() no longer accepts a callback\n *\n *     // Select only the adventures name and length\n *     await Adventure.findOne({ country: 'Croatia' }, 'name length').exec();\n *\n * @param {Object} [conditions]\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @api public\n */\n\nModel.findOne = function findOne(conditions, projection, options) {\n  _checkContext(this, 'findOne');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOne() no longer accepts a callback');\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n  return mq.findOne(conditions);\n};\n\n/**\n * Estimates the number of documents in the MongoDB collection. Faster than\n * using `countDocuments()` for large collections because\n * `estimatedDocumentCount()` uses collection metadata rather than scanning\n * the entire collection.\n *\n * #### Example:\n *\n *     const numAdventures = await Adventure.estimatedDocumentCount();\n *\n * @param {Object} [options]\n * @return {Query}\n * @api public\n */\n\nModel.estimatedDocumentCount = function estimatedDocumentCount(options) {\n  _checkContext(this, 'estimatedDocumentCount');\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  return mq.estimatedDocumentCount(options);\n};\n\n/**\n * Counts number of documents matching `filter` in a database collection.\n *\n * #### Example:\n *\n *     Adventure.countDocuments({ type: 'jungle' }, function (err, count) {\n *       console.log('there are %d jungle adventures', count);\n *     });\n *\n * If you want to count all documents in a large collection,\n * use the [`estimatedDocumentCount()` function](https://mongoosejs.com/docs/api/model.html#Model.estimatedDocumentCount())\n * instead. If you call `countDocuments({})`, MongoDB will always execute\n * a full collection scan and **not** use any indexes.\n *\n * The `countDocuments()` function is similar to `count()`, but there are a\n * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * Below are the operators that `count()` supports but `countDocuments()` does not,\n * and the suggested replacement:\n *\n * - `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)\n * - `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)\n * - `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n *\n * @param {Object} filter\n * @return {Query}\n * @api public\n */\n\nModel.countDocuments = function countDocuments(conditions, options) {\n  _checkContext(this, 'countDocuments');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.countDocuments() no longer accepts a callback');\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  if (options != null) {\n    mq.setOptions(options);\n  }\n  return mq.countDocuments(conditions);\n};\n\n/**\n * Counts number of documents that match `filter` in a database collection.\n *\n * This method is deprecated. If you want to count the number of documents in\n * a collection, e.g. `count({})`, use the [`estimatedDocumentCount()` function](https://mongoosejs.com/docs/api/model.html#Model.estimatedDocumentCount())\n * instead. Otherwise, use the [`countDocuments()`](https://mongoosejs.com/docs/api/model.html#Model.countDocuments()) function instead.\n *\n * #### Example:\n *\n *     const count = await Adventure.count({ type: 'jungle' });\n *     console.log('there are %d jungle adventures', count);\n *\n * @deprecated\n * @param {Object} [filter]\n * @return {Query}\n * @api public\n */\n\nModel.count = function count(conditions) {\n  _checkContext(this, 'count');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.count() no longer accepts a callback');\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  return mq.count(conditions);\n};\n\n/**\n * Creates a Query for a `distinct` operation.\n *\n * #### Example:\n *\n *     const query = Link.distinct('url');\n *     query.exec();\n *\n * @param {String} field\n * @param {Object} [conditions] optional\n * @return {Query}\n * @api public\n */\n\nModel.distinct = function distinct(field, conditions) {\n  _checkContext(this, 'distinct');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.distinct() no longer accepts a callback');\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  return mq.distinct(field, conditions);\n};\n\n/**\n * Creates a Query, applies the passed conditions, and returns the Query.\n *\n * For example, instead of writing:\n *\n *     User.find({ age: { $gte: 21, $lte: 65 } });\n *\n * we can instead write:\n *\n *     User.where('age').gte(21).lte(65).exec();\n *\n * Since the Query class also supports `where` you can continue chaining\n *\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^b/i)\n *     ... etc\n *\n * @param {String} path\n * @param {Object} [val] optional value\n * @return {Query}\n * @api public\n */\n\nModel.where = function where(path, val) {\n  _checkContext(this, 'where');\n  void val; // eslint\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.where.apply(mq, arguments);\n};\n\n/**\n * Creates a `Query` and specifies a `$where` condition.\n *\n * Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.\n *\n *     Blog.$where('this.username.indexOf(\"val\") !== -1').exec(function (err, docs) {});\n *\n * @param {String|Function} argument is a javascript string or anonymous function\n * @method $where\n * @memberOf Model\n * @return {Query}\n * @see Query.$where https://mongoosejs.com/docs/api/query.html#Query.prototype.$where\n * @api public\n */\n\nModel.$where = function $where() {\n  _checkContext(this, '$where');\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.$where.apply(mq, arguments);\n};\n\n/**\n * Issues a mongodb findAndModify update command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes if `callback` is passed else a Query object is returned.\n *\n * #### Example:\n *\n *     A.findOneAndUpdate(conditions, update, options)  // returns Query\n *     A.findOneAndUpdate(conditions, update)           // returns Query\n *     A.findOneAndUpdate()                             // returns Query\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     const query = { name: 'borne' };\n *     Model.findOneAndUpdate(query, { name: 'jason bourne' }, options)\n *\n *     // is sent as\n *     Model.findOneAndUpdate(query, { $set: { name: 'jason bourne' }}, options)\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation that\n * you can enable by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id);\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} [conditions]\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.overwrite=false] By default, if you don't include any [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/) in `update`, Mongoose will wrap `update` in `$set` for you. This prevents you from accidentally overwriting the document. This option tells Mongoose to skip adding `$set`. An alternative to this would be using [Model.findOneAndReplace(conditions, update, options, callback)](https://mongoosejs.com/docs/api/model.html#Model.findOneAndReplace()).\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.fields] Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @return {Query}\n * @see Tutorial https://mongoosejs.com/docs/tutorials/findoneandupdate.html\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findOneAndUpdate = function (conditions, update, options) {\n  _checkContext(this, 'findOneAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndUpdate() no longer accepts a callback');\n  }\n  if (arguments.length === 1) {\n    update = conditions;\n    conditions = null;\n    options = null;\n  }\n  let fields;\n  if (options) {\n    fields = options.fields || options.projection;\n  }\n  update = clone(update, {\n    depopulate: true,\n    _isNested: true\n  });\n  _decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n  return mq.findOneAndUpdate(conditions, update, options);\n};\n\n/**\n * Decorate the update with a version key, if necessary\n * @api private\n */\n\nfunction _decorateUpdateWithVersionKey(update, options, versionKey) {\n  if (!versionKey || !(options && options.upsert || false)) {\n    return;\n  }\n  const updatedPaths = modifiedPaths(update);\n  if (!updatedPaths[versionKey]) {\n    if (options.overwrite) {\n      update[versionKey] = 0;\n    } else {\n      if (!update.$setOnInsert) {\n        update.$setOnInsert = {};\n      }\n      update.$setOnInsert[versionKey] = 0;\n    }\n  }\n}\n\n/**\n * Issues a mongodb findAndModify update command by a document's _id field.\n * `findByIdAndUpdate(id, ...)` is equivalent to `findOneAndUpdate({ _id: id }, ...)`.\n *\n * Finds a matching document, updates it according to the `update` arg,\n * passing any `options`, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndUpdate()`\n *\n * #### Example:\n *\n *     A.findByIdAndUpdate(id, update, options)  // returns Query\n *     A.findByIdAndUpdate(id, update)           // returns Query\n *     A.findByIdAndUpdate()                     // returns Query\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options)\n *\n *     // is sent as\n *     Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options)\n *\n * This helps prevent accidentally overwriting your document with `{ name: 'jason bourne' }`.\n * To prevent this behaviour, see the `overwrite` option\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.overwrite=false] By default, if you don't include any [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/) in `update`, Mongoose will wrap `update` in `$set` for you. This prevents you from accidentally overwriting the document. This option tells Mongoose to skip adding `$set`. An alternative to this would be using [Model.findOneAndReplace({ _id: id }, update, options)](https://mongoosejs.com/docs/api/model.html#Model.findOneAndReplace()).\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.select] sets the document fields to return.\n * @return {Query}\n * @see Model.findOneAndUpdate https://mongoosejs.com/docs/api/model.html#Model.findOneAndUpdate()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findByIdAndUpdate = function (id, update, options) {\n  _checkContext(this, 'findByIdAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findByIdAndUpdate() no longer accepts a callback');\n  }\n\n  // if a model is passed in instead of an id\n  if (id instanceof Document) {\n    id = id._id;\n  }\n  return this.findOneAndUpdate.call(this, {\n    _id: id\n  }, update, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * This function differs slightly from `Model.findOneAndRemove()` in that\n * `findOneAndRemove()` becomes a [MongoDB `findAndModify()` command](https://www.mongodb.com/docs/manual/reference/method/db.collection.findAndModify/),\n * as opposed to a `findOneAndDelete()` command. For most mongoose use cases,\n * this distinction is purely pedantic. You should use `findOneAndDelete()`\n * unless you have a good reason not to.\n *\n * #### Example:\n *\n *     A.findOneAndDelete(conditions, options)  // return Query\n *     A.findOneAndDelete(conditions) // returns Query\n *     A.findOneAndDelete()           // returns Query\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndDelete = function (conditions, options) {\n  _checkContext(this, 'findOneAndDelete');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOneAndDelete() no longer accepts a callback');\n  }\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n  return mq.findOneAndDelete(conditions, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command by a document's _id field.\n * In other words, `findByIdAndDelete(id)` is a shorthand for\n * `findOneAndDelete({ _id: id })`.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @return {Query}\n * @see Model.findOneAndRemove https://mongoosejs.com/docs/api/model.html#Model.findOneAndRemove()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n */\n\nModel.findByIdAndDelete = function (id, options) {\n  _checkContext(this, 'findByIdAndDelete');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findByIdAndDelete() no longer accepts a callback');\n  }\n  return this.findOneAndDelete({\n    _id: id\n  }, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndReplace()` command.\n *\n * Finds a matching document, replaces it with the provided doc, and returns the document.\n *\n * This function triggers the following query middleware.\n *\n * - `findOneAndReplace()`\n *\n * #### Example:\n *\n *     A.findOneAndReplace(filter, replacement, options)  // return Query\n *     A.findOneAndReplace(filter, replacement) // returns Query\n *     A.findOneAndReplace()                    // returns Query\n *\n * @param {Object} filter Replace the first document that matches this filter\n * @param {Object} [replacement] Replace with this document\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndReplace = function (filter, replacement, options) {\n  _checkContext(this, 'findOneAndReplace');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndReplace() no longer accepts a callback');\n  }\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n  return mq.findOneAndReplace(filter, replacement, options);\n};\n\n/**\n * Issue a mongodb findAndModify remove command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndRemove()`\n *\n * #### Example:\n *\n *     A.findOneAndRemove(conditions, options)  // return Query\n *     A.findOneAndRemove(conditions) // returns Query\n *     A.findOneAndRemove()           // returns Query\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id);\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @return {Query}\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findOneAndRemove = function (conditions, options) {\n  _checkContext(this, 'findOneAndRemove');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndRemove() no longer accepts a callback');\n  }\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n  return mq.findOneAndRemove(conditions, options);\n};\n\n/**\n * Issue a mongodb findAndModify remove command by a document's _id field. `findByIdAndRemove(id, ...)` is equivalent to `findOneAndRemove({ _id: id }, ...)`.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndRemove()`\n *\n * #### Example:\n *\n *     A.findByIdAndRemove(id, options)  // return Query\n *     A.findByIdAndRemove(id) // returns Query\n *     A.findByIdAndRemove()           // returns Query\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Object|String} [options.select] sets the document fields to return.\n * @return {Query}\n * @see Model.findOneAndRemove https://mongoosejs.com/docs/api/model.html#Model.findOneAndRemove()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n */\n\nModel.findByIdAndRemove = function (id, options) {\n  _checkContext(this, 'findByIdAndRemove');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findByIdAndRemove() no longer accepts a callback');\n  }\n  return this.findOneAndRemove({\n    _id: id\n  }, options);\n};\n\n/**\n * Shortcut for saving one or more documents to the database.\n * `MyModel.create(docs)` does `new MyModel(doc).save()` for every doc in\n * docs.\n *\n * This function triggers the following middleware.\n *\n * - `save()`\n *\n * #### Example:\n *\n *     // Insert one new `Character` document\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     // Insert multiple new `Character` documents\n *     await Character.create([{ name: 'Will Riker' }, { name: 'Geordi LaForge' }]);\n *\n *     // Create a new character within a transaction. Note that you **must**\n *     // pass an array as the first parameter to `create()` if you want to\n *     // specify options.\n *     await Character.create([{ name: 'Jean-Luc Picard' }], { session });\n *\n * @param {Array|Object} docs Documents to insert, as a spread or array\n * @param {Object} [options] Options passed down to `save()`. To specify `options`, `docs` **must** be an array, not a spread. See [Model.save](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) for available options.\n * @return {Promise}\n * @api public\n */\n\nModel.create = async function create(doc, options) {\n  if (typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.create() no longer accepts a callback');\n  }\n  _checkContext(this, 'create');\n  let args;\n  const discriminatorKey = this.schema.options.discriminatorKey;\n  if (Array.isArray(doc)) {\n    args = doc;\n    options = options != null && typeof options === 'object' ? options : {};\n  } else {\n    const last = arguments[arguments.length - 1];\n    options = {};\n    if (typeof last === 'function' || arguments.length > 1 && !last) {\n      if (typeof options === 'function' || typeof arguments[2] === 'function') {\n        throw new MongooseError('Model.create() no longer accepts a callback');\n      }\n    } else {\n      args = [...arguments];\n    }\n    if (args.length === 2 && args[0] != null && args[1] != null && args[0].session == null && getConstructorName(last.session) === 'ClientSession' && !this.schema.path('session')) {\n      // Probably means the user is running into the common mistake of trying\n      // to use a spread to specify options, see gh-7535\n      utils.warn('WARNING: to pass a `session` to `Model.create()` in ' + 'Mongoose, you **must** pass an array as the first argument. See: ' + 'https://mongoosejs.com/docs/api/model.html#Model.create()');\n    }\n  }\n  if (args.length === 0) {\n    return Array.isArray(doc) ? [] : null;\n  }\n  const res = await Promise.all(args.map(async doc => {\n    const Model = this.discriminators && doc[discriminatorKey] != null ? this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) : this;\n    if (Model == null) {\n      throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` + `found for model \"${this.modelName}\"`);\n    }\n    let toSave = doc;\n    if (!(toSave instanceof Model)) {\n      toSave = new Model(toSave);\n    }\n    await toSave.$save(options);\n    return toSave;\n  }));\n  if (!Array.isArray(doc) && args.length === 1) {\n    return res[0];\n  }\n  return res;\n};\n\n/**\n * _Requires a replica set running MongoDB >= 3.6.0._ Watches the\n * underlying collection for changes using\n * [MongoDB change streams](https://www.mongodb.com/docs/manual/changeStreams/).\n *\n * This function does **not** trigger any middleware. In particular, it\n * does **not** trigger aggregate middleware.\n *\n * The ChangeStream object is an event emitter that emits the following events:\n *\n * - 'change': A change occurred, see below example\n * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n * - 'end': Emitted if the underlying stream is closed\n * - 'close': Emitted if the underlying stream is closed\n *\n * #### Example:\n *\n *     const doc = await Person.create({ name: 'Ned Stark' });\n *     const changeStream = Person.watch().on('change', change => console.log(change));\n *     // Will print from the above `console.log()`:\n *     // { _id: { _data: ... },\n *     //   operationType: 'delete',\n *     //   ns: { db: 'mydb', coll: 'Person' },\n *     //   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }\n *     await doc.remove();\n *\n * @param {Array} [pipeline]\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#watch)\n * @param {Boolean} [options.hydrate=false] if true and `fullDocument: 'updateLookup'` is set, Mongoose will automatically hydrate `fullDocument` into a fully fledged Mongoose document\n * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter\n * @api public\n */\n\nModel.watch = function (pipeline, options) {\n  _checkContext(this, 'watch');\n  const changeStreamThunk = cb => {\n    pipeline = pipeline || [];\n    prepareDiscriminatorPipeline(pipeline, this.schema, 'fullDocument');\n    if (this.$__collection.buffer) {\n      this.$__collection.addQueue(() => {\n        if (this.closed) {\n          return;\n        }\n        const driverChangeStream = this.$__collection.watch(pipeline, options);\n        cb(null, driverChangeStream);\n      });\n    } else {\n      const driverChangeStream = this.$__collection.watch(pipeline, options);\n      cb(null, driverChangeStream);\n    }\n  };\n  options = options || {};\n  options.model = this;\n  return new ChangeStream(changeStreamThunk, pipeline, options);\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * Calling `MyModel.startSession()` is equivalent to calling `MyModel.db.startSession()`.\n *\n * This function does not trigger any middleware.\n *\n * #### Example:\n *\n *     const session = await Person.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.remove();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nModel.startSession = function () {\n  _checkContext(this, 'startSession');\n  return this.db.startSession.apply(this.db, arguments);\n};\n\n/**\n * Shortcut for validating an array of documents and inserting them into\n * MongoDB if they're all valid. This function is faster than `.create()`\n * because it only sends one operation to the server, rather than one for each\n * document.\n *\n * Mongoose always validates each document **before** sending `insertMany`\n * to MongoDB. So if one document has a validation error, no documents will\n * be saved, unless you set\n * [the `ordered` option to false](https://www.mongodb.com/docs/manual/reference/method/db.collection.insertMany/#error-handling).\n *\n * This function does **not** trigger save middleware.\n *\n * This function triggers the following middleware.\n *\n * - `insertMany()`\n *\n * #### Example:\n *\n *     const arr = [{ name: 'Star Wars' }, { name: 'The Empire Strikes Back' }];\n *     Movies.insertMany(arr, function(error, docs) {});\n *\n * @param {Array|Object|*} doc(s)\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#insertMany)\n * @param {Boolean} [options.ordered=true] if true, will fail fast on the first error encountered. If false, will insert all the documents it can and report errors later. An `insertMany()` with `ordered = false` is called an \"unordered\" `insertMany()`.\n * @param {Boolean} [options.rawResult=false] if false, the returned promise resolves to the documents that passed mongoose document validation. If `true`, will return the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/InsertManyResult.html) with a `mongoose` property that contains `validationErrors` and `results` if this is an unordered `insertMany`.\n * @param {Boolean} [options.lean=false] if `true`, skips hydrating and validating the documents. This option is useful if you need the extra performance, but Mongoose won't validate the documents before inserting.\n * @param {Number} [options.limit=null] this limits the number of documents being processed (validation/casting) by mongoose in parallel, this does **NOT** send the documents in batches to MongoDB. Use this option if you're processing a large number of documents and your app is running out of memory.\n * @param {String|Object|Array} [options.populate=null] populates the result documents. This option is a no-op if `rawResult` is set.\n * @return {Promise} resolving to the raw result from the MongoDB driver if `options.rawResult` was `true`, or the documents that passed validation, otherwise\n * @api public\n */\n\nModel.insertMany = async function insertMany(arr, options) {\n  _checkContext(this, 'insertMany');\n  if (typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.insertMany() no longer accepts a callback');\n  }\n  return new Promise((resolve, reject) => {\n    this.$__insertMany(arr, options, (err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * ignore\n *\n * @param {Array} arr\n * @param {Object} options\n * @param {Function} callback\n * @api private\n * @memberOf Model\n * @method $__insertMany\n * @static\n */\n\nModel.$__insertMany = function (arr, options, callback) {\n  const _this = this;\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  callback = callback || utils.noop;\n  options = options || {};\n  const limit = options.limit || 1000;\n  const rawResult = !!options.rawResult;\n  const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n  const lean = !!options.lean;\n  if (!Array.isArray(arr)) {\n    arr = [arr];\n  }\n  const validationErrors = [];\n  const validationErrorsToOriginalOrder = new Map();\n  const results = ordered ? null : new Array(arr.length);\n  const toExecute = arr.map((doc, index) => callback => {\n    if (!(doc instanceof _this)) {\n      try {\n        doc = new _this(doc);\n      } catch (err) {\n        return callback(err);\n      }\n    }\n    if (options.session != null) {\n      doc.$session(options.session);\n    }\n    // If option `lean` is set to true bypass validation\n    if (lean) {\n      // we have to execute callback at the nextTick to be compatible\n      // with parallelLimit, as `results` variable has TDZ issue if we\n      // execute the callback synchronously\n      return immediate(() => callback(null, doc));\n    }\n    doc.$validate().then(() => {\n      callback(null, doc);\n    }, error => {\n      if (ordered === false) {\n        validationErrors.push(error);\n        validationErrorsToOriginalOrder.set(error, index);\n        results[index] = error;\n        return callback(null, null);\n      }\n      callback(error);\n    });\n  });\n  parallelLimit(toExecute, limit, function (error, docs) {\n    if (error) {\n      callback(error, null);\n      return;\n    }\n    const originalDocIndex = new Map();\n    const validDocIndexToOriginalIndex = new Map();\n    for (let i = 0; i < docs.length; ++i) {\n      originalDocIndex.set(docs[i], i);\n    }\n\n    // We filter all failed pre-validations by removing nulls\n    const docAttributes = docs.filter(function (doc) {\n      return doc != null;\n    });\n    for (let i = 0; i < docAttributes.length; ++i) {\n      validDocIndexToOriginalIndex.set(i, originalDocIndex.get(docAttributes[i]));\n    }\n\n    // Make sure validation errors are in the same order as the\n    // original documents, so if both doc1 and doc2 both fail validation,\n    // `Model.insertMany([doc1, doc2])` will always have doc1's validation\n    // error before doc2's. Re: gh-12791.\n    if (validationErrors.length > 0) {\n      validationErrors.sort((err1, err2) => {\n        return validationErrorsToOriginalOrder.get(err1) - validationErrorsToOriginalOrder.get(err2);\n      });\n    }\n\n    // Quickly escape while there aren't any valid docAttributes\n    if (docAttributes.length === 0) {\n      if (rawResult) {\n        const res = {\n          acknowledged: true,\n          insertedCount: 0,\n          insertedIds: {},\n          mongoose: {\n            validationErrors: validationErrors\n          }\n        };\n        return callback(null, res);\n      }\n      callback(null, []);\n      return;\n    }\n    const docObjects = docAttributes.map(function (doc) {\n      if (doc.$__schema.options.versionKey) {\n        doc[doc.$__schema.options.versionKey] = 0;\n      }\n      const shouldSetTimestamps = (!options || options.timestamps !== false) && doc.initializeTimestamps && (!doc.$__ || doc.$__.timestamps !== false);\n      if (shouldSetTimestamps) {\n        return doc.initializeTimestamps().toObject(internalToObjectOptions);\n      }\n      return doc.toObject(internalToObjectOptions);\n    });\n    _this.$__collection.insertMany(docObjects, options).then(res => {\n      for (const attribute of docAttributes) {\n        attribute.$__reset();\n        _setIsNew(attribute, false);\n      }\n      if (rawResult) {\n        if (ordered === false) {\n          for (let i = 0; i < results.length; ++i) {\n            if (results[i] === void 0) {\n              results[i] = docs[i];\n            }\n          }\n\n          // Decorate with mongoose validation errors in case of unordered,\n          // because then still do `insertMany()`\n          res.mongoose = {\n            validationErrors: validationErrors,\n            results: results\n          };\n        }\n        return callback(null, res);\n      }\n      if (options.populate != null) {\n        return _this.populate(docAttributes, options.populate).then(docs => {\n          callback(null, docs);\n        }, err => {\n          if (err != null) {\n            err.insertedDocs = docAttributes;\n          }\n          throw err;\n        });\n      }\n      callback(null, docAttributes);\n    }, error => {\n      // `writeErrors` is a property reported by the MongoDB driver,\n      // just not if there's only 1 error.\n      if (error.writeErrors == null && (error.result && error.result.result && error.result.result.writeErrors) != null) {\n        error.writeErrors = error.result.result.writeErrors;\n      }\n\n      // `insertedDocs` is a Mongoose-specific property\n      const erroredIndexes = new Set((error && error.writeErrors || []).map(err => err.index));\n      for (let i = 0; i < error.writeErrors.length; ++i) {\n        const originalIndex = validDocIndexToOriginalIndex.get(error.writeErrors[i].index);\n        error.writeErrors[i] = {\n          ...error.writeErrors[i],\n          index: originalIndex\n        };\n        if (!ordered) {\n          results[originalIndex] = error.writeErrors[i];\n        }\n      }\n      if (!ordered) {\n        for (let i = 0; i < results.length; ++i) {\n          if (results[i] === void 0) {\n            results[i] = docs[i];\n          }\n        }\n        error.results = results;\n      }\n      let firstErroredIndex = -1;\n      error.insertedDocs = docAttributes.filter((doc, i) => {\n        const isErrored = erroredIndexes.has(i);\n        if (ordered) {\n          if (firstErroredIndex > -1) {\n            return i < firstErroredIndex;\n          }\n          if (isErrored) {\n            firstErroredIndex = i;\n          }\n        }\n        return !isErrored;\n      }).map(function setIsNewForInsertedDoc(doc) {\n        doc.$__reset();\n        _setIsNew(doc, false);\n        return doc;\n      });\n      if (rawResult && ordered === false) {\n        error.mongoose = {\n          validationErrors: validationErrors,\n          results: results\n        };\n      }\n      callback(error, null);\n    });\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction _setIsNew(doc, val) {\n  doc.$isNew = val;\n  doc.$emit('isNew', val);\n  doc.constructor.emit('isNew', val);\n  const subdocs = doc.$getAllSubdocs();\n  for (const subdoc of subdocs) {\n    subdoc.$isNew = val;\n    subdoc.$emit('isNew', val);\n  }\n}\n\n/**\n * Sends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`,\n * `deleteOne`, and/or `deleteMany` operations to the MongoDB server in one\n * command. This is faster than sending multiple independent operations (e.g.\n * if you use `create()`) because with `bulkWrite()` there is only one round\n * trip to MongoDB.\n *\n * Mongoose will perform casting on all operations you provide.\n *\n * This function does **not** trigger any middleware, neither `save()`, nor `update()`.\n * If you need to trigger\n * `save()` middleware for every document use [`create()`](https://mongoosejs.com/docs/api/model.html#Model.create()) instead.\n *\n * #### Example:\n *\n *     Character.bulkWrite([\n *       {\n *         insertOne: {\n *           document: {\n *             name: 'Eddard Stark',\n *             title: 'Warden of the North'\n *           }\n *         }\n *       },\n *       {\n *         updateOne: {\n *           filter: { name: 'Eddard Stark' },\n *           // If you were using the MongoDB driver directly, you'd need to do\n *           // `update: { $set: { title: ... } }` but mongoose adds $set for\n *           // you.\n *           update: { title: 'Hand of the King' }\n *         }\n *       },\n *       {\n *         deleteOne: {\n *           filter: { name: 'Eddard Stark' }\n *         }\n *       }\n *     ]).then(res => {\n *      // Prints \"1 1 1\"\n *      console.log(res.insertedCount, res.modifiedCount, res.deletedCount);\n *     });\n *\n * The [supported operations](https://www.mongodb.com/docs/manual/reference/method/db.collection.bulkWrite/#db.collection.bulkWrite) are:\n *\n * - `insertOne`\n * - `updateOne`\n * - `updateMany`\n * - `deleteOne`\n * - `deleteMany`\n * - `replaceOne`\n *\n * @param {Array} ops\n * @param {Object} [ops.insertOne.document] The document to insert\n * @param {Object} [ops.updateOne.filter] Update the first document that matches this filter\n * @param {Object} [ops.updateOne.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateOne.upsert=false] If true, insert a doc if none match\n * @param {Boolean} [ops.updateOne.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateOne.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateOne.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.updateMany.filter] Update all the documents that match this filter\n * @param {Object} [ops.updateMany.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateMany.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Boolean} [ops.updateMany.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateMany.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateMany.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.deleteOne.filter] Delete the first document that matches this filter\n * @param {Object} [ops.deleteMany.filter] Delete all documents that match this filter\n * @param {Object} [ops.replaceOne.filter] Replace the first document that matches this filter\n * @param {Object} [ops.replaceOne.replacement] The replacement document\n * @param {Boolean} [ops.replaceOne.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Object} [options]\n * @param {Boolean} [options.ordered=true] If true, execute writes in order and stop at the first error. If false, execute writes in parallel and continue until all writes have either succeeded or errored.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n * @param {Boolean} [options.skipValidation=false] Set to true to skip Mongoose schema validation on bulk write operations. Mongoose currently runs validation on `insertOne` and `replaceOne` operations by default.\n * @param {Boolean} [options.bypassDocumentValidation=false] If true, disable [MongoDB server-side schema validation](https://www.mongodb.com/docs/manual/core/schema-validation/) for all writes in this bulk.\n * @param {Boolean} [options.strict=null] Overwrites the [`strict` option](https://mongoosejs.com/docs/guide.html#strict) on schema. If false, allows filtering and writing fields not defined in the schema for all writes in this bulk.\n * @return {Promise} resolves to a [`BulkWriteOpResult`](https://mongodb.github.io/node-mongodb-native/4.9/classes/BulkWriteResult.html) if the operation succeeds\n * @api public\n */\n\nModel.bulkWrite = async function bulkWrite(ops, options) {\n  _checkContext(this, 'bulkWrite');\n  if (typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.bulkWrite() no longer accepts a callback');\n  }\n  options = options || {};\n  const ordered = options.ordered == null ? true : options.ordered;\n  const validations = ops.map(op => castBulkWrite(this, op, options));\n  return new Promise((resolve, reject) => {\n    if (ordered) {\n      each(validations, (fn, cb) => fn(cb), error => {\n        if (error) {\n          return reject(error);\n        }\n        if (ops.length === 0) {\n          return resolve(getDefaultBulkwriteResult());\n        }\n        try {\n          this.$__collection.bulkWrite(ops, options, (error, res) => {\n            if (error) {\n              return reject(error);\n            }\n            resolve(res);\n          });\n        } catch (err) {\n          return reject(err);\n        }\n      });\n      return;\n    }\n    let remaining = validations.length;\n    let validOps = [];\n    let validationErrors = [];\n    for (let i = 0; i < validations.length; ++i) {\n      validations[i](err => {\n        if (err == null) {\n          validOps.push(i);\n        } else {\n          validationErrors.push({\n            index: i,\n            error: err\n          });\n        }\n        if (--remaining <= 0) {\n          completeUnorderedValidation.call(this);\n        }\n      });\n    }\n    validationErrors = validationErrors.sort((v1, v2) => v1.index - v2.index).map(v => v.error);\n    function completeUnorderedValidation() {\n      validOps = validOps.sort().map(index => ops[index]);\n      this.$__collection.bulkWrite(validOps, options, (error, res) => {\n        if (error) {\n          if (validationErrors.length > 0) {\n            error.mongoose = error.mongoose || {};\n            error.mongoose.validationErrors = validationErrors;\n          }\n          return reject(error);\n        }\n        if (validationErrors.length > 0) {\n          res.mongoose = res.mongoose || {};\n          res.mongoose.validationErrors = validationErrors;\n        }\n        resolve(res);\n      });\n    }\n  });\n};\n\n/**\n *  takes an array of documents, gets the changes and inserts/updates documents in the database\n *  according to whether or not the document is new, or whether it has changes or not.\n *\n * `bulkSave` uses `bulkWrite` under the hood, so it's mostly useful when dealing with many documents (10K+)\n *\n * @param {Array<Document>} documents\n * @param {Object} [options] options passed to the underlying `bulkWrite()`\n * @param {Boolean} [options.timestamps] defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n *\n */\nModel.bulkSave = async function (documents, options) {\n  options = options || {};\n  const writeOperations = this.buildBulkWriteOperations(documents, {\n    skipValidation: true,\n    timestamps: options.timestamps\n  });\n  if (options.timestamps != null) {\n    for (const document of documents) {\n      document.$__.saveOptions = document.$__.saveOptions || {};\n      document.$__.saveOptions.timestamps = options.timestamps;\n    }\n  } else {\n    for (const document of documents) {\n      if (document.$__.timestamps != null) {\n        document.$__.saveOptions = document.$__.saveOptions || {};\n        document.$__.saveOptions.timestamps = document.$__.timestamps;\n      }\n    }\n  }\n  await Promise.all(documents.map(buildPreSavePromise));\n  const {\n    bulkWriteResult,\n    bulkWriteError\n  } = await this.bulkWrite(writeOperations, options).then(res => ({\n    bulkWriteResult: res,\n    bulkWriteError: null\n  }), err => ({\n    bulkWriteResult: null,\n    bulkWriteError: err\n  }));\n  await Promise.all(documents.map(async document => {\n    const documentError = bulkWriteError && bulkWriteError.writeErrors.find(writeError => {\n      const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;\n      return writeErrorDocumentId.toString() === document._id.toString();\n    });\n    if (documentError == null) {\n      await handleSuccessfulWrite(document);\n    }\n  }));\n  if (bulkWriteError && bulkWriteError.writeErrors && bulkWriteError.writeErrors.length) {\n    throw bulkWriteError;\n  }\n  return bulkWriteResult;\n};\nfunction buildPreSavePromise(document) {\n  return new Promise((resolve, reject) => {\n    document.schema.s.hooks.execPre('save', document, err => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve();\n    });\n  });\n}\nfunction handleSuccessfulWrite(document) {\n  return new Promise((resolve, reject) => {\n    if (document.$isNew) {\n      _setIsNew(document, false);\n    }\n    document.$__reset();\n    document.schema.s.hooks.execPost('save', document, [document], {}, err => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve();\n    });\n  });\n}\n\n/**\n * Apply defaults to the given document or POJO.\n *\n * @param {Object|Document} obj object or document to apply defaults on\n * @returns {Object|Document}\n * @api public\n */\n\nModel.applyDefaults = function applyDefaults(doc) {\n  if (doc.$__ != null) {\n    applyDefaultsHelper(doc, doc.$__.fields, doc.$__.exclude);\n    for (const subdoc of doc.$getAllSubdocs()) {\n      applyDefaults(subdoc, subdoc.$__.fields, subdoc.$__.exclude);\n    }\n    return doc;\n  }\n  applyDefaultsToPOJO(doc, this.schema);\n  return doc;\n};\n\n/**\n * Cast the given POJO to the model's schema\n *\n * #### Example:\n *\n *     const Test = mongoose.model('Test', Schema({ num: Number }));\n *\n *     const obj = Test.castObject({ num: '42' });\n *     obj.num; // 42 as a number\n *\n *     Test.castObject({ num: 'not a number' }); // Throws a ValidationError\n *\n * @param {Object} obj object or document to cast\n * @param {Object} options options passed to castObject\n * @param {Boolean} options.ignoreCastErrors If set to `true` will not throw a ValidationError and only return values that were successfully cast.\n * @returns {Object} POJO casted to the model's schema\n * @throws {ValidationError} if casting failed for at least one path\n * @api public\n */\n\nModel.castObject = function castObject(obj, options) {\n  options = options || {};\n  const ret = {};\n  const schema = this.schema;\n  const paths = Object.keys(schema.paths);\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType || !schemaType.$isMongooseArray) {\n      continue;\n    }\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n  let error = null;\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (schemaType == null) {\n      continue;\n    }\n    let val = get(obj, path, void 0);\n    if (val == null) {\n      continue;\n    }\n    const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = ret;\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      if (cur[pieces[i]] == null) {\n        cur[pieces[i]] = isNaN(pieces[i + 1]) ? {} : [];\n      }\n      cur = cur[pieces[i]];\n    }\n    if (schemaType.$isMongooseDocumentArray) {\n      continue;\n    }\n    if (schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) {\n      try {\n        val = Model.castObject.call(schemaType.caster, val);\n      } catch (err) {\n        if (!options.ignoreCastErrors) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n        }\n        continue;\n      }\n      cur[pieces[pieces.length - 1]] = val;\n      continue;\n    }\n    try {\n      val = schemaType.cast(val);\n      cur[pieces[pieces.length - 1]] = val;\n    } catch (err) {\n      if (!options.ignoreCastErrors) {\n        error = error || new ValidationError();\n        error.addError(path, err);\n      }\n      continue;\n    }\n  }\n  if (error != null) {\n    throw error;\n  }\n  return ret;\n};\n\n/**\n * Build bulk write operations for `bulkSave()`.\n *\n * @param {Array<Document>} documents The array of documents to build write operations of\n * @param {Object} options\n * @param {Boolean} options.skipValidation defaults to `false`, when set to true, building the write operations will bypass validating the documents.\n * @param {Boolean} options.timestamps defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @return {Array<Promise>} Returns a array of all Promises the function executes to be awaited.\n * @api private\n */\n\nModel.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {\n  if (!Array.isArray(documents)) {\n    throw new Error(`bulkSave expects an array of documents to be passed, received \\`${documents}\\` instead`);\n  }\n  setDefaultOptions();\n  const writeOperations = documents.reduce((accumulator, document, i) => {\n    if (!options.skipValidation) {\n      if (!(document instanceof Document)) {\n        throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);\n      }\n      const validationError = document.validateSync();\n      if (validationError) {\n        throw validationError;\n      }\n    }\n    const isANewDocument = document.isNew;\n    if (isANewDocument) {\n      const writeOperation = {\n        insertOne: {\n          document\n        }\n      };\n      utils.injectTimestampsOption(writeOperation.insertOne, options.timestamps);\n      accumulator.push(writeOperation);\n      return accumulator;\n    }\n    const delta = document.$__delta();\n    const isDocumentWithChanges = delta != null && !utils.isEmptyObject(delta[0]);\n    if (isDocumentWithChanges) {\n      const where = document.$__where(delta[0]);\n      const changes = delta[1];\n      _applyCustomWhere(document, where);\n      document.$__version(where, delta);\n      const writeOperation = {\n        updateOne: {\n          filter: where,\n          update: changes\n        }\n      };\n      utils.injectTimestampsOption(writeOperation.updateOne, options.timestamps);\n      accumulator.push(writeOperation);\n      return accumulator;\n    }\n    return accumulator;\n  }, []);\n  return writeOperations;\n  function setDefaultOptions() {\n    options = options || {};\n    if (options.skipValidation == null) {\n      options.skipValidation = false;\n    }\n  }\n};\n\n/**\n * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.\n * The document returned has no paths marked as modified initially.\n *\n * #### Example:\n *\n *     // hydrate previous data into a Mongoose document\n *     const mongooseCandy = Candy.hydrate({ _id: '54108337212ffb6d459f854c', type: 'jelly bean' });\n *\n * @param {Object} obj\n * @param {Object|String|String[]} [projection] optional projection containing which fields should be selected for this document\n * @param {Object} [options] optional options\n * @param {Boolean} [options.setters=false] if true, apply schema setters when hydrating\n * @return {Document} document instance\n * @api public\n */\n\nModel.hydrate = function (obj, projection, options) {\n  _checkContext(this, 'hydrate');\n  if (projection != null) {\n    if (obj != null && obj.$__ != null) {\n      obj = obj.toObject(internalToObjectOptions);\n    }\n    obj = applyProjection(obj, projection);\n  }\n  const document = require('./queryhelpers').createModel(this, obj, projection);\n  document.$init(obj, options);\n  return document;\n};\n\n/**\n * Same as `updateOne()`, except MongoDB will update _all_ documents that match\n * `filter` (as opposed to just the first one) regardless of the value of\n * the `multi` option.\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `updateMany()`\n *\n * @param {Object} filter\n * @param {Object|Array} update\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateMany = function updateMany(conditions, doc, options) {\n  _checkContext(this, 'updateMany');\n  return _update(this, 'updateMany', conditions, doc, options);\n};\n\n/**\n * Update _only_ the first document that matches `filter`.\n *\n * - Use `replaceOne()` if you want to overwrite an entire document rather than using atomic operators like `$set`.\n *\n * #### Example:\n *\n *     const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `updateOne()`\n *\n * @param {Object} filter\n * @param {Object|Array} update\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateOne = function updateOne(conditions, doc, options) {\n  _checkContext(this, 'updateOne');\n  return _update(this, 'updateOne', conditions, doc, options);\n};\n\n/**\n * Replace the existing document with the given document (no atomic operators like `$set`).\n *\n * #### Example:\n *\n *     const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `replaceOne()`\n *\n * @param {Object} filter\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @return {Query}\n * @api public\n */\n\nModel.replaceOne = function replaceOne(conditions, doc, options) {\n  _checkContext(this, 'replaceOne');\n  const versionKey = this && this.schema && this.schema.options && this.schema.options.versionKey || null;\n  if (versionKey && !doc[versionKey]) {\n    doc[versionKey] = 0;\n  }\n  return _update(this, 'replaceOne', conditions, doc, options);\n};\n\n/**\n * Common code for `updateOne()`, `updateMany()`, `replaceOne()`, and `update()`\n * because they need to do the same thing\n * @api private\n */\n\nfunction _update(model, op, conditions, doc, options) {\n  const mq = new model.Query({}, {}, model, model.collection);\n\n  // gh-2406\n  // make local deep copy of conditions\n  if (conditions instanceof Document) {\n    conditions = conditions.toObject();\n  } else {\n    conditions = clone(conditions);\n  }\n  options = typeof options === 'function' ? options : clone(options);\n  const versionKey = model && model.schema && model.schema.options && model.schema.options.versionKey || null;\n  _decorateUpdateWithVersionKey(doc, options, versionKey);\n  return mq[op](conditions, doc, options);\n}\n\n/**\n * Performs [aggregations](https://www.mongodb.com/docs/manual/aggregation/) on the models collection.\n *\n * If a `callback` is passed, the `aggregate` is executed and a `Promise` is returned. If a callback is not passed, the `aggregate` itself is returned.\n *\n * This function triggers the following middleware.\n *\n * - `aggregate()`\n *\n * #### Example:\n *\n *     // Find the max balance of all accounts\n *     const res = await Users.aggregate([\n *       { $group: { _id: null, maxBalance: { $max: '$balance' }}},\n *       { $project: { _id: 0, maxBalance: 1 }}\n *     ]);\n *\n *     console.log(res); // [ { maxBalance: 98000 } ]\n *\n *     // Or use the aggregation pipeline builder.\n *     const res = await Users.aggregate().\n *       group({ _id: null, maxBalance: { $max: '$balance' } }).\n *       project('-id maxBalance').\n *       exec();\n *     console.log(res); // [ { maxBalance: 98 } ]\n *\n * #### Note:\n *\n * - Mongoose does **not** cast aggregation pipelines to the model's schema because `$project` and `$group` operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format. You can use the [mongoose-cast-aggregation plugin](https://github.com/AbdelrahmanHafez/mongoose-cast-aggregation) to enable minimal casting for aggregation pipelines.\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n *\n * #### More About Aggregations:\n *\n * - [Mongoose `Aggregate`](https://mongoosejs.com/docs/api/aggregate.html)\n * - [An Introduction to Mongoose Aggregate](https://masteringjs.io/tutorials/mongoose/aggregate)\n * - [MongoDB Aggregation docs](https://www.mongodb.com/docs/manual/applications/aggregation/)\n *\n * @see Aggregate https://mongoosejs.com/docs/api/aggregate.html#Aggregate()\n * @see MongoDB https://www.mongodb.com/docs/manual/applications/aggregation/\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @param {Object} [options] aggregation options\n * @return {Aggregate}\n * @api public\n */\n\nModel.aggregate = function aggregate(pipeline, options) {\n  _checkContext(this, 'aggregate');\n  if (typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.aggregate() no longer accepts a callback');\n  }\n  const aggregate = new Aggregate(pipeline || []);\n  aggregate.model(this);\n  if (options != null) {\n    aggregate.option(options);\n  }\n  if (typeof callback === 'undefined') {\n    return aggregate;\n  }\n  return aggregate;\n};\n\n/**\n * Casts and validates the given object against this model's schema, passing the\n * given `context` to custom validators.\n *\n * #### Example:\n *\n *     const Model = mongoose.model('Test', Schema({\n *       name: { type: String, required: true },\n *       age: { type: Number, required: true }\n *     });\n *\n *     try {\n *       await Model.validate({ name: null }, ['name'])\n *     } catch (err) {\n *       err instanceof mongoose.Error.ValidationError; // true\n *       Object.keys(err.errors); // ['name']\n *     }\n *\n * @param {Object} obj\n * @param {Array|String} pathsToValidate\n * @param {Object} [context]\n * @return {Promise|undefined}\n * @api public\n */\n\nModel.validate = async function validate(obj, pathsToValidate, context) {\n  if (arguments.length < 3 || arguments.length === 3 && typeof arguments[2] === 'function') {\n    // For convenience, if we're validating a document or an object, make `context` default to\n    // the model so users don't have to always pass `context`, re: gh-10132, gh-10346\n    context = obj;\n  }\n  if (typeof context === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.validate() no longer accepts a callback');\n  }\n  let schema = this.schema;\n  const discriminatorKey = schema.options.discriminatorKey;\n  if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;\n  }\n  let paths = Object.keys(schema.paths);\n  if (pathsToValidate != null) {\n    const _pathsToValidate = typeof pathsToValidate === 'string' ? new Set(pathsToValidate.split(' ')) : new Set(pathsToValidate);\n    paths = paths.filter(p => {\n      const pieces = p.split('.');\n      let cur = pieces[0];\n      for (const piece of pieces) {\n        if (_pathsToValidate.has(cur)) {\n          return true;\n        }\n        cur += '.' + piece;\n      }\n      return _pathsToValidate.has(p);\n    });\n  }\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType || !schemaType.$isMongooseArray || schemaType.$isMongooseDocumentArray) {\n      continue;\n    }\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n  let remaining = paths.length;\n  let error = null;\n  return new Promise((resolve, reject) => {\n    for (const path of paths) {\n      const schemaType = schema.path(path);\n      if (schemaType == null) {\n        _checkDone();\n        continue;\n      }\n      const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n      let cur = obj;\n      for (let i = 0; i < pieces.length - 1; ++i) {\n        cur = cur[pieces[i]];\n      }\n      let val = get(obj, path, void 0);\n      if (val != null) {\n        try {\n          val = schemaType.cast(val);\n          cur[pieces[pieces.length - 1]] = val;\n        } catch (err) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n          _checkDone();\n          continue;\n        }\n      }\n      schemaType.doValidate(val, err => {\n        if (err) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n        }\n        _checkDone();\n      }, context, {\n        path: path\n      });\n    }\n    function _checkDone() {\n      if (--remaining <= 0) {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      }\n    }\n  });\n};\n\n/**\n * Populates document references.\n *\n * Changed in Mongoose 6: the model you call `populate()` on should be the\n * \"local field\" model, **not** the \"foreign field\" model.\n *\n * #### Available top-level options:\n *\n * - path: space delimited path(s) to populate\n * - select: optional fields to select\n * - match: optional query conditions to match\n * - model: optional name of the model to use for population\n * - options: optional query options like sort, limit, etc\n * - justOne: optional boolean, if true Mongoose will always set `path` to a document, or `null` if no document was found. If false, Mongoose will always set `path` to an array, which will be empty if no documents are found. Inferred from schema by default.\n * - strictPopulate: optional boolean, set to `false` to allow populating paths that aren't in the schema.\n *\n * #### Example:\n *\n *     const Dog = mongoose.model('Dog', new Schema({ name: String, breed: String }));\n *     const Person = mongoose.model('Person', new Schema({\n *       name: String,\n *       pet: { type: mongoose.ObjectId, ref: 'Dog' }\n *     }));\n *\n *     const pets = await Pet.create([\n *       { name: 'Daisy', breed: 'Beagle' },\n *       { name: 'Einstein', breed: 'Catalan Sheepdog' }\n *     ]);\n *\n *     // populate many plain objects\n *     const users = [\n *       { name: 'John Wick', dog: pets[0]._id },\n *       { name: 'Doc Brown', dog: pets[1]._id }\n *     ];\n *     await User.populate(users, { path: 'dog', select: 'name' });\n *     users[0].dog.name; // 'Daisy'\n *     users[0].dog.breed; // undefined because of `select`\n *\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object|String} options Either the paths to populate or an object specifying all parameters\n * @param {string} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](https://mongoosejs.com/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] By default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] If true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Boolean} [options.skipInvalidIds=false] By default, Mongoose throws a cast error if `localField` and `foreignField` schemas don't line up. If you enable this option, Mongoose will instead filter out any `localField` properties that cannot be casted to `foreignField`'s schema type.\n * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\n * @param {Boolean} [options.strictPopulate=true] Set to false to allow populating paths that aren't defined in the given model's schema.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Function} [callback(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n * @return {Promise}\n * @api public\n */\n\nModel.populate = async function populate(docs, paths) {\n  _checkContext(this, 'populate');\n  if (typeof paths === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.populate() no longer accepts a callback');\n  }\n  const _this = this;\n\n  // normalized paths\n  paths = utils.populate(paths);\n  // data that should persist across subPopulate calls\n  const cache = {};\n  return new Promise((resolve, reject) => {\n    _populate(_this, docs, paths, cache, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Populate helper\n *\n * @param {Model} model the model to use\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object} paths\n * @param {never} cache Unused\n * @param {Function} [callback] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n * @return {Function}\n * @api private\n */\n\nfunction _populate(model, docs, paths, cache, callback) {\n  let pending = paths.length;\n  if (paths.length === 0) {\n    return callback(null, docs);\n  }\n  // each path has its own query options and must be executed separately\n  for (const path of paths) {\n    populate(model, docs, path, next);\n  }\n  function next(err) {\n    if (err) {\n      return callback(err, null);\n    }\n    if (--pending) {\n      return;\n    }\n    callback(null, docs);\n  }\n}\n\n/*!\n * Populates `docs`\n */\nconst excludeIdReg = /\\s?-_id\\s?/;\nconst excludeIdRegGlobal = /\\s?-_id\\s?/g;\nfunction populate(model, docs, options, callback) {\n  const populateOptions = {\n    ...options\n  };\n  if (options.strictPopulate == null) {\n    if (options._localModel != null && options._localModel.schema._userProvidedOptions.strictPopulate != null) {\n      populateOptions.strictPopulate = options._localModel.schema._userProvidedOptions.strictPopulate;\n    } else if (options._localModel != null && model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    } else if (model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    }\n  }\n\n  // normalize single / multiple docs passed\n  if (!Array.isArray(docs)) {\n    docs = [docs];\n  }\n  if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {\n    return callback();\n  }\n  const modelsMap = getModelsMapForPopulate(model, docs, populateOptions);\n  if (modelsMap instanceof MongooseError) {\n    return immediate(function () {\n      callback(modelsMap);\n    });\n  }\n  const len = modelsMap.length;\n  let vals = [];\n  function flatten(item) {\n    // no need to include undefined values in our query\n    return undefined !== item;\n  }\n  let _remaining = len;\n  let hasOne = false;\n  const params = [];\n  for (let i = 0; i < len; ++i) {\n    const mod = modelsMap[i];\n    let select = mod.options.select;\n    let ids = utils.array.flatten(mod.ids, flatten);\n    ids = utils.array.unique(ids);\n    const assignmentOpts = {};\n    assignmentOpts.sort = mod && mod.options && mod.options.options && mod.options.options.sort || void 0;\n    assignmentOpts.excludeId = excludeIdReg.test(select) || select && select._id === 0;\n\n    // Lean transform may delete `_id`, which would cause assignment\n    // to fail. So delay running lean transform until _after_\n    // `_assign()`\n    if (mod.options && mod.options.options && mod.options.options.lean && mod.options.options.lean.transform) {\n      mod.options.options._leanTransform = mod.options.options.lean.transform;\n      mod.options.options.lean = true;\n    }\n    if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {\n      // Ensure that we set to 0 or empty array even\n      // if we don't actually execute a query to make sure there's a value\n      // and we know this path was populated for future sets. See gh-7731, gh-8230\n      --_remaining;\n      _assign(model, [], mod, assignmentOpts);\n      continue;\n    }\n    hasOne = true;\n    if (typeof populateOptions.foreignField === 'string') {\n      mod.foreignField.clear();\n      mod.foreignField.add(populateOptions.foreignField);\n    }\n    const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);\n    if (assignmentOpts.excludeId) {\n      // override the exclusion from the query so we can use the _id\n      // for document matching during assignment. we'll delete the\n      // _id back off before returning the result.\n      if (typeof select === 'string') {\n        select = select.replace(excludeIdRegGlobal, ' ');\n      } else {\n        // preserve original select conditions by copying\n        select = utils.object.shallowCopy(select);\n        delete select._id;\n      }\n    }\n    if (mod.options.options && mod.options.options.limit != null) {\n      assignmentOpts.originalLimit = mod.options.options.limit;\n    } else if (mod.options.limit != null) {\n      assignmentOpts.originalLimit = mod.options.limit;\n    }\n    params.push([mod, match, select, assignmentOpts, _next]);\n  }\n  if (!hasOne) {\n    // If models but no docs, skip further deep populate.\n    if (modelsMap.length !== 0) {\n      return callback();\n    }\n    // If no models to populate but we have a nested populate,\n    // keep trying, re: gh-8946\n    if (populateOptions.populate != null) {\n      const opts = utils.populate(populateOptions.populate).map(pop => Object.assign({}, pop, {\n        path: populateOptions.path + '.' + pop.path\n      }));\n      model.populate(docs, opts).then(res => {\n        callback(null, res);\n      }, err => {\n        callback(err);\n      });\n      return;\n    }\n    return callback();\n  }\n  for (const arr of params) {\n    _execPopulateQuery.apply(null, arr);\n  }\n  function _next(err, valsFromDb) {\n    if (err != null) {\n      return callback(err, null);\n    }\n    vals = vals.concat(valsFromDb);\n    if (--_remaining === 0) {\n      _done();\n    }\n  }\n  function _done() {\n    for (const arr of params) {\n      const mod = arr[0];\n      const assignmentOpts = arr[3];\n      for (const val of vals) {\n        mod.options._childDocs.push(val);\n      }\n      try {\n        _assign(model, vals, mod, assignmentOpts);\n      } catch (err) {\n        return callback(err);\n      }\n    }\n    for (const arr of params) {\n      removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);\n    }\n    for (const arr of params) {\n      const mod = arr[0];\n      if (mod.options && mod.options.options && mod.options.options._leanTransform) {\n        for (const doc of vals) {\n          mod.options.options._leanTransform(doc);\n        }\n      }\n    }\n    callback();\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _execPopulateQuery(mod, match, select, assignmentOpts, callback) {\n  let subPopulate = clone(mod.options.populate);\n  const queryOptions = Object.assign({\n    skip: mod.options.skip,\n    limit: mod.options.limit,\n    perDocumentLimit: mod.options.perDocumentLimit\n  }, mod.options.options);\n  if (mod.count) {\n    delete queryOptions.skip;\n  }\n  if (queryOptions.perDocumentLimit != null) {\n    queryOptions.limit = queryOptions.perDocumentLimit;\n    delete queryOptions.perDocumentLimit;\n  } else if (queryOptions.limit != null) {\n    queryOptions.limit = queryOptions.limit * mod.ids.length;\n  }\n  const query = mod.model.find(match, select, queryOptions);\n  // If we're doing virtual populate and projection is inclusive and foreign\n  // field is not selected, automatically select it because mongoose needs it.\n  // If projection is exclusive and client explicitly unselected the foreign\n  // field, that's the client's fault.\n  for (const foreignField of mod.foreignField) {\n    if (foreignField !== '_id' && query.selectedInclusively() && !isPathSelectedInclusive(query._fields, foreignField)) {\n      query.select(foreignField);\n    }\n  }\n\n  // If using count, still need the `foreignField` so we can match counts\n  // to documents, otherwise we would need a separate `count()` for every doc.\n  if (mod.count) {\n    for (const foreignField of mod.foreignField) {\n      query.select(foreignField);\n    }\n  }\n\n  // If we need to sub-populate, call populate recursively\n  if (subPopulate) {\n    // If subpopulating on a discriminator, skip check for non-existent\n    // paths. Because the discriminator may not have the path defined.\n    if (mod.model.baseModelName != null) {\n      if (Array.isArray(subPopulate)) {\n        subPopulate.forEach(pop => {\n          pop.strictPopulate = false;\n        });\n      } else if (typeof subPopulate === 'string') {\n        subPopulate = {\n          path: subPopulate,\n          strictPopulate: false\n        };\n      } else {\n        subPopulate.strictPopulate = false;\n      }\n    }\n    const basePath = mod.options._fullPath || mod.options.path;\n    if (Array.isArray(subPopulate)) {\n      for (const pop of subPopulate) {\n        pop._fullPath = basePath + '.' + pop.path;\n      }\n    } else if (typeof subPopulate === 'object') {\n      subPopulate._fullPath = basePath + '.' + subPopulate.path;\n    }\n    query.populate(subPopulate);\n  }\n  query.exec().then(docs => {\n    for (const val of docs) {\n      leanPopulateMap.set(val, mod.model);\n    }\n    callback(null, docs);\n  }, err => {\n    callback(err);\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _assign(model, vals, mod, assignmentOpts) {\n  const options = mod.options;\n  const isVirtual = mod.isVirtual;\n  const justOne = mod.justOne;\n  let _val;\n  const lean = options && options.options && options.options.lean || false;\n  const len = vals.length;\n  const rawOrder = {};\n  const rawDocs = {};\n  let key;\n  let val;\n\n  // Clone because `assignRawDocsToIdStructure` will mutate the array\n  const allIds = clone(mod.allIds);\n  // optimization:\n  // record the document positions as returned by\n  // the query result.\n  for (let i = 0; i < len; i++) {\n    val = vals[i];\n    if (val == null) {\n      continue;\n    }\n    for (const foreignField of mod.foreignField) {\n      _val = utils.getValue(foreignField, val);\n      if (Array.isArray(_val)) {\n        _val = utils.array.unique(utils.array.flatten(_val));\n        for (let __val of _val) {\n          if (__val instanceof Document) {\n            __val = __val._id;\n          }\n          key = String(__val);\n          if (rawDocs[key]) {\n            if (Array.isArray(rawDocs[key])) {\n              rawDocs[key].push(val);\n              rawOrder[key].push(i);\n            } else {\n              rawDocs[key] = [rawDocs[key], val];\n              rawOrder[key] = [rawOrder[key], i];\n            }\n          } else {\n            if (isVirtual && !justOne) {\n              rawDocs[key] = [val];\n              rawOrder[key] = [i];\n            } else {\n              rawDocs[key] = val;\n              rawOrder[key] = i;\n            }\n          }\n        }\n      } else {\n        if (_val instanceof Document) {\n          _val = _val._id;\n        }\n        key = String(_val);\n        if (rawDocs[key]) {\n          if (Array.isArray(rawDocs[key])) {\n            rawDocs[key].push(val);\n            rawOrder[key].push(i);\n          } else if (isVirtual || rawDocs[key].constructor !== val.constructor || String(rawDocs[key]._id) !== String(val._id)) {\n            // May need to store multiple docs with the same id if there's multiple models\n            // if we have discriminators or a ref function. But avoid converting to an array\n            // if we have multiple queries on the same model because of `perDocumentLimit` re: gh-9906\n            rawDocs[key] = [rawDocs[key], val];\n            rawOrder[key] = [rawOrder[key], i];\n          }\n        } else {\n          rawDocs[key] = val;\n          rawOrder[key] = i;\n        }\n      }\n      // flag each as result of population\n      if (!lean) {\n        val.$__.wasPopulated = val.$__.wasPopulated || true;\n      }\n    }\n  }\n  assignVals({\n    originalModel: model,\n    // If virtual, make sure to not mutate original field\n    rawIds: mod.isVirtual ? allIds : mod.allIds,\n    allIds: allIds,\n    unpopulatedValues: mod.unpopulatedValues,\n    foreignField: mod.foreignField,\n    rawDocs: rawDocs,\n    rawOrder: rawOrder,\n    docs: mod.docs,\n    path: options.path,\n    options: assignmentOpts,\n    justOne: mod.justOne,\n    isVirtual: mod.isVirtual,\n    allOptions: mod,\n    populatedModel: mod.model,\n    lean: lean,\n    virtual: mod.virtual,\n    count: mod.count,\n    match: mod.match\n  });\n}\n\n/**\n * Compiler utility.\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} schema\n * @param {String} collectionName\n * @param {Connection} connection\n * @param {Mongoose} base mongoose instance\n * @api private\n */\n\nModel.compile = function compile(name, schema, collectionName, connection, base) {\n  const versioningEnabled = schema.options.versionKey !== false;\n  if (versioningEnabled && !schema.paths[schema.options.versionKey]) {\n    // add versioning to top level documents only\n    const o = {};\n    o[schema.options.versionKey] = Number;\n    schema.add(o);\n  }\n  let model;\n  if (typeof name === 'function' && name.prototype instanceof Model) {\n    model = name;\n    name = model.name;\n    schema.loadClass(model, false);\n    model.prototype.$isMongooseModelPrototype = true;\n  } else {\n    // generate new class\n    model = function model(doc, fields, skipId) {\n      model.hooks.execPreSync('createModel', doc);\n      if (!(this instanceof model)) {\n        return new model(doc, fields, skipId);\n      }\n      const discriminatorKey = model.schema.options.discriminatorKey;\n      if (model.discriminators == null || doc == null || doc[discriminatorKey] == null) {\n        Model.call(this, doc, fields, skipId);\n        return;\n      }\n\n      // If discriminator key is set, use the discriminator instead (gh-7586)\n      const Discriminator = model.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      if (Discriminator != null) {\n        return new Discriminator(doc, fields, skipId);\n      }\n\n      // Otherwise, just use the top-level model\n      Model.call(this, doc, fields, skipId);\n    };\n  }\n  model.hooks = schema.s.hooks.clone();\n  model.base = base;\n  model.modelName = name;\n  if (!(model.prototype instanceof Model)) {\n    Object.setPrototypeOf(model, Model);\n    Object.setPrototypeOf(model.prototype, Model.prototype);\n  }\n  model.model = function model(name) {\n    return this.db.model(name);\n  };\n  model.db = connection;\n  model.prototype.db = connection;\n  model.prototype[modelDbSymbol] = connection;\n  model.discriminators = model.prototype.discriminators = undefined;\n  model[modelSymbol] = true;\n  model.events = new EventEmitter();\n  schema._preCompile();\n  model.prototype.$__setSchema(schema);\n  const _userProvidedOptions = schema._userProvidedOptions || {};\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: schema.options.capped,\n    Promise: model.base.Promise,\n    modelName: name\n  };\n  if (schema.options.autoCreate !== void 0) {\n    collectionOptions.autoCreate = schema.options.autoCreate;\n  }\n  model.prototype.collection = connection.collection(collectionName, collectionOptions);\n  model.prototype.$collection = model.prototype.collection;\n  model.prototype[modelCollectionSymbol] = model.prototype.collection;\n\n  // apply methods and statics\n  applyMethods(model, schema);\n  applyStatics(model, schema);\n  applyHooks(model, schema);\n  applyStaticHooks(model, schema.s.hooks, schema.statics);\n  model.schema = model.prototype.$__schema;\n  model.collection = model.prototype.collection;\n  model.$__collection = model.collection;\n\n  // Create custom query constructor\n  model.Query = function () {\n    Query.apply(this, arguments);\n  };\n  Object.setPrototypeOf(model.Query.prototype, Query.prototype);\n  model.Query.base = Query.base;\n  model.Query.prototype.constructor = Query;\n  applyQueryMiddleware(model.Query, model);\n  applyQueryMethods(model, schema.query);\n  return model;\n};\n\n/**\n * Register custom query methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\n\nfunction applyQueryMethods(model, methods) {\n  for (const i in methods) {\n    model.Query.prototype[i] = methods[i];\n  }\n}\n\n/**\n * Subclass this model with `conn`, `schema`, and `collection` settings.\n *\n * @param {Connection} conn\n * @param {Schema} [schema]\n * @param {String} [collection]\n * @return {Model}\n * @api private\n * @memberOf Model\n * @static\n * @method __subclass\n */\n\nModel.__subclass = function subclass(conn, schema, collection) {\n  // subclass model using this connection and collection name\n  const _this = this;\n  const Model = function Model(doc, fields, skipId) {\n    if (!(this instanceof Model)) {\n      return new Model(doc, fields, skipId);\n    }\n    _this.call(this, doc, fields, skipId);\n  };\n  Object.setPrototypeOf(Model, _this);\n  Object.setPrototypeOf(Model.prototype, _this.prototype);\n  Model.db = conn;\n  Model.prototype.db = conn;\n  Model.prototype[modelDbSymbol] = conn;\n  _this[subclassedSymbol] = _this[subclassedSymbol] || [];\n  _this[subclassedSymbol].push(Model);\n  if (_this.discriminators != null) {\n    Model.discriminators = {};\n    for (const key of Object.keys(_this.discriminators)) {\n      Model.discriminators[key] = _this.discriminators[key].__subclass(_this.db, _this.discriminators[key].schema, collection);\n    }\n  }\n  const s = schema && typeof schema !== 'string' ? schema : _this.prototype.$__schema;\n  const options = s.options || {};\n  const _userProvidedOptions = s._userProvidedOptions || {};\n  if (!collection) {\n    collection = _this.prototype.$__schema.get('collection') || utils.toCollectionName(_this.modelName, this.base.pluralize());\n  }\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: s && options.capped\n  };\n  Model.prototype.collection = conn.collection(collection, collectionOptions);\n  Model.prototype.$collection = Model.prototype.collection;\n  Model.prototype[modelCollectionSymbol] = Model.prototype.collection;\n  Model.collection = Model.prototype.collection;\n  Model.$__collection = Model.collection;\n  // Errors handled internally, so ignore\n  Model.init().catch(() => {});\n  return Model;\n};\n\n/**\n * Helper for console.log. Given a model named 'MyModel', returns the string\n * `'Model { MyModel }'`.\n *\n * #### Example:\n *\n *     const MyModel = mongoose.model('Test', Schema({ name: String }));\n *     MyModel.inspect(); // 'Model { Test }'\n *     console.log(MyModel); // Prints 'Model { Test }'\n *\n * @api public\n */\n\nModel.inspect = function () {\n  return `Model { ${this.modelName} }`;\n};\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Model[util.inspect.custom] = Model.inspect;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Model;","map":{"version":3,"names":["Aggregate","require","ChangeStream","Document","DocumentNotFoundError","DivergentArrayError","EventEmitter","MongooseBuffer","MongooseError","OverwriteModelError","Query","SaveOptions","Schema","ValidationError","VersionError","ParallelSaveError","applyDefaultsHelper","applyDefaultsToPOJO","applyQueryMiddleware","applyHooks","applyMethods","applyProjection","applySchemaCollation","applyStaticHooks","applyStatics","applyWriteConcern","assignVals","castBulkWrite","clone","createPopulateQueryFilter","getDefaultBulkwriteResult","getSchemaDiscriminatorByValue","discriminator","firstKey","each","get","getConstructorName","getDiscriminatorByValue","getModelsMapForPopulate","immediate","internalToObjectOptions","isDefaultIdIndex","isIndexEqual","getRelatedDBIndexes","getRelatedSchemaIndexes","isPathExcluded","decorateDiscriminatorIndexOptions","isPathSelectedInclusive","leanPopulateMap","modifiedPaths","parallelLimit","parentPaths","prepareDiscriminatorPipeline","pushNestedArrayPaths","removeDeselectedForeignField","setDottedPath","STATES","util","utils","VERSION_WHERE","VERSION_INC","VERSION_ALL","arrayAtomicsSymbol","modelCollectionSymbol","Symbol","modelDbSymbol","modelSymbol","subclassedSymbol","saveToObjectOptions","Object","assign","bson","Model","doc","fields","skipId","TypeError","call","setPrototypeOf","prototype","$isMongooseModelPrototype","db","collection","$__collection","modelName","$where","baseModelName","events","_middleware","_applyCustomWhere","where","key","keys","$__handleSave","options","callback","saveOptions","$__schema","writeConcern","w","j","wtimeout","checkKeys","session","$session","hasOwnProperty","$isNew","obj","toObject","_id","$__version","insertOne","then","ret","err","_setIsNew","$__reset","$__","inserting","delta","$__delta","$__where","updateOne","$__undoReset","optionsWithCustomValues","optimisticConcurrency","versionKey","val","$__getValue","constructor","findOne","documentExists","matchedCount","catch","$__save","error","result","hooks","s","execPost","numAffected","Array","isArray","length","versionBump","version","doIncrement","undefined","$versionError","$__setValue","saving","savedState","$emit","emit","generateVersionError","save","arguments","parallelSave","$op","timestamps","$__handleReject","Promise","resolve","reject","$save","shouldSkipVersioning","self","path","skipVersioning","replace","operand","data","op","test","increment","handleAtomics","value","$set","$__getAtomics","forEach","atomic","atomics","ops","i","isMongooseObject","depopulate","_isNested","valueOf","iter","mem","transform","map","$each","dirty","$__dirty","len","divergent","d","_doc","match","checkDivergentArray","push","pop","$populated","selected","pathSplit","split","top","$elemMatch","join","$isDefault","indexOf","pathsToCheck","find","isSelected","isMongooseArray","$path","pathSymbol","Buffer","isBuffer","primitiveAtomics","virtuals","getters","omitUndefined","array","check","object","skip","select","$pop","$__isSelected","$inc","_where","deleteOne","res","$__deleteOne","cb","isDeleted","model","name","$model","exists","filter","_checkContext","query","lean","setOptions","schema","getFunctionName","isPOJO","mergePlugins","isObject","instanceOfSchema","mergeHooks","models","overwriteModels","$isRootDiscriminator","$globalPluginsApplied","discriminators","defineProperty","configurable","writable","submodel","__subclass","ctx","fnName","global","init","$init","conn","_ensureIndexes","autoIndex","getOption","config","base","ensureIndexes","_automatic","_createCollection","readyState","connecting","disconnected","_shouldBufferCommands","_queue","fn","autoCreate","createCollection","_catch","_this","$caught","apply","schemaCollation","collation","capped","size","timeseries","expireAfterSeconds","expires","clusteredIndex","unique","collectionName","code","syncIndexes","diffIndexesResult","diffIndexes","dropped","cleanIndexes","toDrop","createIndexes","toCreate","dbIndexes","listIndexes","schemaIndexes","indexes","getIndexesToDrop","getIndexesToCreate","schemaIndexKeysObject","schemaIndexOptions","found","index","includes","dbIndex","_dropIndexes","all","indexName","dropIndex","buffer","addQueue","toArray","indexError","done","warn","indexSingleDone","indexSingleStart","baseSchema","_baseSchema","baseSchemaIndexes","create","shift","_autoIndex","deepEqual","indexFields","indexOptions","background","createIndex","translateAliases","translate","alias","translated","fieldKeys","currentSchema","aliases","paths","translatedKey","Map","set","delete","field","conditions","mq","deleteMany","projection","findById","id","estimatedDocumentCount","countDocuments","count","distinct","findOneAndUpdate","update","_decorateUpdateWithVersionKey","upsert","updatedPaths","overwrite","$setOnInsert","findByIdAndUpdate","findOneAndDelete","findByIdAndDelete","findOneAndReplace","replacement","findOneAndRemove","findByIdAndRemove","args","discriminatorKey","last","toSave","watch","pipeline","changeStreamThunk","closed","driverChangeStream","startSession","insertMany","arr","$__insertMany","noop","limit","rawResult","ordered","validationErrors","validationErrorsToOriginalOrder","results","toExecute","$validate","docs","originalDocIndex","validDocIndexToOriginalIndex","docAttributes","sort","err1","err2","acknowledged","insertedCount","insertedIds","mongoose","docObjects","shouldSetTimestamps","initializeTimestamps","attribute","populate","insertedDocs","writeErrors","erroredIndexes","Set","originalIndex","firstErroredIndex","isErrored","has","setIsNewForInsertedDoc","subdocs","$getAllSubdocs","subdoc","bulkWrite","validations","remaining","validOps","completeUnorderedValidation","v1","v2","v","bulkSave","documents","writeOperations","buildBulkWriteOperations","skipValidation","document","buildPreSavePromise","bulkWriteResult","bulkWriteError","documentError","writeError","writeErrorDocumentId","q","toString","handleSuccessfulWrite","execPre","applyDefaults","exclude","castObject","schemaType","$isMongooseArray","pieces","cur","isNaN","$isMongooseDocumentArray","$isSingleNested","$isMongooseDocumentArrayElement","caster","ignoreCastErrors","addError","cast","Error","setDefaultOptions","reduce","accumulator","validationError","validateSync","isANewDocument","isNew","writeOperation","injectTimestampsOption","isDocumentWithChanges","isEmptyObject","changes","hydrate","createModel","updateMany","_update","replaceOne","aggregate","option","validate","pathsToValidate","context","_pathsToValidate","p","piece","_checkDone","doValidate","cache","_populate","pending","next","excludeIdReg","excludeIdRegGlobal","populateOptions","strictPopulate","_localModel","_userProvidedOptions","every","isNullOrUndefined","modelsMap","vals","flatten","item","_remaining","hasOne","params","mod","ids","assignmentOpts","excludeId","_leanTransform","_assign","foreignField","clear","add","skipInvalidIds","shallowCopy","originalLimit","_next","opts","_execPopulateQuery","valsFromDb","concat","_done","_childDocs","subPopulate","queryOptions","perDocumentLimit","selectedInclusively","_fields","basePath","_fullPath","exec","isVirtual","justOne","_val","rawOrder","rawDocs","allIds","getValue","__val","String","wasPopulated","originalModel","rawIds","unpopulatedValues","allOptions","populatedModel","virtual","compile","connection","versioningEnabled","o","Number","loadClass","execPreSync","Discriminator","_preCompile","$__setSchema","collectionOptions","schemaUserProvidedOptions","$collection","statics","applyQueryMethods","methods","subclass","toCollectionName","pluralize","inspect","custom","module","exports"],"sources":["C:/Users/sama/Documents/fullpage/node_modules/mongoose/lib/model.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst Aggregate = require('./aggregate');\nconst ChangeStream = require('./cursor/ChangeStream');\nconst Document = require('./document');\nconst DocumentNotFoundError = require('./error/notFound');\nconst DivergentArrayError = require('./error/divergentArray');\nconst EventEmitter = require('events').EventEmitter;\nconst MongooseBuffer = require('./types/buffer');\nconst MongooseError = require('./error/index');\nconst OverwriteModelError = require('./error/overwriteModel');\nconst Query = require('./query');\nconst SaveOptions = require('./options/saveOptions');\nconst Schema = require('./schema');\nconst ValidationError = require('./error/validation');\nconst VersionError = require('./error/version');\nconst ParallelSaveError = require('./error/parallelSave');\nconst applyDefaultsHelper = require('./helpers/document/applyDefaults');\nconst applyDefaultsToPOJO = require('./helpers/model/applyDefaultsToPOJO');\nconst applyQueryMiddleware = require('./helpers/query/applyQueryMiddleware');\nconst applyHooks = require('./helpers/model/applyHooks');\nconst applyMethods = require('./helpers/model/applyMethods');\nconst applyProjection = require('./helpers/projection/applyProjection');\nconst applySchemaCollation = require('./helpers/indexes/applySchemaCollation');\nconst applyStaticHooks = require('./helpers/model/applyStaticHooks');\nconst applyStatics = require('./helpers/model/applyStatics');\nconst applyWriteConcern = require('./helpers/schema/applyWriteConcern');\nconst assignVals = require('./helpers/populate/assignVals');\nconst castBulkWrite = require('./helpers/model/castBulkWrite');\nconst clone = require('./helpers/clone');\nconst createPopulateQueryFilter = require('./helpers/populate/createPopulateQueryFilter');\nconst getDefaultBulkwriteResult = require('./helpers/getDefaultBulkwriteResult');\nconst getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');\nconst discriminator = require('./helpers/model/discriminator');\nconst firstKey = require('./helpers/firstKey');\nconst each = require('./helpers/each');\nconst get = require('./helpers/get');\nconst getConstructorName = require('./helpers/getConstructorName');\nconst getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');\nconst getModelsMapForPopulate = require('./helpers/populate/getModelsMapForPopulate');\nconst immediate = require('./helpers/immediate');\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\nconst isDefaultIdIndex = require('./helpers/indexes/isDefaultIdIndex');\nconst isIndexEqual = require('./helpers/indexes/isIndexEqual');\nconst {\n  getRelatedDBIndexes,\n  getRelatedSchemaIndexes\n} = require('./helpers/indexes/getRelatedIndexes');\nconst isPathExcluded = require('./helpers/projection/isPathExcluded');\nconst decorateDiscriminatorIndexOptions = require('./helpers/indexes/decorateDiscriminatorIndexOptions');\nconst isPathSelectedInclusive = require('./helpers/projection/isPathSelectedInclusive');\nconst leanPopulateMap = require('./helpers/populate/leanPopulateMap');\nconst modifiedPaths = require('./helpers/update/modifiedPaths');\nconst parallelLimit = require('./helpers/parallelLimit');\nconst parentPaths = require('./helpers/path/parentPaths');\nconst prepareDiscriminatorPipeline = require('./helpers/aggregate/prepareDiscriminatorPipeline');\nconst pushNestedArrayPaths = require('./helpers/model/pushNestedArrayPaths');\nconst removeDeselectedForeignField = require('./helpers/populate/removeDeselectedForeignField');\nconst setDottedPath = require('./helpers/path/setDottedPath');\nconst STATES = require('./connectionstate');\nconst util = require('util');\nconst utils = require('./utils');\n\nconst VERSION_WHERE = 1;\nconst VERSION_INC = 2;\nconst VERSION_ALL = VERSION_WHERE | VERSION_INC;\n\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\nconst modelCollectionSymbol = Symbol('mongoose#Model#collection');\nconst modelDbSymbol = Symbol('mongoose#Model#db');\nconst modelSymbol = require('./helpers/symbols').modelSymbol;\nconst subclassedSymbol = Symbol('mongoose#Model#subclassed');\n\nconst saveToObjectOptions = Object.assign({}, internalToObjectOptions, {\n  bson: true\n});\n\n/**\n * A Model is a class that's your primary tool for interacting with MongoDB.\n * An instance of a Model is called a [Document](https://mongoosejs.com/docs/api/document.html#Document).\n *\n * In Mongoose, the term \"Model\" refers to subclasses of the `mongoose.Model`\n * class. You should not use the `mongoose.Model` class directly. The\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) and\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()) functions\n * create subclasses of `mongoose.Model` as shown below.\n *\n * #### Example:\n *\n *     // `UserModel` is a \"Model\", a subclass of `mongoose.Model`.\n *     const UserModel = mongoose.model('User', new Schema({ name: String }));\n *\n *     // You can use a Model to create new documents using `new`:\n *     const userDoc = new UserModel({ name: 'Foo' });\n *     await userDoc.save();\n *\n *     // You also use a model to create queries:\n *     const userFromDb = await UserModel.findOne({ name: 'Foo' });\n *\n * @param {Object} doc values for initial set\n * @param {Object} [fields] optional object containing the fields that were selected in the query which returned this document. You do **not** need to set this parameter to ensure Mongoose handles your [query projection](https://mongoosejs.com/docs/api/query.html#Query.prototype.select()).\n * @param {Boolean} [skipId=false] optional boolean. If true, mongoose doesn't add an `_id` field to the document.\n * @inherits Document https://mongoosejs.com/docs/api/document.html\n * @event `error`: If listening to this event, 'error' is emitted when a document was saved and an `error` occurred. If not listening, the event bubbles to the connection used to create this Model.\n * @event `index`: Emitted after `Model#ensureIndexes` completes. If an error occurred it is passed with the event.\n * @event `index-single-start`: Emitted when an individual index starts within `Model#ensureIndexes`. The fields and options being used to build the index are also passed with the event.\n * @event `index-single-done`: Emitted when an individual index finishes within `Model#ensureIndexes`. If an error occurred it is passed with the event. The fields, options, and index name are also passed.\n * @api public\n */\n\nfunction Model(doc, fields, skipId) {\n  if (fields instanceof Schema) {\n    throw new TypeError('2nd argument to `Model` must be a POJO or string, ' +\n      '**not** a schema. Make sure you\\'re calling `mongoose.model()`, not ' +\n      '`mongoose.Model()`.');\n  }\n  Document.call(this, doc, fields, skipId);\n}\n\n/**\n * Inherits from Document.\n *\n * All Model.prototype features are available on\n * top level (non-sub) documents.\n * @api private\n */\n\nObject.setPrototypeOf(Model.prototype, Document.prototype);\nModel.prototype.$isMongooseModelPrototype = true;\n\n/**\n * Connection the model uses.\n *\n * @api public\n * @property db\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.db;\n\n/**\n * Collection the model uses.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api public\n * @property collection\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.collection;\n\n/**\n * Internal collection the model uses.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api private\n * @property collection\n * @memberOf Model\n * @instance\n */\n\n\nModel.prototype.$__collection;\n\n/**\n * The name of the model\n *\n * @api public\n * @property modelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.modelName;\n\n/**\n * Additional properties to attach to the query when calling `save()` and\n * `isNew` is false.\n *\n * @api public\n * @property $where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$where;\n\n/**\n * If this is a discriminator model, `baseModelName` is the name of\n * the base model.\n *\n * @api public\n * @property baseModelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.baseModelName;\n\n/**\n * Event emitter that reports any errors that occurred. Useful for global error\n * handling.\n *\n * #### Example:\n *\n *     MyModel.events.on('error', err => console.log(err.message));\n *\n *     // Prints a 'CastError' because of the above handler\n *     await MyModel.findOne({ _id: 'Not a valid ObjectId' }).catch(noop);\n *\n * @api public\n * @property events\n * @fires error whenever any query or model function errors\n * @memberOf Model\n * @static\n */\n\nModel.events;\n\n/**\n * Compiled middleware for this model. Set in `applyHooks()`.\n *\n * @api private\n * @property _middleware\n * @memberOf Model\n * @static\n */\n\nModel._middleware;\n\n/*!\n * ignore\n */\n\nfunction _applyCustomWhere(doc, where) {\n  if (doc.$where == null) {\n    return;\n  }\n  for (const key of Object.keys(doc.$where)) {\n    where[key] = doc.$where[key];\n  }\n}\n\n/*!\n * ignore\n */\n\nModel.prototype.$__handleSave = function(options, callback) {\n  const saveOptions = {};\n\n  applyWriteConcern(this.$__schema, options);\n  if (typeof options.writeConcern !== 'undefined') {\n    saveOptions.writeConcern = {};\n    if ('w' in options.writeConcern) {\n      saveOptions.writeConcern.w = options.writeConcern.w;\n    }\n    if ('j' in options.writeConcern) {\n      saveOptions.writeConcern.j = options.writeConcern.j;\n    }\n    if ('wtimeout' in options.writeConcern) {\n      saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;\n    }\n  } else {\n    if ('w' in options) {\n      saveOptions.w = options.w;\n    }\n    if ('j' in options) {\n      saveOptions.j = options.j;\n    }\n    if ('wtimeout' in options) {\n      saveOptions.wtimeout = options.wtimeout;\n    }\n  }\n  if ('checkKeys' in options) {\n    saveOptions.checkKeys = options.checkKeys;\n  }\n\n  const session = this.$session();\n  if (!saveOptions.hasOwnProperty('session') && session != null) {\n    saveOptions.session = session;\n  }\n\n  if (this.$isNew) {\n    // send entire doc\n    const obj = this.toObject(saveToObjectOptions);\n    if ((obj || {})._id === void 0) {\n      // documents must have an _id else mongoose won't know\n      // what to update later if more changes are made. the user\n      // wouldn't know what _id was generated by mongodb either\n      // nor would the ObjectId generated by mongodb necessarily\n      // match the schema definition.\n      immediate(function() {\n        callback(new MongooseError('document must have an _id before saving'));\n      });\n      return;\n    }\n\n    this.$__version(true, obj);\n    this[modelCollectionSymbol].insertOne(obj, saveOptions).then(\n      ret => callback(null, ret),\n      err => {\n        _setIsNew(this, true);\n\n        callback(err, null);\n      }\n    );\n\n    this.$__reset();\n    _setIsNew(this, false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n\n    return;\n  }\n\n  // Make sure we don't treat it as a new object on error,\n  // since it already exists\n  this.$__.inserting = false;\n  const delta = this.$__delta();\n  if (delta) {\n    if (delta instanceof MongooseError) {\n      callback(delta);\n      return;\n    }\n\n    const where = this.$__where(delta[0]);\n    if (where instanceof MongooseError) {\n      callback(where);\n      return;\n    }\n\n    _applyCustomWhere(this, where);\n    this[modelCollectionSymbol].updateOne(where, delta[1], saveOptions).then(\n      ret => {\n        ret.$where = where;\n        callback(null, ret);\n      },\n      err => {\n        this.$__undoReset();\n\n        callback(err);\n      }\n    );\n  } else {\n    const optionsWithCustomValues = Object.assign({}, options, saveOptions);\n    const where = this.$__where();\n    const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;\n    if (optimisticConcurrency) {\n      const key = this.$__schema.options.versionKey;\n      const val = this.$__getValue(key);\n      if (val != null) {\n        where[key] = val;\n      }\n    }\n    this.constructor.collection.findOne(where, optionsWithCustomValues)\n      .then(documentExists => {\n        const matchedCount = !documentExists ? 0 : 1;\n        callback(null, { $where: where, matchedCount });\n      })\n      .catch(callback);\n    return;\n  }\n\n  // store the modified paths before the document is reset\n  this.$__.modifiedPaths = this.modifiedPaths();\n  this.$__reset();\n\n  _setIsNew(this, false);\n};\n\n/*!\n * ignore\n */\n\nModel.prototype.$__save = function(options, callback) {\n  this.$__handleSave(options, (error, result) => {\n    if (error) {\n      const hooks = this.$__schema.s.hooks;\n      return hooks.execPost('save:error', this, [this], { error: error }, (error) => {\n        callback(error, this);\n      });\n    }\n    let numAffected = 0;\n    const writeConcern = options != null ?\n      options.writeConcern != null ?\n        options.writeConcern.w :\n        options.w :\n      0;\n    if (writeConcern !== 0) {\n      // Skip checking if write succeeded if writeConcern is set to\n      // unacknowledged writes, because otherwise `numAffected` will always be 0\n      if (result != null) {\n        if (Array.isArray(result)) {\n          numAffected = result.length;\n        } else if (result.matchedCount != null) {\n          numAffected = result.matchedCount;\n        } else {\n          numAffected = result;\n        }\n      }\n\n      const versionBump = this.$__.version;\n      // was this an update that required a version bump?\n      if (versionBump && !this.$__.inserting) {\n        const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);\n        this.$__.version = undefined;\n        const key = this.$__schema.options.versionKey;\n        const version = this.$__getValue(key) || 0;\n        if (numAffected <= 0) {\n          // the update failed. pass an error back\n          this.$__undoReset();\n          const err = this.$__.$versionError ||\n            new VersionError(this, version, this.$__.modifiedPaths);\n          return callback(err);\n        }\n\n        // increment version if was successful\n        if (doIncrement) {\n          this.$__setValue(key, version + 1);\n        }\n      }\n      if (result != null && numAffected <= 0) {\n        this.$__undoReset();\n        error = new DocumentNotFoundError(result.$where,\n          this.constructor.modelName, numAffected, result);\n        const hooks = this.$__schema.s.hooks;\n        return hooks.execPost('save:error', this, [this], { error: error }, (error) => {\n          callback(error, this);\n        });\n      }\n    }\n    this.$__.saving = undefined;\n    this.$__.savedState = {};\n    this.$emit('save', this, numAffected);\n    this.constructor.emit('save', this, numAffected);\n    callback(null, this);\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction generateVersionError(doc, modifiedPaths) {\n  const key = doc.$__schema.options.versionKey;\n  if (!key) {\n    return null;\n  }\n  const version = doc.$__getValue(key) || 0;\n  return new VersionError(doc, version, modifiedPaths);\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) is `true`,\n * or sends an [updateOne](https://mongoosejs.com/docs/api/document.html#Document.prototype.updateOne()) operation with just the modified paths if `isNew` is `false`.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](https://mongoosejs.com/docs/api/document.html#Document.prototype.session()).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com/docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] if `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#mongodb-limit-Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @throws {DocumentNotFoundError} if this [save updates an existing document](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise}\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\nModel.prototype.save = async function save(options) {\n  if (typeof options === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.save() no longer accepts a callback');\n  }\n\n  let parallelSave;\n  this.$op = 'save';\n\n  if (this.$__.saving) {\n    parallelSave = new ParallelSaveError(this);\n  } else {\n    this.$__.saving = new ParallelSaveError(this);\n  }\n\n  options = new SaveOptions(options);\n  if (options.hasOwnProperty('session')) {\n    this.$session(options.session);\n  }\n  if (this.$__.timestamps != null) {\n    options.timestamps = this.$__.timestamps;\n  }\n  this.$__.$versionError = generateVersionError(this, this.modifiedPaths());\n\n  if (parallelSave) {\n    this.$__handleReject(parallelSave);\n    throw parallelSave;\n  }\n\n  this.$__.saveOptions = options;\n\n  await new Promise((resolve, reject) => {\n    this.$__save(options, error => {\n      this.$__.saving = null;\n      this.$__.saveOptions = null;\n      this.$__.$versionError = null;\n      this.$op = null;\n      if (error != null) {\n        this.$__handleReject(error);\n        return reject(error);\n      }\n\n      resolve();\n    });\n  });\n\n  return this;\n};\n\nModel.prototype.$save = Model.prototype.save;\n\n/**\n * Determines whether versioning should be skipped for the given path\n *\n * @param {Document} self\n * @param {String} path\n * @return {Boolean} true if versioning should be skipped for the given path\n * @api private\n */\nfunction shouldSkipVersioning(self, path) {\n  const skipVersioning = self.$__schema.options.skipVersioning;\n  if (!skipVersioning) return false;\n\n  // Remove any array indexes from the path\n  path = path.replace(/\\.\\d+\\./, '.');\n\n  return skipVersioning[path];\n}\n\n/**\n * Apply the operation to the delta (update) clause as\n * well as track versioning for our where clause.\n *\n * @param {Document} self\n * @param {Object} where Unused\n * @param {Object} delta\n * @param {Object} data\n * @param {Mixed} val\n * @param {String} [op]\n * @api private\n */\n\nfunction operand(self, where, delta, data, val, op) {\n  // delta\n  op || (op = '$set');\n  if (!delta[op]) delta[op] = {};\n  delta[op][data.path] = val;\n  // disabled versioning?\n  if (self.$__schema.options.versionKey === false) return;\n\n  // path excluded from versioning?\n  if (shouldSkipVersioning(self, data.path)) return;\n\n  // already marked for versioning?\n  if (VERSION_ALL === (VERSION_ALL & self.$__.version)) return;\n\n  if (self.$__schema.options.optimisticConcurrency) {\n    return;\n  }\n\n  switch (op) {\n    case '$set':\n    case '$unset':\n    case '$pop':\n    case '$pull':\n    case '$pullAll':\n    case '$push':\n    case '$addToSet':\n    case '$inc':\n      break;\n    default:\n      // nothing to do\n      return;\n  }\n\n  // ensure updates sent with positional notation are\n  // editing the correct array element.\n  // only increment the version if an array position changes.\n  // modifying elements of an array is ok if position does not change.\n  if (op === '$push' || op === '$addToSet' || op === '$pullAll' || op === '$pull') {\n    if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {\n      increment.call(self);\n    } else {\n      self.$__.version = VERSION_INC;\n    }\n  } else if (/^\\$p/.test(op)) {\n    // potentially changing array positions\n    increment.call(self);\n  } else if (Array.isArray(val)) {\n    // $set an array\n    increment.call(self);\n  } else if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {\n    // now handling $set, $unset\n    // subpath of array\n    self.$__.version = VERSION_WHERE;\n  }\n}\n\n/**\n * Compiles an update and where clause for a `val` with _atomics.\n *\n * @param {Document} self\n * @param {Object} where\n * @param {Object} delta\n * @param {Object} data\n * @param {Array} value\n * @api private\n */\n\nfunction handleAtomics(self, where, delta, data, value) {\n  if (delta.$set && delta.$set[data.path]) {\n    // $set has precedence over other atomics\n    return;\n  }\n\n  if (typeof value.$__getAtomics === 'function') {\n    value.$__getAtomics().forEach(function(atomic) {\n      const op = atomic[0];\n      const val = atomic[1];\n      operand(self, where, delta, data, val, op);\n    });\n    return;\n  }\n\n  // legacy support for plugins\n\n  const atomics = value[arrayAtomicsSymbol];\n  const ops = Object.keys(atomics);\n  let i = ops.length;\n  let val;\n  let op;\n\n  if (i === 0) {\n    // $set\n\n    if (utils.isMongooseObject(value)) {\n      value = value.toObject({ depopulate: 1, _isNested: true });\n    } else if (value.valueOf) {\n      value = value.valueOf();\n    }\n\n    return operand(self, where, delta, data, value);\n  }\n\n  function iter(mem) {\n    return utils.isMongooseObject(mem)\n      ? mem.toObject({ depopulate: 1, _isNested: true })\n      : mem;\n  }\n\n  while (i--) {\n    op = ops[i];\n    val = atomics[op];\n\n    if (utils.isMongooseObject(val)) {\n      val = val.toObject({ depopulate: true, transform: false, _isNested: true });\n    } else if (Array.isArray(val)) {\n      val = val.map(iter);\n    } else if (val.valueOf) {\n      val = val.valueOf();\n    }\n\n    if (op === '$addToSet') {\n      val = { $each: val };\n    }\n\n    operand(self, where, delta, data, val, op);\n  }\n}\n\n/**\n * Produces a special query document of the modified properties used in updates.\n *\n * @api private\n * @method $__delta\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__delta = function() {\n  const dirty = this.$__dirty();\n\n  const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;\n  if (optimisticConcurrency) {\n    this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;\n  }\n\n  if (!dirty.length && VERSION_ALL !== this.$__.version) {\n    return;\n  }\n  const where = {};\n  const delta = {};\n  const len = dirty.length;\n  const divergent = [];\n  let d = 0;\n\n  where._id = this._doc._id;\n  // If `_id` is an object, need to depopulate, but also need to be careful\n  // because `_id` can technically be null (see gh-6406)\n  if ((where && where._id && where._id.$__ || null) != null) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n  for (; d < len; ++d) {\n    const data = dirty[d];\n    let value = data.value;\n    const match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    const pop = this.$populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      const pathSplit = data.path.split('.');\n      const top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === 'undefined') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = '$';\n          data.path = pathSplit.join('.');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    // If this path is set to default, and either this path or one of\n    // its parents is excluded, don't treat this path as dirty.\n    if (this.$isDefault(data.path) && this.$__.selected) {\n      if (data.path.indexOf('.') === -1 && isPathExcluded(this.$__.selected, data.path)) {\n        continue;\n      }\n\n      const pathsToCheck = parentPaths(data.path);\n      if (pathsToCheck.find(path => isPathExcluded(this.$__.isSelected, path))) {\n        continue;\n      }\n    }\n\n    if (divergent.length) continue;\n    if (value === undefined) {\n      operand(this, where, delta, data, 1, '$unset');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (utils.isMongooseArray(value) && value.$path() && value[arrayAtomicsSymbol]) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value[MongooseBuffer.pathSymbol] && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[data.path] != null) {\n        const val = this.$__.primitiveAtomics[data.path];\n        const op = firstKey(val);\n        operand(this, where, delta, data, val[op], op);\n      } else {\n        value = clone(value, {\n          depopulate: true,\n          transform: false,\n          virtuals: false,\n          getters: false,\n          omitUndefined: true,\n          _isNested: true\n        });\n        operand(this, where, delta, data, value);\n      }\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  if (Object.keys(delta).length === 0) {\n    return [where, null];\n  }\n\n  return [where, delta];\n};\n\n/**\n * Determine if array was populated with some form of filter and is now\n * being updated in a manner which could overwrite data unintentionally.\n *\n * @see https://github.com/Automattic/mongoose/issues/1334\n * @param {Document} doc\n * @param {String} path\n * @param {Any} array\n * @return {String|undefined}\n * @api private\n */\n\nfunction checkDivergentArray(doc, path, array) {\n  // see if we populated this path\n  const pop = doc.$populated(path, true);\n\n  if (!pop && doc.$__.selected) {\n    // If any array was selected using an $elemMatch projection, we deny the update.\n    // NOTE: MongoDB only supports projected $elemMatch on top level array.\n    const top = path.split('.')[0];\n    if (doc.$__.selected[top + '.$']) {\n      return top;\n    }\n  }\n\n  if (!(pop && utils.isMongooseArray(array))) return;\n\n  // If the array was populated using options that prevented all\n  // documents from being returned (match, skip, limit) or they\n  // deselected the _id field, $pop and $set of the array are\n  // not safe operations. If _id was deselected, we do not know\n  // how to remove elements. $pop will pop off the _id from the end\n  // of the array in the db which is not guaranteed to be the\n  // same as the last element we have here. $set of the entire array\n  // would be similarly destructive as we never received all\n  // elements of the array and potentially would overwrite data.\n  const check = pop.options.match ||\n      pop.options.options && utils.object.hasOwnProperty(pop.options.options, 'limit') || // 0 is not permitted\n      pop.options.options && pop.options.options.skip || // 0 is permitted\n      pop.options.select && // deselected _id?\n      (pop.options.select._id === 0 ||\n      /\\s?-_id\\s?/.test(pop.options.select));\n\n  if (check) {\n    const atomics = array[arrayAtomicsSymbol];\n    if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {\n      return path;\n    }\n  }\n}\n\n/**\n * Appends versioning to the where and update clauses.\n *\n * @api private\n * @method $__version\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__version = function(where, delta) {\n  const key = this.$__schema.options.versionKey;\n  if (where === true) {\n    // this is an insert\n    if (key) {\n      setDottedPath(delta, key, 0);\n      this.$__setValue(key, 0);\n    }\n    return;\n  }\n\n  if (key === false) {\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n\n  if (!this.$__isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don't need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    const value = this.$__getValue(key);\n    if (value != null) where[key] = value;\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (get(delta.$set, key, null) != null) {\n      // Version key is getting set, means we'll increment the doc's version\n      // after a successful save, so we should set the incremented version so\n      // future saves don't fail (gh-5779)\n      ++delta.$set[key];\n    } else {\n      delta.$inc = delta.$inc || {};\n      delta.$inc[key] = 1;\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}\n\n/**\n * Signal that we desire an increment of this documents version.\n *\n * #### Example:\n *\n *     const doc = await Model.findById(id);\n *     doc.increment();\n *     await doc.save();\n *\n * @see versionKeys https://mongoosejs.com/docs/guide.html#versionKey\n * @memberOf Model\n * @method increment\n * @api public\n */\n\nModel.prototype.increment = increment;\n\n/**\n * Returns a query object\n *\n * @api private\n * @method $__where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__where = function _where(where) {\n  where || (where = {});\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this._doc._id === void 0) {\n    return new MongooseError('No _id found on document!');\n  }\n\n  return where;\n};\n\n/**\n * Removes this document from the db. Equivalent to `.remove()`.\n *\n * #### Example:\n *\n *     product = await product.deleteOne();\n *     await Product.findById(product._id); // null\n *\n * @return {Promise} Promise\n * @api public\n */\n\nModel.prototype.deleteOne = async function deleteOne(options) {\n  if (typeof options === 'function' ||\n      typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (options.hasOwnProperty('session')) {\n    this.$session(options.session);\n  }\n\n  const res = await new Promise((resolve, reject) => {\n    this.$__deleteOne(options, (err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n\n  return res;\n};\n\n/*!\n * ignore\n */\n\nModel.prototype.$__deleteOne = function $__deleteOne(options, cb) {\n  if (this.$__.isDeleted) {\n    return immediate(() => cb(null, this));\n  }\n\n  const where = this.$__where();\n  if (where instanceof MongooseError) {\n    return cb(where);\n  }\n\n  _applyCustomWhere(this, where);\n\n  const session = this.$session();\n  if (!options.hasOwnProperty('session')) {\n    options.session = session;\n  }\n\n  this[modelCollectionSymbol].deleteOne(where, options, err => {\n    if (!err) {\n      this.$__.isDeleted = true;\n      this.$emit('deleteOne', this);\n      this.constructor.emit('deleteOne', this);\n      return cb(null, this);\n    }\n    this.$__.isDeleted = false;\n    cb(err);\n  });\n};\n\n/**\n * Returns another Model instance.\n *\n * #### Example:\n *\n *     const doc = new Tank;\n *     await doc.model('User').findById(id);\n *\n * @param {String} name model name\n * @method model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.model = function model(name) {\n  return this[modelDbSymbol].model(name);\n};\n\n/**\n * Returns another Model instance.\n *\n * #### Example:\n *\n *     const doc = new Tank;\n *     await doc.model('User').findById(id);\n *\n * @param {String} name model name\n * @method $model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.$model = function $model(name) {\n  return this[modelDbSymbol].model(name);\n};\n\n/**\n * Returns a document with `_id` only if at least one document exists in the database that matches\n * the given `filter`, and `null` otherwise.\n *\n * Under the hood, `MyModel.exists({ answer: 42 })` is equivalent to\n * `MyModel.findOne({ answer: 42 }).select({ _id: 1 }).lean()`\n *\n * #### Example:\n *\n *     await Character.deleteMany({});\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     await Character.exists({ name: /picard/i }); // { _id: ... }\n *     await Character.exists({ name: /riker/i }); // null\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * @param {Object} filter\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n */\n\nModel.exists = function exists(filter, options) {\n  _checkContext(this, 'exists');\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.exists() no longer accepts a callback');\n  }\n\n  const query = this.findOne(filter).\n    select({ _id: 1 }).\n    lean().\n    setOptions(options);\n\n  return query;\n};\n\n/**\n * Adds a discriminator type.\n *\n * #### Example:\n *\n *     function BaseSchema() {\n *       Schema.apply(this, arguments);\n *\n *       this.add({\n *         name: String,\n *         createdAt: Date\n *       });\n *     }\n *     util.inherits(BaseSchema, Schema);\n *\n *     const PersonSchema = new BaseSchema();\n *     const BossSchema = new BaseSchema({ department: String });\n *\n *     const Person = mongoose.model('Person', PersonSchema);\n *     const Boss = Person.discriminator('Boss', BossSchema);\n *     new Boss().__t; // \"Boss\". `__t` is the default `discriminatorKey`\n *\n *     const employeeSchema = new Schema({ boss: ObjectId });\n *     const Employee = Person.discriminator('Employee', employeeSchema, 'staff');\n *     new Employee().__t; // \"staff\" because of 3rd argument above\n *\n * @param {String} name discriminator model name\n * @param {Schema} schema discriminator model schema\n * @param {Object|String} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @param {Boolean} [options.overwriteModels=false] by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.\n * @param {Boolean} [options.mergeHooks=true] By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to `false` to make Mongoose use the discriminator schema's hooks instead.\n * @param {Boolean} [options.mergePlugins=true] By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to `false` to make Mongoose use the discriminator schema's plugins instead.\n * @return {Model} The newly created discriminator model\n * @api public\n */\n\nModel.discriminator = function(name, schema, options) {\n  let model;\n  if (typeof name === 'function') {\n    model = name;\n    name = utils.getFunctionName(model);\n    if (!(model.prototype instanceof Model)) {\n      throw new MongooseError('The provided class ' + name + ' must extend Model');\n    }\n  }\n\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n  const mergePlugins = typeof options.mergePlugins === 'boolean' ? options.mergePlugins : true;\n\n  _checkContext(this, 'discriminator');\n\n  if (utils.isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n  if (schema instanceof Schema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this, name, schema, value, mergePlugins, options.mergeHooks);\n  if (this.db.models[name] && !schema.options.overwriteModels) {\n    throw new OverwriteModelError(name);\n  }\n\n  schema.$isRootDiscriminator = true;\n  schema.$globalPluginsApplied = true;\n\n  model = this.db.model(model || name, schema, this.$__collection.name);\n  this.discriminators[name] = model;\n  const d = this.discriminators[name];\n  Object.setPrototypeOf(d.prototype, this.prototype);\n  Object.defineProperty(d, 'baseModelName', {\n    value: this.modelName,\n    configurable: true,\n    writable: false\n  });\n\n  // apply methods and statics\n  applyMethods(d, schema);\n  applyStatics(d, schema);\n\n  if (this[subclassedSymbol] != null) {\n    for (const submodel of this[subclassedSymbol]) {\n      submodel.discriminators = submodel.discriminators || {};\n      submodel.discriminators[name] =\n        model.__subclass(model.db, schema, submodel.collection.name);\n    }\n  }\n\n  return d;\n};\n\n/**\n * Make sure `this` is a model\n * @api private\n */\n\nfunction _checkContext(ctx, fnName) {\n  // Check context, because it is easy to mistakenly type\n  // `new Model.discriminator()` and get an incomprehensible error\n  if (ctx == null || ctx === global) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' +\n      'model as `this`. Make sure you are calling `MyModel.' + fnName + '()` ' +\n      'where `MyModel` is a Mongoose model.');\n  } else if (ctx[modelSymbol] == null) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' +\n      'model as `this`. Make sure you are not calling ' +\n      '`new Model.' + fnName + '()`');\n  }\n}\n\n// Model (class) features\n\n/*!\n * Give the constructor the ability to emit events.\n */\n\nfor (const i in EventEmitter.prototype) {\n  Model[i] = EventEmitter.prototype[i];\n}\n\n/**\n * This function is responsible for building [indexes](https://www.mongodb.com/docs/manual/indexes/),\n * unless [`autoIndex`](https://mongoosejs.com/docs/guide.html#autoIndex) is turned off.\n *\n * Mongoose calls this function automatically when a model is created using\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) or\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()), so you\n * don't need to call `init()` to trigger index builds.\n *\n * However, you _may_ need to call `init()`  to get back a promise that will resolve when your indexes are finished.\n * Calling `await Model.init()` is helpful if you need to wait for indexes to build before continuing.\n * For example, if you want to wait for unique indexes to build before continuing with a test case.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     // This calls `Event.init()` implicitly, so you don't need to call\n *     // `Event.init()` on your own.\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     await Event.init();\n *     console.log('Indexes are done building!');\n *\n * @api public\n * @returns {Promise}\n */\n\nModel.init = function init() {\n  _checkContext(this, 'init');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.init() no longer accepts a callback');\n  }\n\n  this.schema.emit('init', this);\n\n  if (this.$init != null) {\n    return this.$init;\n  }\n\n  const conn = this.db;\n  const _ensureIndexes = async() => {\n    const autoIndex = utils.getOption(\n      'autoIndex',\n      this.schema.options,\n      conn.config,\n      conn.base.options\n    );\n    if (!autoIndex) {\n      return;\n    }\n    return await this.ensureIndexes({ _automatic: true });\n  };\n  const _createCollection = async() => {\n    if ((conn.readyState === STATES.connecting || conn.readyState === STATES.disconnected) && conn._shouldBufferCommands()) {\n      await new Promise(resolve => {\n        conn._queue.push({ fn: resolve });\n      });\n    }\n    const autoCreate = utils.getOption(\n      'autoCreate',\n      this.schema.options,\n      conn.config,\n      conn.base.options\n    );\n    if (!autoCreate) {\n      return;\n    }\n    return await this.createCollection();\n  };\n\n  this.$init = _createCollection().then(() => _ensureIndexes());\n\n  const _catch = this.$init.catch;\n  const _this = this;\n  this.$init.catch = function() {\n    _this.$caught = true;\n    return _catch.apply(_this.$init, arguments);\n  };\n\n  return this.$init;\n};\n\n\n/**\n * Create the collection for this model. By default, if no indexes are specified,\n * mongoose will not create the collection for the model until any documents are\n * created. Use this method to create the collection explicitly.\n *\n * Note 1: You may need to call this before starting a transaction\n * See https://www.mongodb.com/docs/manual/core/transactions/#transactions-and-operations\n *\n * Note 2: You don't have to call this if your schema contains index or unique field.\n * In that case, just use `Model.init()`\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String })\n *     const User = mongoose.model('User', userSchema);\n *\n *     User.createCollection().then(function(collection) {\n *       console.log('Collection is created!');\n *     });\n *\n * @api public\n * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n * @returns {Promise}\n */\n\nModel.createCollection = async function createCollection(options) {\n  _checkContext(this, 'createCollection');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createCollection() no longer accepts a callback');\n  }\n\n  const schemaCollation = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.collation;\n  if (schemaCollation != null) {\n    options = Object.assign({ collation: schemaCollation }, options);\n  }\n  const capped = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.capped;\n  if (capped != null) {\n    if (typeof capped === 'number') {\n      options = Object.assign({ capped: true, size: capped }, options);\n    } else if (typeof capped === 'object') {\n      options = Object.assign({ capped: true }, capped, options);\n    }\n  }\n  const timeseries = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.timeseries;\n  if (timeseries != null) {\n    options = Object.assign({ timeseries }, options);\n    if (options.expireAfterSeconds != null) {\n      // do nothing\n    } else if (options.expires != null) {\n      utils.expires(options);\n    } else if (this.schema.options.expireAfterSeconds != null) {\n      options.expireAfterSeconds = this.schema.options.expireAfterSeconds;\n    } else if (this.schema.options.expires != null) {\n      options.expires = this.schema.options.expires;\n      utils.expires(options);\n    }\n  }\n\n  const clusteredIndex = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.clusteredIndex;\n  if (clusteredIndex != null) {\n    options = Object.assign({ clusteredIndex: { ...clusteredIndex, unique: true } }, options);\n  }\n\n  try {\n    await this.db.createCollection(this.$__collection.collectionName, options);\n  } catch (err) {\n\n    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n      throw err;\n    }\n  }\n  return this.$__collection;\n};\n\n/**\n * Makes the indexes in MongoDB match the indexes defined in this model's\n * schema. This function will drop any indexes that are not defined in\n * the model's schema except the `_id` index, and build any indexes that\n * are in your schema but not in MongoDB.\n *\n * See the [introductory blog post](https://thecodebarbarian.com/whats-new-in-mongoose-5-2-syncindexes)\n * for more information.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.collection.createIndex({ age: 1 }); // Index is not in schema\n *     // Will drop the 'age' index and create an index on `name`\n *     await Customer.syncIndexes();\n *\n * @param {Object} [options] options to pass to `ensureIndexes()`\n * @param {Boolean} [options.background=null] if specified, overrides each index's `background` property\n * @return {Promise}\n * @api public\n */\n\nModel.syncIndexes = async function syncIndexes(options) {\n  _checkContext(this, 'syncIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n\n  const model = this;\n\n  try {\n    await model.createCollection();\n  } catch (err) {\n    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n      throw err;\n    }\n  }\n\n  const diffIndexesResult = await model.diffIndexes();\n  const dropped = await model.cleanIndexes({ ...options, toDrop: diffIndexesResult.toDrop });\n  await model.createIndexes({ ...options, toCreate: diffIndexesResult.toCreate });\n\n  return dropped;\n};\n\n/**\n * Does a dry-run of Model.syncIndexes(), meaning that\n * the result of this function would be the result of\n * Model.syncIndexes().\n *\n * @param {Object} [options]\n * @returns {Promise} which contains an object, {toDrop, toCreate}, which\n * are indexes that would be dropped in MongoDB and indexes that would be created in MongoDB.\n */\n\nModel.diffIndexes = async function diffIndexes() {\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n\n  const model = this;\n\n  let dbIndexes = await model.listIndexes();\n  if (dbIndexes === undefined) {\n    dbIndexes = [];\n  }\n  dbIndexes = getRelatedDBIndexes(model, dbIndexes);\n\n  const schema = model.schema;\n  const schemaIndexes = getRelatedSchemaIndexes(model, schema.indexes());\n\n  const toDrop = getIndexesToDrop(schema, schemaIndexes, dbIndexes);\n  const toCreate = getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop);\n\n  return { toDrop, toCreate };\n};\n\nfunction getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop) {\n  const toCreate = [];\n\n  for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n    let found = false;\n\n    const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n\n    for (const index of dbIndexes) {\n      if (isDefaultIdIndex(index)) {\n        continue;\n      }\n      if (\n        isIndexEqual(schemaIndexKeysObject, options, index) &&\n        !toDrop.includes(index.name)\n      ) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      toCreate.push(schemaIndexKeysObject);\n    }\n  }\n\n  return toCreate;\n}\n\nfunction getIndexesToDrop(schema, schemaIndexes, dbIndexes) {\n  const toDrop = [];\n\n  for (const dbIndex of dbIndexes) {\n    let found = false;\n    // Never try to drop `_id` index, MongoDB server doesn't allow it\n    if (isDefaultIdIndex(dbIndex)) {\n      continue;\n    }\n\n    for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n      const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n      applySchemaCollation(schemaIndexKeysObject, options, schema.options);\n\n      if (isIndexEqual(schemaIndexKeysObject, options, dbIndex)) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      toDrop.push(dbIndex.name);\n    }\n  }\n\n  return toDrop;\n}\n/**\n * Deletes all indexes that aren't defined in this model's schema. Used by\n * `syncIndexes()`.\n *\n * The returned promise resolves to a list of the dropped indexes' names as an array\n *\n * @param {Function} [callback] optional callback\n * @return {Promise|undefined} Returns `undefined` if callback is specified, returns a promise if no callback.\n * @api public\n */\n\nModel.cleanIndexes = async function cleanIndexes(options) {\n  _checkContext(this, 'cleanIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.cleanIndexes() no longer accepts a callback');\n  }\n  const model = this;\n\n  const collection = model.$__collection;\n\n  if (Array.isArray(options && options.toDrop)) {\n    const res = await _dropIndexes(options.toDrop, collection);\n    return res;\n  }\n\n  const res = await model.diffIndexes();\n  return await _dropIndexes(res.toDrop, collection);\n};\n\nasync function _dropIndexes(toDrop, collection) {\n  if (toDrop.length === 0) {\n    return [];\n  }\n\n  await Promise.all(toDrop.map(indexName => collection.dropIndex(indexName)));\n  return toDrop;\n}\n\n/**\n * Lists the indexes currently defined in MongoDB. This may or may not be\n * the same as the indexes defined in your schema depending on whether you\n * use the [`autoIndex` option](https://mongoosejs.com/docs/guide.html#autoIndex) and if you\n * build indexes manually.\n *\n * @return {Promise}\n * @api public\n */\n\nModel.listIndexes = async function listIndexes() {\n  _checkContext(this, 'listIndexes');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.listIndexes() no longer accepts a callback');\n  }\n\n  if (this.$__collection.buffer) {\n    await new Promise(resolve => {\n      this.$__collection.addQueue(resolve);\n    });\n  }\n\n  return this.$__collection.listIndexes().toArray();\n};\n\n/**\n * Sends `createIndex` commands to mongo for each index declared in the schema.\n * The `createIndex` commands are sent in series.\n *\n * #### Example:\n *\n *     Event.ensureIndexes(function (err) {\n *       if (err) return handleError(err);\n *     });\n *\n * After completion, an `index` event is emitted on this `Model` passing an error if one occurred.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     Event.on('index', function (err) {\n *       if (err) console.error(err); // error occurred during index creation\n *     })\n *\n * _NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution._\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.ensureIndexes = async function ensureIndexes(options) {\n  _checkContext(this, 'ensureIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.ensureIndexes() no longer accepts a callback');\n  }\n\n  await new Promise((resolve, reject) => {\n    _ensureIndexes(this, options, (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n};\n\n/**\n * Similar to `ensureIndexes()`, except for it uses the [`createIndex`](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createIndex)\n * function.\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.createIndexes = async function createIndexes(options) {\n  _checkContext(this, 'createIndexes');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createIndexes() no longer accepts a callback');\n  }\n\n  return this.ensureIndexes(options);\n};\n\n\n/*!\n * ignore\n */\n\nfunction _ensureIndexes(model, options, callback) {\n  const indexes = model.schema.indexes();\n  let indexError;\n\n  options = options || {};\n  const done = function(err) {\n    if (err && !model.$caught) {\n      model.emit('error', err);\n    }\n    model.emit('index', err || indexError);\n    callback && callback(err || indexError);\n  };\n\n  for (const index of indexes) {\n    if (isDefaultIdIndex(index)) {\n      utils.warn('mongoose: Cannot specify a custom index on `_id` for ' +\n        'model name \"' + model.modelName + '\", ' +\n        'MongoDB does not allow overwriting the default `_id` index. See ' +\n        'https://bit.ly/mongodb-id-index');\n    }\n  }\n\n  if (!indexes.length) {\n    immediate(function() {\n      done();\n    });\n    return;\n  }\n  // Indexes are created one-by-one to support how MongoDB < 2.4 deals\n  // with background indexes.\n\n  const indexSingleDone = function(err, fields, options, name) {\n    model.emit('index-single-done', err, fields, options, name);\n  };\n  const indexSingleStart = function(fields, options) {\n    model.emit('index-single-start', fields, options);\n  };\n\n  const baseSchema = model.schema._baseSchema;\n  const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];\n\n  immediate(function() {\n    // If buffering is off, do this manually.\n    if (options._automatic && !model.collection.collection) {\n      model.collection.addQueue(create, []);\n    } else {\n      create();\n    }\n  });\n\n\n  function create() {\n    if (options._automatic) {\n      if (model.schema.options.autoIndex === false ||\n          (model.schema.options.autoIndex == null && model.db.config.autoIndex === false)) {\n        return done();\n      }\n    }\n\n    const index = indexes.shift();\n    if (!index) {\n      return done();\n    }\n    if (options._automatic && index[1]._autoIndex === false) {\n      return create();\n    }\n\n    if (baseSchemaIndexes.find(i => utils.deepEqual(i, index))) {\n      return create();\n    }\n\n    const indexFields = clone(index[0]);\n    const indexOptions = clone(index[1]);\n\n    delete indexOptions._autoIndex;\n    decorateDiscriminatorIndexOptions(model.schema, indexOptions);\n    applyWriteConcern(model.schema, indexOptions);\n    applySchemaCollation(indexFields, indexOptions, model.schema.options);\n\n    indexSingleStart(indexFields, options);\n\n    if ('background' in options) {\n      indexOptions.background = options.background;\n    }\n\n    if ('toCreate' in options) {\n      if (options.toCreate.length === 0) {\n        return done();\n      }\n    }\n\n    model.collection.createIndex(indexFields, indexOptions).then(\n      name => {\n        indexSingleDone(null, indexFields, indexOptions, name);\n        create();\n      },\n      err => {\n        if (!indexError) {\n          indexError = err;\n        }\n        if (!model.$caught) {\n          model.emit('error', err);\n        }\n\n        indexSingleDone(err, indexFields, indexOptions);\n        create();\n      }\n    );\n  }\n}\n\n/**\n * Schema the model uses.\n *\n * @property schema\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.schema;\n\n/**\n * Connection instance the model uses.\n *\n * @property db\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.db;\n\n/**\n * Collection the model uses.\n *\n * @property collection\n * @api public\n * @memberOf Model\n */\n\nModel.collection;\n\n/**\n * Internal collection the model uses.\n *\n * @property collection\n * @api private\n * @memberOf Model\n */\nModel.$__collection;\n\n/**\n * Base Mongoose instance the model uses.\n *\n * @property base\n * @api public\n * @memberOf Model\n */\n\nModel.base;\n\n/**\n * Registered discriminators for this model.\n *\n * @property discriminators\n * @api public\n * @memberOf Model\n */\n\nModel.discriminators;\n\n/**\n * Translate any aliases fields/conditions so the final query or document object is pure\n *\n * #### Example:\n *\n *     Character\n *       .find(Character.translateAliases({\n *         '名': 'Eddard Stark' // Alias for 'name'\n *       })\n *       .exec(function(err, characters) {})\n *\n * #### Note:\n *\n * Only translate arguments of object type anything else is returned raw\n *\n * @param {Object} fields fields/conditions that may contain aliased keys\n * @return {Object} the translated 'pure' fields/conditions\n */\nModel.translateAliases = function translateAliases(fields) {\n  _checkContext(this, 'translateAliases');\n\n  const translate = (key, value) => {\n    let alias;\n    const translated = [];\n    const fieldKeys = key.split('.');\n    let currentSchema = this.schema;\n    for (const i in fieldKeys) {\n      const name = fieldKeys[i];\n      if (currentSchema && currentSchema.aliases[name]) {\n        alias = currentSchema.aliases[name];\n        // Alias found,\n        translated.push(alias);\n      } else {\n        alias = name;\n        // Alias not found, so treat as un-aliased key\n        translated.push(name);\n      }\n\n      // Check if aliased path is a schema\n      if (currentSchema && currentSchema.paths[alias]) {\n        currentSchema = currentSchema.paths[alias].schema;\n      }\n      else\n        currentSchema = null;\n    }\n\n    const translatedKey = translated.join('.');\n    if (fields instanceof Map)\n      fields.set(translatedKey, value);\n    else\n      fields[translatedKey] = value;\n\n    if (translatedKey !== key) {\n      // We'll be using the translated key instead\n      if (fields instanceof Map) {\n        // Delete from map\n        fields.delete(key);\n      } else {\n        // Delete from object\n        delete fields[key]; // We'll be using the translated key instead\n      }\n    }\n    return fields;\n  };\n\n  if (typeof fields === 'object') {\n    // Fields is an object (query conditions or document fields)\n    if (fields instanceof Map) {\n      // A Map was supplied\n      for (const field of new Map(fields)) {\n        fields = translate(field[0], field[1]);\n      }\n    } else {\n      // Infer a regular object was supplied\n      for (const key of Object.keys(fields)) {\n        fields = translate(key, fields[key]);\n        if (key[0] === '$') {\n          if (Array.isArray(fields[key])) {\n            for (const i in fields[key]) {\n              // Recursively translate nested queries\n              fields[key][i] = this.translateAliases(fields[key][i]);\n            }\n          }\n        }\n      }\n    }\n\n    return fields;\n  } else {\n    // Don't know typeof fields\n    return fields;\n  }\n};\n\n/**\n * Deletes the first document that matches `conditions` from the collection.\n * It returns an object with the property `deletedCount` indicating how many documents were deleted.\n * Behaves like `remove()`, but deletes at most one document regardless of the\n * `single` option.\n *\n * #### Example:\n *\n *     await Character.deleteOne({ name: 'Eddard Stark' }); // returns {deletedCount: 1}\n *\n * #### Note:\n *\n * This function triggers `deleteOne` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @api public\n */\n\nModel.deleteOne = function deleteOne(conditions, options) {\n  _checkContext(this, 'deleteOne');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n\n  return mq.deleteOne(conditions);\n};\n\n/**\n * Deletes all of the documents that match `conditions` from the collection.\n * It returns an object with the property `deletedCount` containing the number of documents deleted.\n * Behaves like `remove()`, but deletes all documents that match `conditions`\n * regardless of the `single` option.\n *\n * #### Example:\n *\n *     await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }); // returns {deletedCount: x} where x is the number of documents deleted.\n *\n * #### Note:\n *\n * This function triggers `deleteMany` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @api public\n */\n\nModel.deleteMany = function deleteMany(conditions, options) {\n  _checkContext(this, 'deleteMany');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.deleteMany() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n\n  return mq.deleteMany(conditions);\n};\n\n/**\n * Finds documents.\n *\n * Mongoose casts the `filter` to match the model's schema before the command is sent.\n * See our [query casting tutorial](https://mongoosejs.com/docs/tutorials/query_casting.html) for\n * more information on how Mongoose casts `filter`.\n *\n * #### Example:\n *\n *     // find all documents\n *     await MyModel.find({});\n *\n *     // find all documents named john and at least 18\n *     await MyModel.find({ name: 'john', age: { $gte: 18 } }).exec();\n *\n *     // executes, name LIKE john and only selecting the \"name\" and \"friends\" fields\n *     await MyModel.find({ name: /john/i }, 'name friends').exec();\n *\n *     // passing options\n *     await MyModel.find({ name: /john/i }, null, { skip: 10 }).exec();\n *\n * @param {Object|ObjectId} filter\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see query casting https://mongoosejs.com/docs/tutorials/query_casting.html\n * @api public\n */\n\nModel.find = function find(conditions, projection, options) {\n  _checkContext(this, 'find');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.find() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n\n  return mq.find(conditions);\n};\n\n/**\n * Finds a single document by its _id field. `findById(id)` is almost*\n * equivalent to `findOne({ _id: id })`. If you want to query by a document's\n * `_id`, use `findById()` instead of `findOne()`.\n *\n * The `id` is cast based on the Schema before sending the command.\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * \\* Except for how it treats `undefined`. If you use `findOne()`, you'll see\n * that `findOne(undefined)` and `findOne({ _id: undefined })` are equivalent\n * to `findOne({})` and return arbitrary documents. However, mongoose\n * translates `findById(undefined)` into `findOne({ _id: null })`.\n *\n * #### Example:\n *\n *     // Find the adventure with the given `id`, or `null` if not found\n *     await Adventure.findById(id).exec();\n *\n *     // select only the adventures name and length\n *     await Adventure.findById(id, 'name length').exec();\n *\n * @param {Any} id value of `_id` to query by\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @see findById in Mongoose https://masteringjs.io/tutorials/mongoose/find-by-id\n * @api public\n */\n\nModel.findById = function findById(id, projection, options) {\n  _checkContext(this, 'findById');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findById() no longer accepts a callback');\n  }\n\n  if (typeof id === 'undefined') {\n    id = null;\n  }\n\n  return this.findOne({ _id: id }, projection, options);\n};\n\n/**\n * Finds one document.\n *\n * The `conditions` are cast to their respective SchemaTypes before the command is sent.\n *\n * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `findById()` instead.\n *\n * #### Example:\n *\n *     // Find one adventure whose `country` is 'Croatia', otherwise `null`\n *     await Adventure.findOne({ country: 'Croatia' }).exec();\n *\n *     // Model.findOne() no longer accepts a callback\n *\n *     // Select only the adventures name and length\n *     await Adventure.findOne({ country: 'Croatia' }, 'name length').exec();\n *\n * @param {Object} [conditions]\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @api public\n */\n\nModel.findOne = function findOne(conditions, projection, options) {\n  _checkContext(this, 'findOne');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOne() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n\n  return mq.findOne(conditions);\n};\n\n/**\n * Estimates the number of documents in the MongoDB collection. Faster than\n * using `countDocuments()` for large collections because\n * `estimatedDocumentCount()` uses collection metadata rather than scanning\n * the entire collection.\n *\n * #### Example:\n *\n *     const numAdventures = await Adventure.estimatedDocumentCount();\n *\n * @param {Object} [options]\n * @return {Query}\n * @api public\n */\n\nModel.estimatedDocumentCount = function estimatedDocumentCount(options) {\n  _checkContext(this, 'estimatedDocumentCount');\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n\n  return mq.estimatedDocumentCount(options);\n};\n\n/**\n * Counts number of documents matching `filter` in a database collection.\n *\n * #### Example:\n *\n *     Adventure.countDocuments({ type: 'jungle' }, function (err, count) {\n *       console.log('there are %d jungle adventures', count);\n *     });\n *\n * If you want to count all documents in a large collection,\n * use the [`estimatedDocumentCount()` function](https://mongoosejs.com/docs/api/model.html#Model.estimatedDocumentCount())\n * instead. If you call `countDocuments({})`, MongoDB will always execute\n * a full collection scan and **not** use any indexes.\n *\n * The `countDocuments()` function is similar to `count()`, but there are a\n * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * Below are the operators that `count()` supports but `countDocuments()` does not,\n * and the suggested replacement:\n *\n * - `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)\n * - `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)\n * - `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n *\n * @param {Object} filter\n * @return {Query}\n * @api public\n */\n\nModel.countDocuments = function countDocuments(conditions, options) {\n  _checkContext(this, 'countDocuments');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.countDocuments() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  if (options != null) {\n    mq.setOptions(options);\n  }\n\n  return mq.countDocuments(conditions);\n};\n\n/**\n * Counts number of documents that match `filter` in a database collection.\n *\n * This method is deprecated. If you want to count the number of documents in\n * a collection, e.g. `count({})`, use the [`estimatedDocumentCount()` function](https://mongoosejs.com/docs/api/model.html#Model.estimatedDocumentCount())\n * instead. Otherwise, use the [`countDocuments()`](https://mongoosejs.com/docs/api/model.html#Model.countDocuments()) function instead.\n *\n * #### Example:\n *\n *     const count = await Adventure.count({ type: 'jungle' });\n *     console.log('there are %d jungle adventures', count);\n *\n * @deprecated\n * @param {Object} [filter]\n * @return {Query}\n * @api public\n */\n\nModel.count = function count(conditions) {\n  _checkContext(this, 'count');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.count() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n\n  return mq.count(conditions);\n};\n\n/**\n * Creates a Query for a `distinct` operation.\n *\n * #### Example:\n *\n *     const query = Link.distinct('url');\n *     query.exec();\n *\n * @param {String} field\n * @param {Object} [conditions] optional\n * @return {Query}\n * @api public\n */\n\nModel.distinct = function distinct(field, conditions) {\n  _checkContext(this, 'distinct');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.distinct() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n\n  return mq.distinct(field, conditions);\n};\n\n/**\n * Creates a Query, applies the passed conditions, and returns the Query.\n *\n * For example, instead of writing:\n *\n *     User.find({ age: { $gte: 21, $lte: 65 } });\n *\n * we can instead write:\n *\n *     User.where('age').gte(21).lte(65).exec();\n *\n * Since the Query class also supports `where` you can continue chaining\n *\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^b/i)\n *     ... etc\n *\n * @param {String} path\n * @param {Object} [val] optional value\n * @return {Query}\n * @api public\n */\n\nModel.where = function where(path, val) {\n  _checkContext(this, 'where');\n\n  void val; // eslint\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.where.apply(mq, arguments);\n};\n\n/**\n * Creates a `Query` and specifies a `$where` condition.\n *\n * Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.\n *\n *     Blog.$where('this.username.indexOf(\"val\") !== -1').exec(function (err, docs) {});\n *\n * @param {String|Function} argument is a javascript string or anonymous function\n * @method $where\n * @memberOf Model\n * @return {Query}\n * @see Query.$where https://mongoosejs.com/docs/api/query.html#Query.prototype.$where\n * @api public\n */\n\nModel.$where = function $where() {\n  _checkContext(this, '$where');\n\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.$where.apply(mq, arguments);\n};\n\n/**\n * Issues a mongodb findAndModify update command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes if `callback` is passed else a Query object is returned.\n *\n * #### Example:\n *\n *     A.findOneAndUpdate(conditions, update, options)  // returns Query\n *     A.findOneAndUpdate(conditions, update)           // returns Query\n *     A.findOneAndUpdate()                             // returns Query\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     const query = { name: 'borne' };\n *     Model.findOneAndUpdate(query, { name: 'jason bourne' }, options)\n *\n *     // is sent as\n *     Model.findOneAndUpdate(query, { $set: { name: 'jason bourne' }}, options)\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation that\n * you can enable by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id);\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} [conditions]\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.overwrite=false] By default, if you don't include any [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/) in `update`, Mongoose will wrap `update` in `$set` for you. This prevents you from accidentally overwriting the document. This option tells Mongoose to skip adding `$set`. An alternative to this would be using [Model.findOneAndReplace(conditions, update, options, callback)](https://mongoosejs.com/docs/api/model.html#Model.findOneAndReplace()).\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.fields] Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @return {Query}\n * @see Tutorial https://mongoosejs.com/docs/tutorials/findoneandupdate.html\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findOneAndUpdate = function(conditions, update, options) {\n  _checkContext(this, 'findOneAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndUpdate() no longer accepts a callback');\n  }\n\n  if (arguments.length === 1) {\n    update = conditions;\n    conditions = null;\n    options = null;\n  }\n\n  let fields;\n  if (options) {\n    fields = options.fields || options.projection;\n  }\n\n  update = clone(update, {\n    depopulate: true,\n    _isNested: true\n  });\n\n  _decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndUpdate(conditions, update, options);\n};\n\n/**\n * Decorate the update with a version key, if necessary\n * @api private\n */\n\nfunction _decorateUpdateWithVersionKey(update, options, versionKey) {\n  if (!versionKey || !(options && options.upsert || false)) {\n    return;\n  }\n\n  const updatedPaths = modifiedPaths(update);\n  if (!updatedPaths[versionKey]) {\n    if (options.overwrite) {\n      update[versionKey] = 0;\n    } else {\n      if (!update.$setOnInsert) {\n        update.$setOnInsert = {};\n      }\n      update.$setOnInsert[versionKey] = 0;\n    }\n  }\n}\n\n/**\n * Issues a mongodb findAndModify update command by a document's _id field.\n * `findByIdAndUpdate(id, ...)` is equivalent to `findOneAndUpdate({ _id: id }, ...)`.\n *\n * Finds a matching document, updates it according to the `update` arg,\n * passing any `options`, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndUpdate()`\n *\n * #### Example:\n *\n *     A.findByIdAndUpdate(id, update, options)  // returns Query\n *     A.findByIdAndUpdate(id, update)           // returns Query\n *     A.findByIdAndUpdate()                     // returns Query\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options)\n *\n *     // is sent as\n *     Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options)\n *\n * This helps prevent accidentally overwriting your document with `{ name: 'jason bourne' }`.\n * To prevent this behaviour, see the `overwrite` option\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.overwrite=false] By default, if you don't include any [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/) in `update`, Mongoose will wrap `update` in `$set` for you. This prevents you from accidentally overwriting the document. This option tells Mongoose to skip adding `$set`. An alternative to this would be using [Model.findOneAndReplace({ _id: id }, update, options)](https://mongoosejs.com/docs/api/model.html#Model.findOneAndReplace()).\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.select] sets the document fields to return.\n * @return {Query}\n * @see Model.findOneAndUpdate https://mongoosejs.com/docs/api/model.html#Model.findOneAndUpdate()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findByIdAndUpdate = function(id, update, options) {\n  _checkContext(this, 'findByIdAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findByIdAndUpdate() no longer accepts a callback');\n  }\n\n  // if a model is passed in instead of an id\n  if (id instanceof Document) {\n    id = id._id;\n  }\n\n  return this.findOneAndUpdate.call(this, { _id: id }, update, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * This function differs slightly from `Model.findOneAndRemove()` in that\n * `findOneAndRemove()` becomes a [MongoDB `findAndModify()` command](https://www.mongodb.com/docs/manual/reference/method/db.collection.findAndModify/),\n * as opposed to a `findOneAndDelete()` command. For most mongoose use cases,\n * this distinction is purely pedantic. You should use `findOneAndDelete()`\n * unless you have a good reason not to.\n *\n * #### Example:\n *\n *     A.findOneAndDelete(conditions, options)  // return Query\n *     A.findOneAndDelete(conditions) // returns Query\n *     A.findOneAndDelete()           // returns Query\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndDelete = function(conditions, options) {\n  _checkContext(this, 'findOneAndDelete');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOneAndDelete() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndDelete(conditions, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command by a document's _id field.\n * In other words, `findByIdAndDelete(id)` is a shorthand for\n * `findOneAndDelete({ _id: id })`.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @return {Query}\n * @see Model.findOneAndRemove https://mongoosejs.com/docs/api/model.html#Model.findOneAndRemove()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n */\n\nModel.findByIdAndDelete = function(id, options) {\n  _checkContext(this, 'findByIdAndDelete');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findByIdAndDelete() no longer accepts a callback');\n  }\n\n  return this.findOneAndDelete({ _id: id }, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndReplace()` command.\n *\n * Finds a matching document, replaces it with the provided doc, and returns the document.\n *\n * This function triggers the following query middleware.\n *\n * - `findOneAndReplace()`\n *\n * #### Example:\n *\n *     A.findOneAndReplace(filter, replacement, options)  // return Query\n *     A.findOneAndReplace(filter, replacement) // returns Query\n *     A.findOneAndReplace()                    // returns Query\n *\n * @param {Object} filter Replace the first document that matches this filter\n * @param {Object} [replacement] Replace with this document\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndReplace = function(filter, replacement, options) {\n  _checkContext(this, 'findOneAndReplace');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndReplace() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndReplace(filter, replacement, options);\n};\n\n/**\n * Issue a mongodb findAndModify remove command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndRemove()`\n *\n * #### Example:\n *\n *     A.findOneAndRemove(conditions, options)  // return Query\n *     A.findOneAndRemove(conditions) // returns Query\n *     A.findOneAndRemove()           // returns Query\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id);\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @return {Query}\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findOneAndRemove = function(conditions, options) {\n  _checkContext(this, 'findOneAndRemove');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndRemove() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndRemove(conditions, options);\n};\n\n/**\n * Issue a mongodb findAndModify remove command by a document's _id field. `findByIdAndRemove(id, ...)` is equivalent to `findOneAndRemove({ _id: id }, ...)`.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndRemove()`\n *\n * #### Example:\n *\n *     A.findByIdAndRemove(id, options)  // return Query\n *     A.findByIdAndRemove(id) // returns Query\n *     A.findByIdAndRemove()           // returns Query\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Object|String} [options.select] sets the document fields to return.\n * @return {Query}\n * @see Model.findOneAndRemove https://mongoosejs.com/docs/api/model.html#Model.findOneAndRemove()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n */\n\nModel.findByIdAndRemove = function(id, options) {\n  _checkContext(this, 'findByIdAndRemove');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findByIdAndRemove() no longer accepts a callback');\n  }\n\n  return this.findOneAndRemove({ _id: id }, options);\n};\n\n/**\n * Shortcut for saving one or more documents to the database.\n * `MyModel.create(docs)` does `new MyModel(doc).save()` for every doc in\n * docs.\n *\n * This function triggers the following middleware.\n *\n * - `save()`\n *\n * #### Example:\n *\n *     // Insert one new `Character` document\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     // Insert multiple new `Character` documents\n *     await Character.create([{ name: 'Will Riker' }, { name: 'Geordi LaForge' }]);\n *\n *     // Create a new character within a transaction. Note that you **must**\n *     // pass an array as the first parameter to `create()` if you want to\n *     // specify options.\n *     await Character.create([{ name: 'Jean-Luc Picard' }], { session });\n *\n * @param {Array|Object} docs Documents to insert, as a spread or array\n * @param {Object} [options] Options passed down to `save()`. To specify `options`, `docs` **must** be an array, not a spread. See [Model.save](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) for available options.\n * @return {Promise}\n * @api public\n */\n\nModel.create = async function create(doc, options) {\n  if (typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.create() no longer accepts a callback');\n  }\n\n  _checkContext(this, 'create');\n\n  let args;\n  const discriminatorKey = this.schema.options.discriminatorKey;\n\n  if (Array.isArray(doc)) {\n    args = doc;\n    options = options != null && typeof options === 'object' ? options : {};\n  } else {\n    const last = arguments[arguments.length - 1];\n    options = {};\n    if (typeof last === 'function' || (arguments.length > 1 && !last)) {\n      if (typeof options === 'function' ||\n          typeof arguments[2] === 'function') {\n        throw new MongooseError('Model.create() no longer accepts a callback');\n      }\n    } else {\n      args = [...arguments];\n    }\n\n    if (args.length === 2 &&\n        args[0] != null &&\n        args[1] != null &&\n        args[0].session == null &&\n        getConstructorName(last.session) === 'ClientSession' &&\n        !this.schema.path('session')) {\n      // Probably means the user is running into the common mistake of trying\n      // to use a spread to specify options, see gh-7535\n      utils.warn('WARNING: to pass a `session` to `Model.create()` in ' +\n        'Mongoose, you **must** pass an array as the first argument. See: ' +\n        'https://mongoosejs.com/docs/api/model.html#Model.create()');\n    }\n  }\n\n  if (args.length === 0) {\n    return Array.isArray(doc) ? [] : null;\n  }\n\n  const res = await Promise.all(args.map(async doc => {\n    const Model = this.discriminators && doc[discriminatorKey] != null ?\n      this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n      this;\n    if (Model == null) {\n      throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n        `found for model \"${this.modelName}\"`);\n    }\n    let toSave = doc;\n\n    if (!(toSave instanceof Model)) {\n      toSave = new Model(toSave);\n    }\n\n    await toSave.$save(options);\n\n    return toSave;\n  }));\n\n  if (!Array.isArray(doc) && args.length === 1) {\n    return res[0];\n  }\n\n  return res;\n};\n\n/**\n * _Requires a replica set running MongoDB >= 3.6.0._ Watches the\n * underlying collection for changes using\n * [MongoDB change streams](https://www.mongodb.com/docs/manual/changeStreams/).\n *\n * This function does **not** trigger any middleware. In particular, it\n * does **not** trigger aggregate middleware.\n *\n * The ChangeStream object is an event emitter that emits the following events:\n *\n * - 'change': A change occurred, see below example\n * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n * - 'end': Emitted if the underlying stream is closed\n * - 'close': Emitted if the underlying stream is closed\n *\n * #### Example:\n *\n *     const doc = await Person.create({ name: 'Ned Stark' });\n *     const changeStream = Person.watch().on('change', change => console.log(change));\n *     // Will print from the above `console.log()`:\n *     // { _id: { _data: ... },\n *     //   operationType: 'delete',\n *     //   ns: { db: 'mydb', coll: 'Person' },\n *     //   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }\n *     await doc.remove();\n *\n * @param {Array} [pipeline]\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#watch)\n * @param {Boolean} [options.hydrate=false] if true and `fullDocument: 'updateLookup'` is set, Mongoose will automatically hydrate `fullDocument` into a fully fledged Mongoose document\n * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter\n * @api public\n */\n\nModel.watch = function(pipeline, options) {\n  _checkContext(this, 'watch');\n\n  const changeStreamThunk = cb => {\n    pipeline = pipeline || [];\n    prepareDiscriminatorPipeline(pipeline, this.schema, 'fullDocument');\n    if (this.$__collection.buffer) {\n      this.$__collection.addQueue(() => {\n        if (this.closed) {\n          return;\n        }\n        const driverChangeStream = this.$__collection.watch(pipeline, options);\n        cb(null, driverChangeStream);\n      });\n    } else {\n      const driverChangeStream = this.$__collection.watch(pipeline, options);\n      cb(null, driverChangeStream);\n    }\n  };\n\n  options = options || {};\n  options.model = this;\n\n  return new ChangeStream(changeStreamThunk, pipeline, options);\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * Calling `MyModel.startSession()` is equivalent to calling `MyModel.db.startSession()`.\n *\n * This function does not trigger any middleware.\n *\n * #### Example:\n *\n *     const session = await Person.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.remove();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nModel.startSession = function() {\n  _checkContext(this, 'startSession');\n\n  return this.db.startSession.apply(this.db, arguments);\n};\n\n/**\n * Shortcut for validating an array of documents and inserting them into\n * MongoDB if they're all valid. This function is faster than `.create()`\n * because it only sends one operation to the server, rather than one for each\n * document.\n *\n * Mongoose always validates each document **before** sending `insertMany`\n * to MongoDB. So if one document has a validation error, no documents will\n * be saved, unless you set\n * [the `ordered` option to false](https://www.mongodb.com/docs/manual/reference/method/db.collection.insertMany/#error-handling).\n *\n * This function does **not** trigger save middleware.\n *\n * This function triggers the following middleware.\n *\n * - `insertMany()`\n *\n * #### Example:\n *\n *     const arr = [{ name: 'Star Wars' }, { name: 'The Empire Strikes Back' }];\n *     Movies.insertMany(arr, function(error, docs) {});\n *\n * @param {Array|Object|*} doc(s)\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#insertMany)\n * @param {Boolean} [options.ordered=true] if true, will fail fast on the first error encountered. If false, will insert all the documents it can and report errors later. An `insertMany()` with `ordered = false` is called an \"unordered\" `insertMany()`.\n * @param {Boolean} [options.rawResult=false] if false, the returned promise resolves to the documents that passed mongoose document validation. If `true`, will return the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/InsertManyResult.html) with a `mongoose` property that contains `validationErrors` and `results` if this is an unordered `insertMany`.\n * @param {Boolean} [options.lean=false] if `true`, skips hydrating and validating the documents. This option is useful if you need the extra performance, but Mongoose won't validate the documents before inserting.\n * @param {Number} [options.limit=null] this limits the number of documents being processed (validation/casting) by mongoose in parallel, this does **NOT** send the documents in batches to MongoDB. Use this option if you're processing a large number of documents and your app is running out of memory.\n * @param {String|Object|Array} [options.populate=null] populates the result documents. This option is a no-op if `rawResult` is set.\n * @return {Promise} resolving to the raw result from the MongoDB driver if `options.rawResult` was `true`, or the documents that passed validation, otherwise\n * @api public\n */\n\nModel.insertMany = async function insertMany(arr, options) {\n  _checkContext(this, 'insertMany');\n  if (typeof options === 'function' ||\n    typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.insertMany() no longer accepts a callback');\n  }\n\n  return new Promise((resolve, reject) => {\n    this.$__insertMany(arr, options, (err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * ignore\n *\n * @param {Array} arr\n * @param {Object} options\n * @param {Function} callback\n * @api private\n * @memberOf Model\n * @method $__insertMany\n * @static\n */\n\nModel.$__insertMany = function(arr, options, callback) {\n  const _this = this;\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  callback = callback || utils.noop;\n  options = options || {};\n  const limit = options.limit || 1000;\n  const rawResult = !!options.rawResult;\n  const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n  const lean = !!options.lean;\n\n  if (!Array.isArray(arr)) {\n    arr = [arr];\n  }\n\n  const validationErrors = [];\n  const validationErrorsToOriginalOrder = new Map();\n  const results = ordered ? null : new Array(arr.length);\n  const toExecute = arr.map((doc, index) =>\n    callback => {\n      if (!(doc instanceof _this)) {\n        try {\n          doc = new _this(doc);\n        } catch (err) {\n          return callback(err);\n        }\n      }\n      if (options.session != null) {\n        doc.$session(options.session);\n      }\n      // If option `lean` is set to true bypass validation\n      if (lean) {\n        // we have to execute callback at the nextTick to be compatible\n        // with parallelLimit, as `results` variable has TDZ issue if we\n        // execute the callback synchronously\n        return immediate(() => callback(null, doc));\n      }\n      doc.$validate().then(\n        () => { callback(null, doc); },\n        error => {\n          if (ordered === false) {\n            validationErrors.push(error);\n            validationErrorsToOriginalOrder.set(error, index);\n            results[index] = error;\n            return callback(null, null);\n          }\n          callback(error);\n        }\n      );\n    });\n\n  parallelLimit(toExecute, limit, function(error, docs) {\n    if (error) {\n      callback(error, null);\n      return;\n    }\n\n    const originalDocIndex = new Map();\n    const validDocIndexToOriginalIndex = new Map();\n    for (let i = 0; i < docs.length; ++i) {\n      originalDocIndex.set(docs[i], i);\n    }\n\n    // We filter all failed pre-validations by removing nulls\n    const docAttributes = docs.filter(function(doc) {\n      return doc != null;\n    });\n    for (let i = 0; i < docAttributes.length; ++i) {\n      validDocIndexToOriginalIndex.set(i, originalDocIndex.get(docAttributes[i]));\n    }\n\n    // Make sure validation errors are in the same order as the\n    // original documents, so if both doc1 and doc2 both fail validation,\n    // `Model.insertMany([doc1, doc2])` will always have doc1's validation\n    // error before doc2's. Re: gh-12791.\n    if (validationErrors.length > 0) {\n      validationErrors.sort((err1, err2) => {\n        return validationErrorsToOriginalOrder.get(err1) - validationErrorsToOriginalOrder.get(err2);\n      });\n    }\n\n    // Quickly escape while there aren't any valid docAttributes\n    if (docAttributes.length === 0) {\n      if (rawResult) {\n        const res = {\n          acknowledged: true,\n          insertedCount: 0,\n          insertedIds: {},\n          mongoose: {\n            validationErrors: validationErrors\n          }\n        };\n        return callback(null, res);\n      }\n      callback(null, []);\n      return;\n    }\n    const docObjects = docAttributes.map(function(doc) {\n      if (doc.$__schema.options.versionKey) {\n        doc[doc.$__schema.options.versionKey] = 0;\n      }\n      const shouldSetTimestamps = (!options || options.timestamps !== false) && doc.initializeTimestamps && (!doc.$__ || doc.$__.timestamps !== false);\n      if (shouldSetTimestamps) {\n        return doc.initializeTimestamps().toObject(internalToObjectOptions);\n      }\n      return doc.toObject(internalToObjectOptions);\n    });\n\n    _this.$__collection.insertMany(docObjects, options).then(\n      res => {\n        for (const attribute of docAttributes) {\n          attribute.$__reset();\n          _setIsNew(attribute, false);\n        }\n\n        if (rawResult) {\n          if (ordered === false) {\n            for (let i = 0; i < results.length; ++i) {\n              if (results[i] === void 0) {\n                results[i] = docs[i];\n              }\n            }\n\n            // Decorate with mongoose validation errors in case of unordered,\n            // because then still do `insertMany()`\n            res.mongoose = {\n              validationErrors: validationErrors,\n              results: results\n            };\n          }\n          return callback(null, res);\n        }\n\n        if (options.populate != null) {\n          return _this.populate(docAttributes, options.populate).then(\n            docs => { callback(null, docs); },\n            err => {\n              if (err != null) {\n                err.insertedDocs = docAttributes;\n              }\n              throw err;\n            }\n          );\n        }\n\n        callback(null, docAttributes);\n      },\n      error => {\n        // `writeErrors` is a property reported by the MongoDB driver,\n        // just not if there's only 1 error.\n        if (error.writeErrors == null &&\n            (error.result && error.result.result && error.result.result.writeErrors) != null) {\n          error.writeErrors = error.result.result.writeErrors;\n        }\n\n        // `insertedDocs` is a Mongoose-specific property\n        const erroredIndexes = new Set((error && error.writeErrors || []).map(err => err.index));\n\n        for (let i = 0; i < error.writeErrors.length; ++i) {\n          const originalIndex = validDocIndexToOriginalIndex.get(error.writeErrors[i].index);\n          error.writeErrors[i] = {\n            ...error.writeErrors[i],\n            index: originalIndex\n          };\n          if (!ordered) {\n            results[originalIndex] = error.writeErrors[i];\n          }\n        }\n\n        if (!ordered) {\n          for (let i = 0; i < results.length; ++i) {\n            if (results[i] === void 0) {\n              results[i] = docs[i];\n            }\n          }\n\n          error.results = results;\n        }\n\n        let firstErroredIndex = -1;\n        error.insertedDocs = docAttributes.\n          filter((doc, i) => {\n            const isErrored = erroredIndexes.has(i);\n\n            if (ordered) {\n              if (firstErroredIndex > -1) {\n                return i < firstErroredIndex;\n              }\n\n              if (isErrored) {\n                firstErroredIndex = i;\n              }\n            }\n\n            return !isErrored;\n          }).\n          map(function setIsNewForInsertedDoc(doc) {\n            doc.$__reset();\n            _setIsNew(doc, false);\n            return doc;\n          });\n\n        if (rawResult && ordered === false) {\n          error.mongoose = {\n            validationErrors: validationErrors,\n            results: results\n          };\n        }\n\n        callback(error, null);\n      }\n    );\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction _setIsNew(doc, val) {\n  doc.$isNew = val;\n  doc.$emit('isNew', val);\n  doc.constructor.emit('isNew', val);\n\n  const subdocs = doc.$getAllSubdocs();\n  for (const subdoc of subdocs) {\n    subdoc.$isNew = val;\n    subdoc.$emit('isNew', val);\n  }\n}\n\n/**\n * Sends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`,\n * `deleteOne`, and/or `deleteMany` operations to the MongoDB server in one\n * command. This is faster than sending multiple independent operations (e.g.\n * if you use `create()`) because with `bulkWrite()` there is only one round\n * trip to MongoDB.\n *\n * Mongoose will perform casting on all operations you provide.\n *\n * This function does **not** trigger any middleware, neither `save()`, nor `update()`.\n * If you need to trigger\n * `save()` middleware for every document use [`create()`](https://mongoosejs.com/docs/api/model.html#Model.create()) instead.\n *\n * #### Example:\n *\n *     Character.bulkWrite([\n *       {\n *         insertOne: {\n *           document: {\n *             name: 'Eddard Stark',\n *             title: 'Warden of the North'\n *           }\n *         }\n *       },\n *       {\n *         updateOne: {\n *           filter: { name: 'Eddard Stark' },\n *           // If you were using the MongoDB driver directly, you'd need to do\n *           // `update: { $set: { title: ... } }` but mongoose adds $set for\n *           // you.\n *           update: { title: 'Hand of the King' }\n *         }\n *       },\n *       {\n *         deleteOne: {\n *           filter: { name: 'Eddard Stark' }\n *         }\n *       }\n *     ]).then(res => {\n *      // Prints \"1 1 1\"\n *      console.log(res.insertedCount, res.modifiedCount, res.deletedCount);\n *     });\n *\n * The [supported operations](https://www.mongodb.com/docs/manual/reference/method/db.collection.bulkWrite/#db.collection.bulkWrite) are:\n *\n * - `insertOne`\n * - `updateOne`\n * - `updateMany`\n * - `deleteOne`\n * - `deleteMany`\n * - `replaceOne`\n *\n * @param {Array} ops\n * @param {Object} [ops.insertOne.document] The document to insert\n * @param {Object} [ops.updateOne.filter] Update the first document that matches this filter\n * @param {Object} [ops.updateOne.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateOne.upsert=false] If true, insert a doc if none match\n * @param {Boolean} [ops.updateOne.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateOne.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateOne.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.updateMany.filter] Update all the documents that match this filter\n * @param {Object} [ops.updateMany.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateMany.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Boolean} [ops.updateMany.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateMany.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateMany.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.deleteOne.filter] Delete the first document that matches this filter\n * @param {Object} [ops.deleteMany.filter] Delete all documents that match this filter\n * @param {Object} [ops.replaceOne.filter] Replace the first document that matches this filter\n * @param {Object} [ops.replaceOne.replacement] The replacement document\n * @param {Boolean} [ops.replaceOne.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Object} [options]\n * @param {Boolean} [options.ordered=true] If true, execute writes in order and stop at the first error. If false, execute writes in parallel and continue until all writes have either succeeded or errored.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n * @param {Boolean} [options.skipValidation=false] Set to true to skip Mongoose schema validation on bulk write operations. Mongoose currently runs validation on `insertOne` and `replaceOne` operations by default.\n * @param {Boolean} [options.bypassDocumentValidation=false] If true, disable [MongoDB server-side schema validation](https://www.mongodb.com/docs/manual/core/schema-validation/) for all writes in this bulk.\n * @param {Boolean} [options.strict=null] Overwrites the [`strict` option](https://mongoosejs.com/docs/guide.html#strict) on schema. If false, allows filtering and writing fields not defined in the schema for all writes in this bulk.\n * @return {Promise} resolves to a [`BulkWriteOpResult`](https://mongodb.github.io/node-mongodb-native/4.9/classes/BulkWriteResult.html) if the operation succeeds\n * @api public\n */\n\nModel.bulkWrite = async function bulkWrite(ops, options) {\n  _checkContext(this, 'bulkWrite');\n\n  if (typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.bulkWrite() no longer accepts a callback');\n  }\n  options = options || {};\n  const ordered = options.ordered == null ? true : options.ordered;\n\n  const validations = ops.map(op => castBulkWrite(this, op, options));\n\n  return new Promise((resolve, reject) => {\n    if (ordered) {\n      each(validations, (fn, cb) => fn(cb), error => {\n        if (error) {\n          return reject(error);\n        }\n\n        if (ops.length === 0) {\n          return resolve(getDefaultBulkwriteResult());\n        }\n\n        try {\n          this.$__collection.bulkWrite(ops, options, (error, res) => {\n            if (error) {\n              return reject(error);\n            }\n\n            resolve(res);\n          });\n        } catch (err) {\n          return reject(err);\n        }\n      });\n\n      return;\n    }\n\n    let remaining = validations.length;\n    let validOps = [];\n    let validationErrors = [];\n    for (let i = 0; i < validations.length; ++i) {\n      validations[i]((err) => {\n        if (err == null) {\n          validOps.push(i);\n        } else {\n          validationErrors.push({ index: i, error: err });\n        }\n        if (--remaining <= 0) {\n          completeUnorderedValidation.call(this);\n        }\n      });\n    }\n\n    validationErrors = validationErrors.\n      sort((v1, v2) => v1.index - v2.index).\n      map(v => v.error);\n\n    function completeUnorderedValidation() {\n      validOps = validOps.sort().map(index => ops[index]);\n\n      this.$__collection.bulkWrite(validOps, options, (error, res) => {\n        if (error) {\n          if (validationErrors.length > 0) {\n            error.mongoose = error.mongoose || {};\n            error.mongoose.validationErrors = validationErrors;\n          }\n\n          return reject(error);\n        }\n\n        if (validationErrors.length > 0) {\n          res.mongoose = res.mongoose || {};\n          res.mongoose.validationErrors = validationErrors;\n        }\n\n        resolve(res);\n      });\n    }\n  });\n};\n\n/**\n *  takes an array of documents, gets the changes and inserts/updates documents in the database\n *  according to whether or not the document is new, or whether it has changes or not.\n *\n * `bulkSave` uses `bulkWrite` under the hood, so it's mostly useful when dealing with many documents (10K+)\n *\n * @param {Array<Document>} documents\n * @param {Object} [options] options passed to the underlying `bulkWrite()`\n * @param {Boolean} [options.timestamps] defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n *\n */\nModel.bulkSave = async function(documents, options) {\n  options = options || {};\n\n  const writeOperations = this.buildBulkWriteOperations(documents, { skipValidation: true, timestamps: options.timestamps });\n\n  if (options.timestamps != null) {\n    for (const document of documents) {\n      document.$__.saveOptions = document.$__.saveOptions || {};\n      document.$__.saveOptions.timestamps = options.timestamps;\n    }\n  } else {\n    for (const document of documents) {\n      if (document.$__.timestamps != null) {\n        document.$__.saveOptions = document.$__.saveOptions || {};\n        document.$__.saveOptions.timestamps = document.$__.timestamps;\n      }\n    }\n  }\n\n  await Promise.all(documents.map(buildPreSavePromise));\n\n  const { bulkWriteResult, bulkWriteError } = await this.bulkWrite(writeOperations, options).then(\n    (res) => ({ bulkWriteResult: res, bulkWriteError: null }),\n    (err) => ({ bulkWriteResult: null, bulkWriteError: err })\n  );\n\n  await Promise.all(\n    documents.map(async(document) => {\n      const documentError = bulkWriteError && bulkWriteError.writeErrors.find(writeError => {\n        const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;\n        return writeErrorDocumentId.toString() === document._id.toString();\n      });\n\n      if (documentError == null) {\n        await handleSuccessfulWrite(document);\n      }\n    })\n  );\n\n  if (bulkWriteError && bulkWriteError.writeErrors && bulkWriteError.writeErrors.length) {\n    throw bulkWriteError;\n  }\n\n  return bulkWriteResult;\n};\n\nfunction buildPreSavePromise(document) {\n  return new Promise((resolve, reject) => {\n    document.schema.s.hooks.execPre('save', document, (err) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve();\n    });\n  });\n}\n\nfunction handleSuccessfulWrite(document) {\n  return new Promise((resolve, reject) => {\n    if (document.$isNew) {\n      _setIsNew(document, false);\n    }\n\n    document.$__reset();\n    document.schema.s.hooks.execPost('save', document, [document], {}, (err) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve();\n    });\n\n  });\n}\n\n/**\n * Apply defaults to the given document or POJO.\n *\n * @param {Object|Document} obj object or document to apply defaults on\n * @returns {Object|Document}\n * @api public\n */\n\nModel.applyDefaults = function applyDefaults(doc) {\n  if (doc.$__ != null) {\n    applyDefaultsHelper(doc, doc.$__.fields, doc.$__.exclude);\n\n    for (const subdoc of doc.$getAllSubdocs()) {\n      applyDefaults(subdoc, subdoc.$__.fields, subdoc.$__.exclude);\n    }\n\n    return doc;\n  }\n\n  applyDefaultsToPOJO(doc, this.schema);\n\n  return doc;\n};\n\n/**\n * Cast the given POJO to the model's schema\n *\n * #### Example:\n *\n *     const Test = mongoose.model('Test', Schema({ num: Number }));\n *\n *     const obj = Test.castObject({ num: '42' });\n *     obj.num; // 42 as a number\n *\n *     Test.castObject({ num: 'not a number' }); // Throws a ValidationError\n *\n * @param {Object} obj object or document to cast\n * @param {Object} options options passed to castObject\n * @param {Boolean} options.ignoreCastErrors If set to `true` will not throw a ValidationError and only return values that were successfully cast.\n * @returns {Object} POJO casted to the model's schema\n * @throws {ValidationError} if casting failed for at least one path\n * @api public\n */\n\nModel.castObject = function castObject(obj, options) {\n  options = options || {};\n  const ret = {};\n\n  const schema = this.schema;\n  const paths = Object.keys(schema.paths);\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType || !schemaType.$isMongooseArray) {\n      continue;\n    }\n\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n\n  let error = null;\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (schemaType == null) {\n      continue;\n    }\n\n    let val = get(obj, path, void 0);\n\n    if (val == null) {\n      continue;\n    }\n\n    const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = ret;\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      if (cur[pieces[i]] == null) {\n        cur[pieces[i]] = isNaN(pieces[i + 1]) ? {} : [];\n      }\n      cur = cur[pieces[i]];\n    }\n\n    if (schemaType.$isMongooseDocumentArray) {\n      continue;\n    }\n    if (schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) {\n      try {\n        val = Model.castObject.call(schemaType.caster, val);\n      } catch (err) {\n        if (!options.ignoreCastErrors) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n        }\n        continue;\n      }\n\n      cur[pieces[pieces.length - 1]] = val;\n      continue;\n    }\n\n    try {\n      val = schemaType.cast(val);\n      cur[pieces[pieces.length - 1]] = val;\n    } catch (err) {\n      if (!options.ignoreCastErrors) {\n        error = error || new ValidationError();\n        error.addError(path, err);\n      }\n\n      continue;\n    }\n  }\n\n  if (error != null) {\n    throw error;\n  }\n\n  return ret;\n};\n\n/**\n * Build bulk write operations for `bulkSave()`.\n *\n * @param {Array<Document>} documents The array of documents to build write operations of\n * @param {Object} options\n * @param {Boolean} options.skipValidation defaults to `false`, when set to true, building the write operations will bypass validating the documents.\n * @param {Boolean} options.timestamps defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @return {Array<Promise>} Returns a array of all Promises the function executes to be awaited.\n * @api private\n */\n\nModel.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {\n  if (!Array.isArray(documents)) {\n    throw new Error(`bulkSave expects an array of documents to be passed, received \\`${documents}\\` instead`);\n  }\n\n  setDefaultOptions();\n\n  const writeOperations = documents.reduce((accumulator, document, i) => {\n    if (!options.skipValidation) {\n      if (!(document instanceof Document)) {\n        throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);\n      }\n      const validationError = document.validateSync();\n      if (validationError) {\n        throw validationError;\n      }\n    }\n\n    const isANewDocument = document.isNew;\n    if (isANewDocument) {\n      const writeOperation = { insertOne: { document } };\n      utils.injectTimestampsOption(writeOperation.insertOne, options.timestamps);\n      accumulator.push(writeOperation);\n\n      return accumulator;\n    }\n\n    const delta = document.$__delta();\n    const isDocumentWithChanges = delta != null && !utils.isEmptyObject(delta[0]);\n\n    if (isDocumentWithChanges) {\n      const where = document.$__where(delta[0]);\n      const changes = delta[1];\n\n      _applyCustomWhere(document, where);\n\n      document.$__version(where, delta);\n      const writeOperation = { updateOne: { filter: where, update: changes } };\n      utils.injectTimestampsOption(writeOperation.updateOne, options.timestamps);\n      accumulator.push(writeOperation);\n\n      return accumulator;\n    }\n\n    return accumulator;\n  }, []);\n\n  return writeOperations;\n\n\n  function setDefaultOptions() {\n    options = options || {};\n    if (options.skipValidation == null) {\n      options.skipValidation = false;\n    }\n  }\n};\n\n\n/**\n * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.\n * The document returned has no paths marked as modified initially.\n *\n * #### Example:\n *\n *     // hydrate previous data into a Mongoose document\n *     const mongooseCandy = Candy.hydrate({ _id: '54108337212ffb6d459f854c', type: 'jelly bean' });\n *\n * @param {Object} obj\n * @param {Object|String|String[]} [projection] optional projection containing which fields should be selected for this document\n * @param {Object} [options] optional options\n * @param {Boolean} [options.setters=false] if true, apply schema setters when hydrating\n * @return {Document} document instance\n * @api public\n */\n\nModel.hydrate = function(obj, projection, options) {\n  _checkContext(this, 'hydrate');\n\n  if (projection != null) {\n    if (obj != null && obj.$__ != null) {\n      obj = obj.toObject(internalToObjectOptions);\n    }\n    obj = applyProjection(obj, projection);\n  }\n\n  const document = require('./queryhelpers').createModel(this, obj, projection);\n  document.$init(obj, options);\n  return document;\n};\n\n/**\n * Same as `updateOne()`, except MongoDB will update _all_ documents that match\n * `filter` (as opposed to just the first one) regardless of the value of\n * the `multi` option.\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `updateMany()`\n *\n * @param {Object} filter\n * @param {Object|Array} update\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateMany = function updateMany(conditions, doc, options) {\n  _checkContext(this, 'updateMany');\n\n  return _update(this, 'updateMany', conditions, doc, options);\n};\n\n/**\n * Update _only_ the first document that matches `filter`.\n *\n * - Use `replaceOne()` if you want to overwrite an entire document rather than using atomic operators like `$set`.\n *\n * #### Example:\n *\n *     const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `updateOne()`\n *\n * @param {Object} filter\n * @param {Object|Array} update\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateOne = function updateOne(conditions, doc, options) {\n  _checkContext(this, 'updateOne');\n\n  return _update(this, 'updateOne', conditions, doc, options);\n};\n\n/**\n * Replace the existing document with the given document (no atomic operators like `$set`).\n *\n * #### Example:\n *\n *     const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `replaceOne()`\n *\n * @param {Object} filter\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @return {Query}\n * @api public\n */\n\nModel.replaceOne = function replaceOne(conditions, doc, options) {\n  _checkContext(this, 'replaceOne');\n\n  const versionKey = this && this.schema && this.schema.options && this.schema.options.versionKey || null;\n  if (versionKey && !doc[versionKey]) {\n    doc[versionKey] = 0;\n  }\n\n  return _update(this, 'replaceOne', conditions, doc, options);\n};\n\n/**\n * Common code for `updateOne()`, `updateMany()`, `replaceOne()`, and `update()`\n * because they need to do the same thing\n * @api private\n */\n\nfunction _update(model, op, conditions, doc, options) {\n  const mq = new model.Query({}, {}, model, model.collection);\n\n  // gh-2406\n  // make local deep copy of conditions\n  if (conditions instanceof Document) {\n    conditions = conditions.toObject();\n  } else {\n    conditions = clone(conditions);\n  }\n  options = typeof options === 'function' ? options : clone(options);\n\n  const versionKey = model &&\n  model.schema &&\n  model.schema.options &&\n  model.schema.options.versionKey || null;\n  _decorateUpdateWithVersionKey(doc, options, versionKey);\n\n  return mq[op](conditions, doc, options);\n}\n\n/**\n * Performs [aggregations](https://www.mongodb.com/docs/manual/aggregation/) on the models collection.\n *\n * If a `callback` is passed, the `aggregate` is executed and a `Promise` is returned. If a callback is not passed, the `aggregate` itself is returned.\n *\n * This function triggers the following middleware.\n *\n * - `aggregate()`\n *\n * #### Example:\n *\n *     // Find the max balance of all accounts\n *     const res = await Users.aggregate([\n *       { $group: { _id: null, maxBalance: { $max: '$balance' }}},\n *       { $project: { _id: 0, maxBalance: 1 }}\n *     ]);\n *\n *     console.log(res); // [ { maxBalance: 98000 } ]\n *\n *     // Or use the aggregation pipeline builder.\n *     const res = await Users.aggregate().\n *       group({ _id: null, maxBalance: { $max: '$balance' } }).\n *       project('-id maxBalance').\n *       exec();\n *     console.log(res); // [ { maxBalance: 98 } ]\n *\n * #### Note:\n *\n * - Mongoose does **not** cast aggregation pipelines to the model's schema because `$project` and `$group` operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format. You can use the [mongoose-cast-aggregation plugin](https://github.com/AbdelrahmanHafez/mongoose-cast-aggregation) to enable minimal casting for aggregation pipelines.\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n *\n * #### More About Aggregations:\n *\n * - [Mongoose `Aggregate`](https://mongoosejs.com/docs/api/aggregate.html)\n * - [An Introduction to Mongoose Aggregate](https://masteringjs.io/tutorials/mongoose/aggregate)\n * - [MongoDB Aggregation docs](https://www.mongodb.com/docs/manual/applications/aggregation/)\n *\n * @see Aggregate https://mongoosejs.com/docs/api/aggregate.html#Aggregate()\n * @see MongoDB https://www.mongodb.com/docs/manual/applications/aggregation/\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @param {Object} [options] aggregation options\n * @return {Aggregate}\n * @api public\n */\n\nModel.aggregate = function aggregate(pipeline, options) {\n  _checkContext(this, 'aggregate');\n\n  if (typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.aggregate() no longer accepts a callback');\n  }\n\n  const aggregate = new Aggregate(pipeline || []);\n  aggregate.model(this);\n  if (options != null) {\n    aggregate.option(options);\n  }\n\n  if (typeof callback === 'undefined') {\n    return aggregate;\n  }\n\n  return aggregate;\n};\n\n/**\n * Casts and validates the given object against this model's schema, passing the\n * given `context` to custom validators.\n *\n * #### Example:\n *\n *     const Model = mongoose.model('Test', Schema({\n *       name: { type: String, required: true },\n *       age: { type: Number, required: true }\n *     });\n *\n *     try {\n *       await Model.validate({ name: null }, ['name'])\n *     } catch (err) {\n *       err instanceof mongoose.Error.ValidationError; // true\n *       Object.keys(err.errors); // ['name']\n *     }\n *\n * @param {Object} obj\n * @param {Array|String} pathsToValidate\n * @param {Object} [context]\n * @return {Promise|undefined}\n * @api public\n */\n\nModel.validate = async function validate(obj, pathsToValidate, context) {\n  if ((arguments.length < 3) || (arguments.length === 3 && typeof arguments[2] === 'function')) {\n    // For convenience, if we're validating a document or an object, make `context` default to\n    // the model so users don't have to always pass `context`, re: gh-10132, gh-10346\n    context = obj;\n  }\n  if (typeof context === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.validate() no longer accepts a callback');\n  }\n\n  let schema = this.schema;\n  const discriminatorKey = schema.options.discriminatorKey;\n  if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;\n  }\n  let paths = Object.keys(schema.paths);\n\n  if (pathsToValidate != null) {\n    const _pathsToValidate = typeof pathsToValidate === 'string' ? new Set(pathsToValidate.split(' ')) : new Set(pathsToValidate);\n    paths = paths.filter(p => {\n      const pieces = p.split('.');\n      let cur = pieces[0];\n\n      for (const piece of pieces) {\n        if (_pathsToValidate.has(cur)) {\n          return true;\n        }\n        cur += '.' + piece;\n      }\n\n      return _pathsToValidate.has(p);\n    });\n  }\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType || !schemaType.$isMongooseArray || schemaType.$isMongooseDocumentArray) {\n      continue;\n    }\n\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n\n  let remaining = paths.length;\n  let error = null;\n\n  return new Promise((resolve, reject) => {\n    for (const path of paths) {\n      const schemaType = schema.path(path);\n      if (schemaType == null) {\n        _checkDone();\n        continue;\n      }\n\n      const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n      let cur = obj;\n      for (let i = 0; i < pieces.length - 1; ++i) {\n        cur = cur[pieces[i]];\n      }\n\n      let val = get(obj, path, void 0);\n\n      if (val != null) {\n        try {\n          val = schemaType.cast(val);\n          cur[pieces[pieces.length - 1]] = val;\n        } catch (err) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n\n          _checkDone();\n          continue;\n        }\n      }\n\n      schemaType.doValidate(val, err => {\n        if (err) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n        }\n        _checkDone();\n      }, context, { path: path });\n    }\n\n    function _checkDone() {\n      if (--remaining <= 0) {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      }\n    }\n  });\n};\n\n/**\n * Populates document references.\n *\n * Changed in Mongoose 6: the model you call `populate()` on should be the\n * \"local field\" model, **not** the \"foreign field\" model.\n *\n * #### Available top-level options:\n *\n * - path: space delimited path(s) to populate\n * - select: optional fields to select\n * - match: optional query conditions to match\n * - model: optional name of the model to use for population\n * - options: optional query options like sort, limit, etc\n * - justOne: optional boolean, if true Mongoose will always set `path` to a document, or `null` if no document was found. If false, Mongoose will always set `path` to an array, which will be empty if no documents are found. Inferred from schema by default.\n * - strictPopulate: optional boolean, set to `false` to allow populating paths that aren't in the schema.\n *\n * #### Example:\n *\n *     const Dog = mongoose.model('Dog', new Schema({ name: String, breed: String }));\n *     const Person = mongoose.model('Person', new Schema({\n *       name: String,\n *       pet: { type: mongoose.ObjectId, ref: 'Dog' }\n *     }));\n *\n *     const pets = await Pet.create([\n *       { name: 'Daisy', breed: 'Beagle' },\n *       { name: 'Einstein', breed: 'Catalan Sheepdog' }\n *     ]);\n *\n *     // populate many plain objects\n *     const users = [\n *       { name: 'John Wick', dog: pets[0]._id },\n *       { name: 'Doc Brown', dog: pets[1]._id }\n *     ];\n *     await User.populate(users, { path: 'dog', select: 'name' });\n *     users[0].dog.name; // 'Daisy'\n *     users[0].dog.breed; // undefined because of `select`\n *\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object|String} options Either the paths to populate or an object specifying all parameters\n * @param {string} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](https://mongoosejs.com/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] By default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] If true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Boolean} [options.skipInvalidIds=false] By default, Mongoose throws a cast error if `localField` and `foreignField` schemas don't line up. If you enable this option, Mongoose will instead filter out any `localField` properties that cannot be casted to `foreignField`'s schema type.\n * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\n * @param {Boolean} [options.strictPopulate=true] Set to false to allow populating paths that aren't defined in the given model's schema.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Function} [callback(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n * @return {Promise}\n * @api public\n */\n\nModel.populate = async function populate(docs, paths) {\n  _checkContext(this, 'populate');\n  if (typeof paths === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.populate() no longer accepts a callback');\n  }\n\n  const _this = this;\n\n  // normalized paths\n  paths = utils.populate(paths);\n  // data that should persist across subPopulate calls\n  const cache = {};\n\n  return new Promise((resolve, reject) => {\n    _populate(_this, docs, paths, cache, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Populate helper\n *\n * @param {Model} model the model to use\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object} paths\n * @param {never} cache Unused\n * @param {Function} [callback] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n * @return {Function}\n * @api private\n */\n\nfunction _populate(model, docs, paths, cache, callback) {\n  let pending = paths.length;\n  if (paths.length === 0) {\n    return callback(null, docs);\n  }\n  // each path has its own query options and must be executed separately\n  for (const path of paths) {\n    populate(model, docs, path, next);\n  }\n\n  function next(err) {\n    if (err) {\n      return callback(err, null);\n    }\n    if (--pending) {\n      return;\n    }\n    callback(null, docs);\n  }\n}\n\n/*!\n * Populates `docs`\n */\nconst excludeIdReg = /\\s?-_id\\s?/;\nconst excludeIdRegGlobal = /\\s?-_id\\s?/g;\n\nfunction populate(model, docs, options, callback) {\n  const populateOptions = { ...options };\n  if (options.strictPopulate == null) {\n    if (options._localModel != null && options._localModel.schema._userProvidedOptions.strictPopulate != null) {\n      populateOptions.strictPopulate = options._localModel.schema._userProvidedOptions.strictPopulate;\n    } else if (options._localModel != null && model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    } else if (model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    }\n  }\n\n  // normalize single / multiple docs passed\n  if (!Array.isArray(docs)) {\n    docs = [docs];\n  }\n  if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {\n    return callback();\n  }\n\n  const modelsMap = getModelsMapForPopulate(model, docs, populateOptions);\n\n  if (modelsMap instanceof MongooseError) {\n    return immediate(function() {\n      callback(modelsMap);\n    });\n  }\n  const len = modelsMap.length;\n  let vals = [];\n\n  function flatten(item) {\n    // no need to include undefined values in our query\n    return undefined !== item;\n  }\n\n  let _remaining = len;\n  let hasOne = false;\n  const params = [];\n  for (let i = 0; i < len; ++i) {\n    const mod = modelsMap[i];\n    let select = mod.options.select;\n    let ids = utils.array.flatten(mod.ids, flatten);\n    ids = utils.array.unique(ids);\n\n    const assignmentOpts = {};\n    assignmentOpts.sort = mod &&\n      mod.options &&\n      mod.options.options &&\n      mod.options.options.sort || void 0;\n    assignmentOpts.excludeId = excludeIdReg.test(select) || (select && select._id === 0);\n\n    // Lean transform may delete `_id`, which would cause assignment\n    // to fail. So delay running lean transform until _after_\n    // `_assign()`\n    if (mod.options &&\n        mod.options.options &&\n        mod.options.options.lean &&\n        mod.options.options.lean.transform) {\n      mod.options.options._leanTransform = mod.options.options.lean.transform;\n      mod.options.options.lean = true;\n    }\n\n    if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {\n      // Ensure that we set to 0 or empty array even\n      // if we don't actually execute a query to make sure there's a value\n      // and we know this path was populated for future sets. See gh-7731, gh-8230\n      --_remaining;\n      _assign(model, [], mod, assignmentOpts);\n      continue;\n    }\n\n    hasOne = true;\n    if (typeof populateOptions.foreignField === 'string') {\n      mod.foreignField.clear();\n      mod.foreignField.add(populateOptions.foreignField);\n    }\n    const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);\n    if (assignmentOpts.excludeId) {\n      // override the exclusion from the query so we can use the _id\n      // for document matching during assignment. we'll delete the\n      // _id back off before returning the result.\n      if (typeof select === 'string') {\n        select = select.replace(excludeIdRegGlobal, ' ');\n      } else {\n        // preserve original select conditions by copying\n        select = utils.object.shallowCopy(select);\n        delete select._id;\n      }\n    }\n\n    if (mod.options.options && mod.options.options.limit != null) {\n      assignmentOpts.originalLimit = mod.options.options.limit;\n    } else if (mod.options.limit != null) {\n      assignmentOpts.originalLimit = mod.options.limit;\n    }\n    params.push([mod, match, select, assignmentOpts, _next]);\n  }\n  if (!hasOne) {\n    // If models but no docs, skip further deep populate.\n    if (modelsMap.length !== 0) {\n      return callback();\n    }\n    // If no models to populate but we have a nested populate,\n    // keep trying, re: gh-8946\n    if (populateOptions.populate != null) {\n      const opts = utils.populate(populateOptions.populate).map(pop => Object.assign({}, pop, {\n        path: populateOptions.path + '.' + pop.path\n      }));\n      model.populate(docs, opts).then(res => { callback(null, res); }, err => { callback(err); });\n      return;\n    }\n    return callback();\n  }\n\n  for (const arr of params) {\n    _execPopulateQuery.apply(null, arr);\n  }\n  function _next(err, valsFromDb) {\n    if (err != null) {\n      return callback(err, null);\n    }\n    vals = vals.concat(valsFromDb);\n    if (--_remaining === 0) {\n      _done();\n    }\n  }\n\n  function _done() {\n    for (const arr of params) {\n      const mod = arr[0];\n      const assignmentOpts = arr[3];\n      for (const val of vals) {\n        mod.options._childDocs.push(val);\n      }\n      try {\n        _assign(model, vals, mod, assignmentOpts);\n      } catch (err) {\n        return callback(err);\n      }\n    }\n\n    for (const arr of params) {\n      removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);\n    }\n    for (const arr of params) {\n      const mod = arr[0];\n      if (mod.options && mod.options.options && mod.options.options._leanTransform) {\n        for (const doc of vals) {\n          mod.options.options._leanTransform(doc);\n        }\n      }\n    }\n    callback();\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _execPopulateQuery(mod, match, select, assignmentOpts, callback) {\n  let subPopulate = clone(mod.options.populate);\n  const queryOptions = Object.assign({\n    skip: mod.options.skip,\n    limit: mod.options.limit,\n    perDocumentLimit: mod.options.perDocumentLimit\n  }, mod.options.options);\n\n  if (mod.count) {\n    delete queryOptions.skip;\n  }\n\n  if (queryOptions.perDocumentLimit != null) {\n    queryOptions.limit = queryOptions.perDocumentLimit;\n    delete queryOptions.perDocumentLimit;\n  } else if (queryOptions.limit != null) {\n    queryOptions.limit = queryOptions.limit * mod.ids.length;\n  }\n\n  const query = mod.model.find(match, select, queryOptions);\n  // If we're doing virtual populate and projection is inclusive and foreign\n  // field is not selected, automatically select it because mongoose needs it.\n  // If projection is exclusive and client explicitly unselected the foreign\n  // field, that's the client's fault.\n  for (const foreignField of mod.foreignField) {\n    if (foreignField !== '_id' &&\n        query.selectedInclusively() &&\n        !isPathSelectedInclusive(query._fields, foreignField)) {\n      query.select(foreignField);\n    }\n  }\n\n  // If using count, still need the `foreignField` so we can match counts\n  // to documents, otherwise we would need a separate `count()` for every doc.\n  if (mod.count) {\n    for (const foreignField of mod.foreignField) {\n      query.select(foreignField);\n    }\n  }\n\n  // If we need to sub-populate, call populate recursively\n  if (subPopulate) {\n    // If subpopulating on a discriminator, skip check for non-existent\n    // paths. Because the discriminator may not have the path defined.\n    if (mod.model.baseModelName != null) {\n      if (Array.isArray(subPopulate)) {\n        subPopulate.forEach(pop => { pop.strictPopulate = false; });\n      } else if (typeof subPopulate === 'string') {\n        subPopulate = { path: subPopulate, strictPopulate: false };\n      } else {\n        subPopulate.strictPopulate = false;\n      }\n    }\n    const basePath = mod.options._fullPath || mod.options.path;\n\n    if (Array.isArray(subPopulate)) {\n      for (const pop of subPopulate) {\n        pop._fullPath = basePath + '.' + pop.path;\n      }\n    } else if (typeof subPopulate === 'object') {\n      subPopulate._fullPath = basePath + '.' + subPopulate.path;\n    }\n\n    query.populate(subPopulate);\n  }\n\n  query.exec().then(\n    docs => {\n      for (const val of docs) {\n        leanPopulateMap.set(val, mod.model);\n      }\n      callback(null, docs);\n    },\n    err => {\n      callback(err);\n    }\n  );\n}\n\n/*!\n * ignore\n */\n\nfunction _assign(model, vals, mod, assignmentOpts) {\n  const options = mod.options;\n  const isVirtual = mod.isVirtual;\n  const justOne = mod.justOne;\n  let _val;\n  const lean = options &&\n    options.options &&\n    options.options.lean || false;\n  const len = vals.length;\n  const rawOrder = {};\n  const rawDocs = {};\n  let key;\n  let val;\n\n  // Clone because `assignRawDocsToIdStructure` will mutate the array\n  const allIds = clone(mod.allIds);\n  // optimization:\n  // record the document positions as returned by\n  // the query result.\n  for (let i = 0; i < len; i++) {\n    val = vals[i];\n    if (val == null) {\n      continue;\n    }\n    for (const foreignField of mod.foreignField) {\n      _val = utils.getValue(foreignField, val);\n      if (Array.isArray(_val)) {\n        _val = utils.array.unique(utils.array.flatten(_val));\n\n        for (let __val of _val) {\n          if (__val instanceof Document) {\n            __val = __val._id;\n          }\n          key = String(__val);\n          if (rawDocs[key]) {\n            if (Array.isArray(rawDocs[key])) {\n              rawDocs[key].push(val);\n              rawOrder[key].push(i);\n            } else {\n              rawDocs[key] = [rawDocs[key], val];\n              rawOrder[key] = [rawOrder[key], i];\n            }\n          } else {\n            if (isVirtual && !justOne) {\n              rawDocs[key] = [val];\n              rawOrder[key] = [i];\n            } else {\n              rawDocs[key] = val;\n              rawOrder[key] = i;\n            }\n          }\n        }\n      } else {\n        if (_val instanceof Document) {\n          _val = _val._id;\n        }\n        key = String(_val);\n        if (rawDocs[key]) {\n          if (Array.isArray(rawDocs[key])) {\n            rawDocs[key].push(val);\n            rawOrder[key].push(i);\n          } else if (isVirtual ||\n            rawDocs[key].constructor !== val.constructor ||\n            String(rawDocs[key]._id) !== String(val._id)) {\n            // May need to store multiple docs with the same id if there's multiple models\n            // if we have discriminators or a ref function. But avoid converting to an array\n            // if we have multiple queries on the same model because of `perDocumentLimit` re: gh-9906\n            rawDocs[key] = [rawDocs[key], val];\n            rawOrder[key] = [rawOrder[key], i];\n          }\n        } else {\n          rawDocs[key] = val;\n          rawOrder[key] = i;\n        }\n      }\n      // flag each as result of population\n      if (!lean) {\n        val.$__.wasPopulated = val.$__.wasPopulated || true;\n      }\n    }\n  }\n\n  assignVals({\n    originalModel: model,\n    // If virtual, make sure to not mutate original field\n    rawIds: mod.isVirtual ? allIds : mod.allIds,\n    allIds: allIds,\n    unpopulatedValues: mod.unpopulatedValues,\n    foreignField: mod.foreignField,\n    rawDocs: rawDocs,\n    rawOrder: rawOrder,\n    docs: mod.docs,\n    path: options.path,\n    options: assignmentOpts,\n    justOne: mod.justOne,\n    isVirtual: mod.isVirtual,\n    allOptions: mod,\n    populatedModel: mod.model,\n    lean: lean,\n    virtual: mod.virtual,\n    count: mod.count,\n    match: mod.match\n  });\n}\n\n/**\n * Compiler utility.\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} schema\n * @param {String} collectionName\n * @param {Connection} connection\n * @param {Mongoose} base mongoose instance\n * @api private\n */\n\nModel.compile = function compile(name, schema, collectionName, connection, base) {\n  const versioningEnabled = schema.options.versionKey !== false;\n\n  if (versioningEnabled && !schema.paths[schema.options.versionKey]) {\n    // add versioning to top level documents only\n    const o = {};\n    o[schema.options.versionKey] = Number;\n    schema.add(o);\n  }\n  let model;\n  if (typeof name === 'function' && name.prototype instanceof Model) {\n    model = name;\n    name = model.name;\n    schema.loadClass(model, false);\n    model.prototype.$isMongooseModelPrototype = true;\n  } else {\n    // generate new class\n    model = function model(doc, fields, skipId) {\n      model.hooks.execPreSync('createModel', doc);\n      if (!(this instanceof model)) {\n        return new model(doc, fields, skipId);\n      }\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (model.discriminators == null || doc == null || doc[discriminatorKey] == null) {\n        Model.call(this, doc, fields, skipId);\n        return;\n      }\n\n      // If discriminator key is set, use the discriminator instead (gh-7586)\n      const Discriminator = model.discriminators[doc[discriminatorKey]] ||\n        getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      if (Discriminator != null) {\n        return new Discriminator(doc, fields, skipId);\n      }\n\n      // Otherwise, just use the top-level model\n      Model.call(this, doc, fields, skipId);\n    };\n  }\n\n  model.hooks = schema.s.hooks.clone();\n  model.base = base;\n  model.modelName = name;\n\n  if (!(model.prototype instanceof Model)) {\n    Object.setPrototypeOf(model, Model);\n    Object.setPrototypeOf(model.prototype, Model.prototype);\n  }\n  model.model = function model(name) {\n    return this.db.model(name);\n  };\n\n  model.db = connection;\n  model.prototype.db = connection;\n  model.prototype[modelDbSymbol] = connection;\n  model.discriminators = model.prototype.discriminators = undefined;\n  model[modelSymbol] = true;\n  model.events = new EventEmitter();\n\n  schema._preCompile();\n\n  model.prototype.$__setSchema(schema);\n\n  const _userProvidedOptions = schema._userProvidedOptions || {};\n\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: schema.options.capped,\n    Promise: model.base.Promise,\n    modelName: name\n  };\n  if (schema.options.autoCreate !== void 0) {\n    collectionOptions.autoCreate = schema.options.autoCreate;\n  }\n\n  model.prototype.collection = connection.collection(\n    collectionName,\n    collectionOptions\n  );\n\n  model.prototype.$collection = model.prototype.collection;\n  model.prototype[modelCollectionSymbol] = model.prototype.collection;\n\n  // apply methods and statics\n  applyMethods(model, schema);\n  applyStatics(model, schema);\n  applyHooks(model, schema);\n  applyStaticHooks(model, schema.s.hooks, schema.statics);\n\n  model.schema = model.prototype.$__schema;\n  model.collection = model.prototype.collection;\n  model.$__collection = model.collection;\n\n  // Create custom query constructor\n  model.Query = function() {\n    Query.apply(this, arguments);\n  };\n  Object.setPrototypeOf(model.Query.prototype, Query.prototype);\n  model.Query.base = Query.base;\n  model.Query.prototype.constructor = Query;\n  applyQueryMiddleware(model.Query, model);\n  applyQueryMethods(model, schema.query);\n\n  return model;\n};\n\n/**\n * Register custom query methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\n\nfunction applyQueryMethods(model, methods) {\n  for (const i in methods) {\n    model.Query.prototype[i] = methods[i];\n  }\n}\n\n/**\n * Subclass this model with `conn`, `schema`, and `collection` settings.\n *\n * @param {Connection} conn\n * @param {Schema} [schema]\n * @param {String} [collection]\n * @return {Model}\n * @api private\n * @memberOf Model\n * @static\n * @method __subclass\n */\n\nModel.__subclass = function subclass(conn, schema, collection) {\n  // subclass model using this connection and collection name\n  const _this = this;\n\n  const Model = function Model(doc, fields, skipId) {\n    if (!(this instanceof Model)) {\n      return new Model(doc, fields, skipId);\n    }\n    _this.call(this, doc, fields, skipId);\n  };\n\n  Object.setPrototypeOf(Model, _this);\n  Object.setPrototypeOf(Model.prototype, _this.prototype);\n  Model.db = conn;\n  Model.prototype.db = conn;\n  Model.prototype[modelDbSymbol] = conn;\n\n  _this[subclassedSymbol] = _this[subclassedSymbol] || [];\n  _this[subclassedSymbol].push(Model);\n  if (_this.discriminators != null) {\n    Model.discriminators = {};\n    for (const key of Object.keys(_this.discriminators)) {\n      Model.discriminators[key] = _this.discriminators[key].\n        __subclass(_this.db, _this.discriminators[key].schema, collection);\n    }\n  }\n\n  const s = schema && typeof schema !== 'string'\n    ? schema\n    : _this.prototype.$__schema;\n\n  const options = s.options || {};\n  const _userProvidedOptions = s._userProvidedOptions || {};\n\n  if (!collection) {\n    collection = _this.prototype.$__schema.get('collection') ||\n      utils.toCollectionName(_this.modelName, this.base.pluralize());\n  }\n\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: s && options.capped\n  };\n\n  Model.prototype.collection = conn.collection(collection, collectionOptions);\n  Model.prototype.$collection = Model.prototype.collection;\n  Model.prototype[modelCollectionSymbol] = Model.prototype.collection;\n  Model.collection = Model.prototype.collection;\n  Model.$__collection = Model.collection;\n  // Errors handled internally, so ignore\n  Model.init().catch(() => {});\n  return Model;\n};\n\n/**\n * Helper for console.log. Given a model named 'MyModel', returns the string\n * `'Model { MyModel }'`.\n *\n * #### Example:\n *\n *     const MyModel = mongoose.model('Test', Schema({ name: String }));\n *     MyModel.inspect(); // 'Model { Test }'\n *     console.log(MyModel); // Prints 'Model { Test }'\n *\n * @api public\n */\n\nModel.inspect = function() {\n  return `Model { ${this.modelName} }`;\n};\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Model[util.inspect.custom] = Model.inspect;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Model;\n"],"mappings":"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C;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAN,MAAM,CAACS,cAAc,CAACN,KAAK,CAACO,SAAS,EAAE5E,QAAQ,CAAC4E,SAAS,CAAC;AAC1DP,KAAK,CAACO,SAAS,CAACC,yBAAyB,GAAG,IAAI;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAR,KAAK,CAACO,SAAS,CAACE,EAAE;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAT,KAAK,CAACO,SAAS,CAACG,UAAU;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGAV,KAAK,CAACO,SAAS,CAACI,aAAa;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAX,KAAK,CAACO,SAAS,CAACK,SAAS;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAZ,KAAK,CAACO,SAAS,CAACM,MAAM;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAb,KAAK,CAACO,SAAS,CAACO,aAAa;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAd,KAAK,CAACe,MAAM;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAf,KAAK,CAACgB,WAAW;;AAEjB;AACA;AACA;;AAEA,SAASC,iBAAiBA,CAAChB,GAAG,EAAEiB,KAAK,EAAE;EACrC,IAAIjB,GAAG,CAACY,MAAM,IAAI,IAAI,EAAE;IACtB;EACF;EACA,KAAK,MAAMM,GAAG,IAAItB,MAAM,CAACuB,IAAI,CAACnB,GAAG,CAACY,MAAM,CAAC,EAAE;IACzCK,KAAK,CAACC,GAAG,CAAC,GAAGlB,GAAG,CAACY,MAAM,CAACM,GAAG,CAAC;EAC9B;AACF;;AAEA;AACA;AACA;;AAEAnB,KAAK,CAACO,SAAS,CAACc,aAAa,GAAG,UAASC,OAAO,EAAEC,QAAQ,EAAE;EAC1D,MAAMC,WAA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"},"metadata":{},"sourceType":"script","externalDependencies":[]}