{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies\n */\nconst checkEmbeddedDiscriminatorKeyProjection = require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\nconst get = require('./helpers/get');\nconst getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst clone = require('./helpers/clone');\nconst isPathSelectedInclusive = require('./helpers/projection/isPathSelectedInclusive');\n\n/**\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.filter(p => (p && p.options && p.options.lean) == null).forEach(makeLean(options.lean));\n  }\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n  return pop;\n};\n\n/**\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.filter(p => (p && p.options && p.options.lean) == null).forEach(makeLean(options.lean));\n  }\n  const session = query && query.options && query.options.session || null;\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = {\n          session: session\n        };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n  const projection = query._fieldsForExec();\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n  return pop;\n};\n\n/**\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;\n  const key = discriminatorMapping && discriminatorMapping.isRoot ? discriminatorMapping.key : null;\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n  const _opts = {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  };\n  if (options != null && 'defaults' in options) {\n    _opts.defaults = options.defaults;\n  }\n  return new model(undefined, fields, _opts);\n};\n\n/*!\n * ignore\n */\n\nexports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {\n  const initOpts = populatedIds ? {\n    populated: populatedIds\n  } : undefined;\n  const casted = exports.createModel(model, doc, fields, userProvidedFields, options);\n  try {\n    casted.$init(doc, initOpts, callback);\n  } catch (error) {\n    callback(error, casted);\n  }\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  const minusPathsToSkip = new Set();\n  if (fields) {\n    keys = Object.keys(fields);\n\n    // Collapse minus paths\n    const minusPaths = [];\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      if (keys[i][0] !== '-') {\n        continue;\n      }\n      delete fields[key];\n      if (key === '-_id') {\n        fields['_id'] = 0;\n      } else {\n        minusPaths.push(key.slice(1));\n      }\n    }\n    keys = Object.keys(fields);\n    for (let keyIndex = 0; keyIndex < keys.length; ++keyIndex) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      // `_id: 1, name: 0` is a mixed inclusive/exclusive projection in\n      // MongoDB 4.0 and earlier, but not in later versions.\n      if (keys[keyIndex] === '_id' && keys.length > 1) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n\n    // Potentially add back minus paths based on schema-level path config\n    // and whether the projection is inclusive\n    for (const path of minusPaths) {\n      const type = schema.path(path);\n      // If the path isn't selected by default or the projection is not\n      // inclusive, minus path is treated as equivalent to `key: 0`.\n      // But we also allow using `-name` to remove `name` from an inclusive\n      // projection if `name` has schema-level `select: true`.\n      if (!type || !type.selected || exclude !== false) {\n        fields[path] = 0;\n      } else if (type && type.selected && exclude === false) {\n        // Make a note of minus paths that are overwriting paths that are\n        // included by default.\n        minusPathsToSkip.add(path);\n      }\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n  analyzeSchema(schema);\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema && schema.paths['_id'] && schema.paths['_id'].options && schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n      for (const fieldName of selected) {\n        if (minusPathsToSkip.has(fieldName)) {\n          continue;\n        }\n        if (isPathSelectedInclusive(fields, fieldName)) {\n          continue;\n        }\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        if (fields[fieldName] != null) {\n          // Skip applying default projections to fields with non-defining\n          // projections, like `$slice`\n          continue;\n        }\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n    const addedPaths = [];\n    schema.eachPath(function (path, type) {\n      if (prefix) path = prefix + '.' + path;\n      if (type.$isSchemaMap || path.endsWith('.$*')) {\n        const plusPath = '+' + path;\n        const hasPlusPath = fields && plusPath in fields;\n        if (type.options && type.options.select === false && !hasPlusPath) {\n          excluded.push(path);\n        }\n        return;\n      }\n      let addedPath = analyzePath(path, type);\n      // arrays\n      if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.caster);\n      }\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema, selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n  function analyzePath(path, type) {\n    if (fields == null) {\n      return;\n    }\n\n    // If schema-level selected not set, nothing to do\n    if (typeof type.selected !== 'boolean') {\n      return;\n    }\n\n    // User overwriting default exclusion\n    if (type.selected === false && fields[path]) {\n      return;\n    }\n\n    // If set to 0, we're explicitly excluding the discriminator key. Can't do this for all fields,\n    // because we have tests that assert that using `-path` to exclude schema-level `select: true`\n    // fields counts as an exclusive projection. See gh-11546\n    if (exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n    if (exclude === false && type.selected && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && (type && type.options && type.options.$skipDiscriminatorCheck || false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/**\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function (option) {\n    option.options || (option.options = {});\n    if (val != null && Array.isArray(val.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).map(path => path.slice(option.path.length + 1));\n    }\n    option.options.lean = val;\n  };\n}","map":{"version":3,"names":["checkEmbeddedDiscriminatorKeyProjection","require","get","getDiscriminatorByValue","isDefiningProjection","clone","isPathSelectedInclusive","exports","preparePopulationOptions","query","options","_populate","populate","pop","Object","keys","reduce","vals","key","concat","lean","filter","p","forEach","makeLean","opts","_localModel","model","preparePopulationOptionsMQ","_mongooseOptions","session","path","projection","_fieldsForExec","_queryProjection","createModel","doc","fields","userProvidedFields","hooks","execPreSync","discriminatorMapping","schema","isRoot","value","discriminators","discriminator","_fields","applyPaths","undefined","_opts","skipId","isNew","willInit","defaults","createModelAndInit","populatedIds","callback","initOpts","populated","casted","$init","error","exclude","minusPathsToSkip","Set","minusPaths","i","length","push","slice","keyIndex","field","type","selected","add","excluded","stack","analyzeSchema","fieldName","paths","select","_id","has","startsWith","prefix","indexOf","addedPaths","eachPath","$isSchemaMap","endsWith","plusPath","hasPlusPath","addedPath","analyzePath","Array","isArray","$isMongooseArray","$isMongooseDocumentArray","caster","_addedPaths","discriminatorKey","pieces","split","cur","$skipDiscriminatorCheck","val","option","virtuals","assign","map"],"sources":["C:/Users/sama/Documents/fullpage/node_modules/mongoose/lib/queryhelpers.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies\n */\n\nconst checkEmbeddedDiscriminatorKeyProjection =\n  require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\nconst get = require('./helpers/get');\nconst getDiscriminatorByValue =\n  require('./helpers/discriminator/getDiscriminatorByValue');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst clone = require('./helpers/clone');\nconst isPathSelectedInclusive = require('./helpers/projection/isPathSelectedInclusive');\n\n/**\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop\n      .filter(p => (p && p.options && p.options.lean) == null)\n      .forEach(makeLean(options.lean));\n  }\n\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n\n  return pop;\n};\n\n/**\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop\n      .filter(p => (p && p.options && p.options.lean) == null)\n      .forEach(makeLean(options.lean));\n  }\n\n  const session = query && query.options && query.options.session || null;\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n\n  return pop;\n};\n\n/**\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ?\n    model.schema.discriminatorMapping :\n    null;\n\n  const key = discriminatorMapping && discriminatorMapping.isRoot ?\n    discriminatorMapping.key :\n    null;\n\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n\n  const _opts = {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  };\n  if (options != null && 'defaults' in options) {\n    _opts.defaults = options.defaults;\n  }\n  return new model(undefined, fields, _opts);\n};\n\n/*!\n * ignore\n */\n\nexports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {\n  const initOpts = populatedIds ?\n    { populated: populatedIds } :\n    undefined;\n\n  const casted = exports.createModel(model, doc, fields, userProvidedFields, options);\n  try {\n    casted.$init(doc, initOpts, callback);\n  } catch (error) {\n    callback(error, casted);\n  }\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  const minusPathsToSkip = new Set();\n\n  if (fields) {\n    keys = Object.keys(fields);\n\n    // Collapse minus paths\n    const minusPaths = [];\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      if (keys[i][0] !== '-') {\n        continue;\n      }\n\n      delete fields[key];\n      if (key === '-_id') {\n        fields['_id'] = 0;\n      } else {\n        minusPaths.push(key.slice(1));\n      }\n    }\n\n    keys = Object.keys(fields);\n    for (let keyIndex = 0; keyIndex < keys.length; ++keyIndex) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      // `_id: 1, name: 0` is a mixed inclusive/exclusive projection in\n      // MongoDB 4.0 and earlier, but not in later versions.\n      if (keys[keyIndex] === '_id' && keys.length > 1) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n\n    // Potentially add back minus paths based on schema-level path config\n    // and whether the projection is inclusive\n    for (const path of minusPaths) {\n      const type = schema.path(path);\n      // If the path isn't selected by default or the projection is not\n      // inclusive, minus path is treated as equivalent to `key: 0`.\n      // But we also allow using `-name` to remove `name` from an inclusive\n      // projection if `name` has schema-level `select: true`.\n      if ((!type || !type.selected) || exclude !== false) {\n        fields[path] = 0;\n      } else if (type && type.selected && exclude === false) {\n        // Make a note of minus paths that are overwriting paths that are\n        // included by default.\n        minusPathsToSkip.add(path);\n      }\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n\n  analyzeSchema(schema);\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema &&\n          schema.paths['_id'] &&\n          schema.paths['_id'].options &&\n          schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n\n      for (const fieldName of selected) {\n        if (minusPathsToSkip.has(fieldName)) {\n          continue;\n        }\n        if (isPathSelectedInclusive(fields, fieldName)) {\n          continue;\n        }\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        if (fields[fieldName] != null) {\n          // Skip applying default projections to fields with non-defining\n          // projections, like `$slice`\n          continue;\n        }\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n\n    const addedPaths = [];\n    schema.eachPath(function(path, type) {\n      if (prefix) path = prefix + '.' + path;\n      if (type.$isSchemaMap || path.endsWith('.$*')) {\n        const plusPath = '+' + path;\n        const hasPlusPath = fields && plusPath in fields;\n        if (type.options && type.options.select === false && !hasPlusPath) {\n          excluded.push(path);\n        }\n        return;\n      }\n      let addedPath = analyzePath(path, type);\n      // arrays\n      if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.caster);\n      }\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema,\n            selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n\n  function analyzePath(path, type) {\n    if (fields == null) {\n      return;\n    }\n\n    // If schema-level selected not set, nothing to do\n    if (typeof type.selected !== 'boolean') {\n      return;\n    }\n\n    // User overwriting default exclusion\n    if (type.selected === false && fields[path]) {\n      return;\n    }\n\n    // If set to 0, we're explicitly excluding the discriminator key. Can't do this for all fields,\n    // because we have tests that assert that using `-path` to exclude schema-level `select: true`\n    // fields counts as an exclusive projection. See gh-11546\n    if (exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n\n    if (exclude === false && type.selected && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && (type && type.options && type.options.$skipDiscriminatorCheck || false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/**\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function(option) {\n    option.options || (option.options = {});\n\n    if (val != null && Array.isArray(val.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.\n        filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).\n        map(path => path.slice(option.path.length + 1));\n    }\n\n    option.options.lean = val;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}