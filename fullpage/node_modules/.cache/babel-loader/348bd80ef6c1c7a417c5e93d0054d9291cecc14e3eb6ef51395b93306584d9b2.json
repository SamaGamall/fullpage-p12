{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenEntryCache = exports.TokenEntry = void 0;\n/* 5 minutes in milliseonds */\nconst EXPIRATION_BUFFER_MS = 300000;\n/* Default expiration is now for when no expiration provided */\nconst DEFAULT_EXPIRATION_SECS = 0;\n/* Counter for function \"hashes\".*/\nlet FN_HASH_COUNTER = 0;\n/* No function present function */\nconst NO_FUNCTION = () => {\n  return Promise.resolve({\n    accessToken: 'test'\n  });\n};\n/* The map of function hashes */\nconst FN_HASHES = new WeakMap();\n/* Put the no function hash in the map. */\nFN_HASHES.set(NO_FUNCTION, FN_HASH_COUNTER);\n/** @internal */\nclass TokenEntry {\n  /**\n   * Instantiate the entry.\n   */\n  constructor(tokenResult, serverResult, expiration) {\n    this.tokenResult = tokenResult;\n    this.serverResult = serverResult;\n    this.expiration = expiration;\n  }\n  /**\n   * The entry is still valid if the expiration is more than\n   * 5 minutes from the expiration time.\n   */\n  isValid() {\n    return this.expiration - Date.now() > EXPIRATION_BUFFER_MS;\n  }\n}\nexports.TokenEntry = TokenEntry;\n/**\n * Cache of OIDC token entries.\n * @internal\n */\nclass TokenEntryCache {\n  constructor() {\n    this.entries = new Map();\n  }\n  /**\n   * Set an entry in the token cache.\n   */\n  addEntry(address, username, requestFn, refreshFn, tokenResult, serverResult) {\n    const entry = new TokenEntry(tokenResult, serverResult, expirationTime(tokenResult.expiresInSeconds));\n    this.entries.set(cacheKey(address, username, requestFn, refreshFn), entry);\n    return entry;\n  }\n  /**\n   * Clear the cache.\n   */\n  clear() {\n    this.entries.clear();\n  }\n  /**\n   * Delete an entry from the cache.\n   */\n  deleteEntry(address, username, requestFn, refreshFn) {\n    this.entries.delete(cacheKey(address, username, requestFn, refreshFn));\n  }\n  /**\n   * Get an entry from the cache.\n   */\n  getEntry(address, username, requestFn, refreshFn) {\n    return this.entries.get(cacheKey(address, username, requestFn, refreshFn));\n  }\n  /**\n   * Delete all expired entries from the cache.\n   */\n  deleteExpiredEntries() {\n    for (const [key, entry] of this.entries) {\n      if (!entry.isValid()) {\n        this.entries.delete(key);\n      }\n    }\n  }\n}\nexports.TokenEntryCache = TokenEntryCache;\n/**\n * Get an expiration time in milliseconds past epoch. Defaults to immediate.\n */\nfunction expirationTime(expiresInSeconds) {\n  return Date.now() + (expiresInSeconds ?? DEFAULT_EXPIRATION_SECS) * 1000;\n}\n/**\n * Create a cache key from the address and username.\n */\nfunction cacheKey(address, username, requestFn, refreshFn) {\n  return `${address}-${username}-${hashFunctions(requestFn, refreshFn)}`;\n}\n/**\n * Get the hash string for the request and refresh functions.\n */\nfunction hashFunctions(requestFn, refreshFn) {\n  let requestHash = FN_HASHES.get(requestFn || NO_FUNCTION);\n  let refreshHash = FN_HASHES.get(refreshFn || NO_FUNCTION);\n  if (!requestHash && requestFn) {\n    // Create a new one for the function and put it in the map.\n    FN_HASH_COUNTER++;\n    requestHash = FN_HASH_COUNTER;\n    FN_HASHES.set(requestFn, FN_HASH_COUNTER);\n  }\n  if (!refreshHash && refreshFn) {\n    // Create a new one for the function and put it in the map.\n    FN_HASH_COUNTER++;\n    refreshHash = FN_HASH_COUNTER;\n    FN_HASHES.set(refreshFn, FN_HASH_COUNTER);\n  }\n  return `${requestHash}-${refreshHash}`;\n}","map":{"version":3,"names":["EXPIRATION_BUFFER_MS","DEFAULT_EXPIRATION_SECS","FN_HASH_COUNTER","NO_FUNCTION","Promise","resolve","accessToken","FN_HASHES","WeakMap","set","TokenEntry","constructor","tokenResult","serverResult","expiration","isValid","Date","now","exports","TokenEntryCache","entries","Map","addEntry","address","username","requestFn","refreshFn","entry","expirationTime","expiresInSeconds","cacheKey","clear","deleteEntry","delete","getEntry","get","deleteExpiredEntries","key","hashFunctions","requestHash","refreshHash"],"sources":["C:\\Users\\sama\\Documents\\fullpage\\node_modules\\mongodb\\src\\cmap\\auth\\mongodb_oidc\\token_entry_cache.ts"],"sourcesContent":["import type {\n  OIDCMechanismServerStep1,\n  OIDCRefreshFunction,\n  OIDCRequestFunction,\n  OIDCRequestTokenResult\n} from '../mongodb_oidc';\n\n/* 5 minutes in milliseonds */\nconst EXPIRATION_BUFFER_MS = 300000;\n/* Default expiration is now for when no expiration provided */\nconst DEFAULT_EXPIRATION_SECS = 0;\n/* Counter for function \"hashes\".*/\nlet FN_HASH_COUNTER = 0;\n/* No function present function */\nconst NO_FUNCTION: OIDCRequestFunction = () => {\n  return Promise.resolve({ accessToken: 'test' });\n};\n/* The map of function hashes */\nconst FN_HASHES = new WeakMap<OIDCRequestFunction | OIDCRefreshFunction, number>();\n/* Put the no function hash in the map. */\nFN_HASHES.set(NO_FUNCTION, FN_HASH_COUNTER);\n\n/** @internal */\nexport class TokenEntry {\n  tokenResult: OIDCRequestTokenResult;\n  serverResult: OIDCMechanismServerStep1;\n  expiration: number;\n\n  /**\n   * Instantiate the entry.\n   */\n  constructor(\n    tokenResult: OIDCRequestTokenResult,\n    serverResult: OIDCMechanismServerStep1,\n    expiration: number\n  ) {\n    this.tokenResult = tokenResult;\n    this.serverResult = serverResult;\n    this.expiration = expiration;\n  }\n\n  /**\n   * The entry is still valid if the expiration is more than\n   * 5 minutes from the expiration time.\n   */\n  isValid() {\n    return this.expiration - Date.now() > EXPIRATION_BUFFER_MS;\n  }\n}\n\n/**\n * Cache of OIDC token entries.\n * @internal\n */\nexport class TokenEntryCache {\n  entries: Map<string, TokenEntry>;\n\n  constructor() {\n    this.entries = new Map();\n  }\n\n  /**\n   * Set an entry in the token cache.\n   */\n  addEntry(\n    address: string,\n    username: string,\n    requestFn: OIDCRequestFunction | null,\n    refreshFn: OIDCRefreshFunction | null,\n    tokenResult: OIDCRequestTokenResult,\n    serverResult: OIDCMechanismServerStep1\n  ): TokenEntry {\n    const entry = new TokenEntry(\n      tokenResult,\n      serverResult,\n      expirationTime(tokenResult.expiresInSeconds)\n    );\n    this.entries.set(cacheKey(address, username, requestFn, refreshFn), entry);\n    return entry;\n  }\n\n  /**\n   * Clear the cache.\n   */\n  clear(): void {\n    this.entries.clear();\n  }\n\n  /**\n   * Delete an entry from the cache.\n   */\n  deleteEntry(\n    address: string,\n    username: string,\n    requestFn: OIDCRequestFunction | null,\n    refreshFn: OIDCRefreshFunction | null\n  ): void {\n    this.entries.delete(cacheKey(address, username, requestFn, refreshFn));\n  }\n\n  /**\n   * Get an entry from the cache.\n   */\n  getEntry(\n    address: string,\n    username: string,\n    requestFn: OIDCRequestFunction | null,\n    refreshFn: OIDCRefreshFunction | null\n  ): TokenEntry | undefined {\n    return this.entries.get(cacheKey(address, username, requestFn, refreshFn));\n  }\n\n  /**\n   * Delete all expired entries from the cache.\n   */\n  deleteExpiredEntries(): void {\n    for (const [key, entry] of this.entries) {\n      if (!entry.isValid()) {\n        this.entries.delete(key);\n      }\n    }\n  }\n}\n\n/**\n * Get an expiration time in milliseconds past epoch. Defaults to immediate.\n */\nfunction expirationTime(expiresInSeconds?: number): number {\n  return Date.now() + (expiresInSeconds ?? DEFAULT_EXPIRATION_SECS) * 1000;\n}\n\n/**\n * Create a cache key from the address and username.\n */\nfunction cacheKey(\n  address: string,\n  username: string,\n  requestFn: OIDCRequestFunction | null,\n  refreshFn: OIDCRefreshFunction | null\n): string {\n  return `${address}-${username}-${hashFunctions(requestFn, refreshFn)}`;\n}\n\n/**\n * Get the hash string for the request and refresh functions.\n */\nfunction hashFunctions(\n  requestFn: OIDCRequestFunction | null,\n  refreshFn: OIDCRefreshFunction | null\n): string {\n  let requestHash = FN_HASHES.get(requestFn || NO_FUNCTION);\n  let refreshHash = FN_HASHES.get(refreshFn || NO_FUNCTION);\n  if (!requestHash && requestFn) {\n    // Create a new one for the function and put it in the map.\n    FN_HASH_COUNTER++;\n    requestHash = FN_HASH_COUNTER;\n    FN_HASHES.set(requestFn, FN_HASH_COUNTER);\n  }\n  if (!refreshHash && refreshFn) {\n    // Create a new one for the function and put it in the map.\n    FN_HASH_COUNTER++;\n    refreshHash = FN_HASH_COUNTER;\n    FN_HASHES.set(refreshFn, FN_HASH_COUNTER);\n  }\n  return `${requestHash}-${refreshHash}`;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}